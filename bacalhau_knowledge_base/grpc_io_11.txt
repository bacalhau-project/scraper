URL: https://grpc.io/blog/principles/

gRPCAboutMeetDocsGuidesShowcaseBlogCommunitygRPConf 2024 is happening NEXT WEEK onAug. 27th!-Register nowand get 25% off with the code GOOGLE25.BloggRPConf 2024 ScheduleCelebrate gRPC DayCan gRPC replace REST and WebSockets for Web Application Communication?Highlights in gRPConf 2023:Customer Showcase, Developer Engagement, Birds of Feathers Discussions and more.Announcing gRPConf 2023!gRPConf 2023 SchedulegRPC performance benchmarks on GKERunning gRPC and Protobuf on ARM64 (on Linux)The future of gRPC in C# belongs to grpc-dotnetAnalyzing gRPC messages using WiresharkInterceptors in gRPC-WebAnnouncing gRPC-JS 1.0Kotlin, meet gRPCgRPC comes to Cloud RunImprovements to gRPC's CMake Build System.NET Core ❤ gRPCDear gRPCThe state of gRPC in the browserVisualizing gRPC Language StacksgRPC-Web is Generally AvailableA short introduction to ChannelzgRPC on HTTP/2 Engineering a Robust, High-performance ProtocolgRPC + JSONTake the gRPC Survey!Gracefully clean up in gRPC JUnit testsgRPC Meets .NET SDK And Visual Studio: Automatic Codegen On BuildgRPC ❤ KotlinSo You Want to Optimize gRPC - Part 2So You Want to Optimize gRPC - Part 1gRPC and DeadlinesgRPC-Go Engineering PracticesThe gRPC Meetup KitgRPC-Go performance Improvements2017-08-17 Community Meeting UpdateAnnouncing out-of-the-box support for gRPC in the Flatbuffers serialization librarygRPC Load BalancinggRPC in HelmMigration to Google Cloud Platform — gRPC & grpc-gatewayBuilding gRPC services with bazel and rules_protobufgRPC at VSCOWhy we have decided to move our APIs to gRPCgRPC Project is now 1.0 and ready for production deploymentsMobile BenchmarksgRPC with REST and Open APIsgRPC - now with easy installationGoogle Cloud PubSub - with the power of gRPC!gRPC releases Beta, opening door for use in production environmentsgRPC Motivation and Design PrinciplesView page sourceEdit this pageCreate child pageCreate documentation issueCreate project issueMotivationPrinciples & RequirementsServices not Objects, Messages not ReferencesCoverage & SimplicityFree & OpenInteroperability & ReachGeneral Purpose & PerformantLayeredPayload AgnosticStreamingBlocking & Non-BlockingCancellation & TimeoutLameduckingFlow ControlPluggableExtensions as APIsMetadata ExchangeStandardized Status CodesRSSgRPC Motivation and Design PrinciplesByLouis Ryan(Google) |Tuesday, September 08, 2015ContentsMotivationPrinciples & RequirementsServices not Objects, Messages not ReferencesCoverage & SimplicityFree & OpenInteroperability & ReachGeneral Purpose & PerformantLayeredPayload AgnosticStreamingBlocking & Non-BlockingCancellation & TimeoutLameduckingFlow ControlPluggableExtensions as APIsMetadata ExchangeStandardized Status CodesMotivationGoogle has been using a single general-purpose RPC infrastructure called Stubby to connect the large number of microservices running within and across our data centers for over a decade. Our internal systems have long embraced the microservice architecture gaining popularity today. Having a uniform, cross-platform RPC infrastructure has allowed for the rollout of fleet-wide improvements in efficiency, security, reliability and behavioral analysis critical to supporting the incredible growth seen in that period.Stubby has many great features - however, it’s not based on any standard and is too tightly coupled to our internal infrastructure to be considered suitable for public release. With the advent of SPDY, HTTP/2, and QUIC, many of these same features have appeared in public standards, together with other features that Stubby does not provide. It became clear that it was time to rework Stubby to take advantage of this standardization, and to extend its applicability to mobile, IoT, and Cloud use-cases.Principles & RequirementsServices not Objects, Messages not ReferencesPromote the microservices design philosophy of coarse-grained message exchange between systems while avoiding thepitfalls of distributed objectsand thefallacies of ignoring the network.Coverage & SimplicityThe stack should be available on every popular development platform and easy for someone to build for their platform of choice. It should be viable on CPU and memory-limited devices.Free & OpenMake the fundamental features free for all to use. Release all artifacts as open-source efforts with licensing that should facilitate and not impede adoption.Interoperability & ReachThe wire protocol must be capable of surviving traversal over common internet infrastructure.General Purpose & PerformantThe stack should be applicable to a broad class of use-cases while sacrificing little in performance when compared to a use-case specific stack.LayeredKey facets of the stack must be able to evolve independently. A revision to the wire-format should not disrupt application layer bindings.Payload AgnosticDifferent services need to use different message types and encodings such as protocol buffers, JSON, XML, and Thrift; the protocol and implementations must allow for this. Similarly the need for payload compression varies by use-case and payload type: the protocol should allow for pluggable compression mechanisms.StreamingStorage systems rely on streaming and flow-control to express large data-sets. Other services, like voice-to-text or stock-tickers, rely on streaming to represent temporally related message sequences.Blocking & Non-BlockingSupport both asynchronous and synchronous processing of the sequence of messages exchanged by a client and server. This is critical for scaling and handling streams on certain platforms.Cancellation & TimeoutOperations can be expensive and long-lived - cancellation allows servers to reclaim resources when clients are well-behaved. When a causal-chain of work is tracked, cancellation can cascade. A client may indicate a timeout for a call, which allows services to tune their behavior to the needs of the client.LameduckingServers must be allowed to gracefully shut-down by rejecting new requests while continuing to process in-flight ones.Flow ControlComputing power and network capacity are often unbalanced between client and server. Flow control allows for better buffer management as well as providing protection from DOS by an overly active peer.PluggableA wire protocol is only part of a functioning API infrastructure. Large distributed systems need security, health-checking, load-balancing and failover, monitoring, tracing, logging, and so on. Implementations should provide extensions points to allow for plugging in these features and, where useful, default implementations.Extensions as APIsExtensions that require collaboration among services should favor using APIs rather than protocol extensions where possible. Extensions of this type could include health-checking, service introspection, load monitoring, and load-balancing assignment.Metadata ExchangeCommon cross-cutting concerns like authentication or tracing rely on the exchange of data that is not part of the declared interface of a service. Deployments rely on their ability to evolve these features at a different rate to the individual APIs exposed by services.Standardized Status CodesClients typically respond to errors returned by API calls in a limited number of ways. The status code namespace should be constrained to make these error handling decisions clearer. If richer domain-specific status is needed the metadata exchange mechanism can be used to provide that.←PreviousNext→View page sourceEdit this pageCreate child pageCreate documentation issueCreate project issue© 2024 gRPC AuthorsTerms|Privacy|Trademarks|License|About