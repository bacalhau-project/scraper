URL: https://nats.io/blog/jetstream-eventual-consistency/

AboutDownloadDocumentationBlogCommunitySupportPrivacyDelegate with trustVincent Vermersch— May 21, 2024Back to BlogWhen speaking about async patterns (messaging, event sourcing, etc.) with other developers, they often seemafraidof eventual consistency. However, it is often expressed in the form of:The frontend needs the answer directlyThe business process needs to be validated with perfect dataMy next page needs fresh data to display properlyWith a messaging system, you have to wait for the message to be processed and the state to be updated. Then you can query it withtrust. In the happy path, this could be something reasonable like 30ms, but it could be arbitrarily long if there is an interruption in the flow.With a classic CRUD system, you write to your database and query it directly with trust.How can I delegate the job and be sure that it’ll be done or that I get an error if it can’t be done?Let’s dive into use cases and tactics where I can gain the same trust using NATS JetStream.There can only be oneI have a payment system, and in this system, we must withdraw the customer for a givenorderIDonly once!
Sadly, our partner who triggers the payment can call us multiple times with sometimes a 1-day delay.Here, we use one subject per order to store its payment log.
The subject will contain only one message, the withdrawal.
Using publish expectations, I can be sure that there will be only one subject per order payment.constnc=connect();constjs=nc.jetstream();// Generate a unique order ID.constorderID=shortUID();// Using a lastSubjectSequence of 0 requires this message// to be the first one for the subject in the stream.awaitjs.publish(`payment.${orderID}`,Empty,{expect:{lastSubjectSequence:0}});The impatient clickerThe customer always clicks multiple times on the same button, so it calls the backend and duplicates messages!
This triggers side effects multiple times, creating spam and downstream issues for business intelligence.NATS JetStream has a built-in deduplication system based on message ID for a given time window. The window is configured in nanoseconds at the stream level.constnc=connect();constjsm=awaitnc.jetstreamManager();// Create the stream with an explicit 5s deduplication window.awaitjsm.streams.add({name:"a",subjects:["a.*"],duplicate_window:5_000_000_000});constjs=nc.jetstream();// If this message is published twice within 5s, only the first published will be stored.awaitjs.publish("a.b",Empty,{msgID:"a"});Business ruleIn my order process, I can’t refund more than the price of the order.I can query my order subject like I would query my database. Data is up to date.
Here, I’ll check theOrderPassedevent to get the amount and my business rule.constnc=connect();constjsm=awaitnc.jetstreamManager();constcodec=JSONCodec();constrefund={amount:10};// Create a temporary ordered consumer fetching all events for my order ID.constc=awaitjs.consumers.get(stream,{filterSubject:`*.${orderID}`});// Get all messages for this order and publish only if the condition matches.constmessages=awaitc.consume();forawait(constmofmessages){constevent=codec.decode(m.body);if(event.name=='OrderProcessed'){if(event.data.price<refund.amount){awaitjs.publish(`refund.${orderID}`,codec.encode(refund));break;}}}Yes, message processing like this can help to build a state from all previous events. You rebuild the freshest state fetching previous events.All these solutions could be elegantly applied in anAggregateif you need this tactic.Maintain OrderI have a payment system, and for the refund process, I need first to have double human validation. Then the refund can append. And it must append only once.For a refund subject, I will say that the refund must be exactly in 3rd place or fail.// connect to NATSconstnc=connect();// create a JetStream client:constjs=nc.jetstream();constorderID=shortUID();// The message should be the first on the subjectawaitjs.publish(`refund.${orderID}`,Empty,{expect:{lastSubjectSequence:2}});Hint :In NATS, the sequence applies to the whole stream.
In this example, I assume I have only one refund in the whole stream (which is not for production).For example, if I have in my streams 2 orders the sequences will be :refund.uuid-order-1 -> seq 1refund.uuid-order-1 -> seq 2refund.uuid-order-2 -> seq 3refund.uuid-order-2 -> seq 4refund.uuid-order-2 -> seq 5If I write my Refund after all this, thelastSubjectSequenceshould be 6 to maintain ordering.To get the current sequence :When subscribing to a subject, the received event contains the sequence. I can store the last subscribed and use it.Fetching the last event metadata before writing (as in theBusiness ruleexample).Save the sequence of your last write in memoryToo many eventsI have a boiler that sends an event every 10 milliseconds.
To adapt room temperature, I need to compare current temperature with an average water temperature from the last hour.To get this average water temperature I will need to read every events from the last hour, it means reading 36 0000 events.To make this faster, you can create onesnapshotevent every hour.
Then read this snapshot stream to validate your business rule.constnc=connect();constjsm=awaitnc.jetstreamManager();constcodec=JSONCodec();// Create a temporary ordered consumer fetching events from last hourconstc=awaitjs.consumers.get(stream,{filterSubject:`boiler.${boilerID}`});lettotalTemperature=0;lettemperaturePoints=0;letlastSnapshot=Date.now()/1000|0;// Subscription to build the snapshotconstmessages=awaitc.consume();forawait(constmofmessages){constevent=codec.decode(m.body);totalTemperature+=event.data.temperature;temperaturePoints++;if(event.data.created_at-lastSnapshot>=3600){constnow=Date.now()/1000|0;// Publish to snapshot subjectawaitjs.publish(`boiler.${boilerID}.hourly-snapshot`,{temperature:averageTemperature/temperaturePoints,created_at:now,temperature_points:temperaturePoints});totalTemperature=0;temperaturePoints=0;lastSnapshot=now;}}About the AuthorVincent Vermersch, SAAAS Architect. I build digital factories since 2002.
Mainly for data driven products on marketing and e-commerce industry.
Event sourcer, event modeler, Wardley mapper and micro phenomenology practitioner.Back to BlogCopyright © NATS Authors 2024NATS is aCloud Native Computing Foundationincubating projectThe Linux Foundation has registered trademarks and uses trademarks.For a list of trademarks of The Linux Foundation, please seeTrademark Usage page.