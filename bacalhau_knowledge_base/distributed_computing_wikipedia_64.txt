URL: https://en.wikipedia.org/wiki/Computer_program

Jump to contentMain menuMain menumove to sidebarhideNavigationMain pageContentsCurrent eventsRandom articleAbout WikipediaContact usDonateContributeHelpLearn to editCommunity portalRecent changesUpload fileSearchSearchAppearanceCreate accountLog inPersonal toolsCreate accountLog inPages for logged out editorslearn moreContributionsTalkContentsmove to sidebarhide(Top)1Example computer program2HistoryToggle History subsection2.1Analytical Engine2.2Universal Turing machine2.3ENIAC2.4Stored-program computers2.5Very Large Scale Integration2.6Sac State 80082.7x86 series2.8Changing programming environment3Programming paradigms and languagesToggle Programming paradigms and languages subsection3.1Generations of programming language3.2Imperative languages3.2.1Fortran3.2.2COBOL3.2.3Algol3.2.4Basic3.2.5C3.2.6C++3.3Declarative languages3.3.1Lisp3.3.2ML3.3.3Prolog3.4Object-oriented programming3.5Syntax and semantics4Software engineering and computer programmingToggle Software engineering and computer programming subsection4.1Performance objectives4.2Cost objectives4.3Waterfall model4.4Computer programmer4.5Program modules4.6Cohesion4.7Coupling4.8Data flow analysis5Functional categoriesToggle Functional categories subsection5.1Application software5.2Operating system5.2.1Kernel Program5.3Utility program5.4Microcode program6Notes7ReferencesToggle the table of contentsComputer program103 languagesAfrikaansالعربيةঅসমীয়াAsturianuAzərbaycancaবাংলা閩南語 / Bân-lâm-gúБеларускаяБеларуская (тарашкевіца)भोजपुरीБългарскиBosanskiBrezhonegCatalàČeštinaCymraegDeutschEestiΕλληνικάEspañolEsperantoEuskaraفارسیFrançaisFryskGaeilgeGàidhligGalego한국어Հայերենहिन्दीHrvatskiIdoBahasa IndonesiaIsiZuluÍslenskaItalianoעבריתქართულიҚазақшаKiswahiliКыргызчаລາວLatinaLatviešuLëtzebuergeschLietuviųLa .lojban.MagyarМакедонскиMalagasyമലയാളംმარგალურიBahasa Melayu閩東語 / Mìng-dĕ̤ng-ngṳ̄MirandésМокшеньМонголမြန်မာဘာသာNederlandsनेपाली日本語Norsk bokmålОлык марийOʻzbekcha / ўзбекчаپنجابیPolskiPortuguêsQaraqalpaqshaRomânăRuna SimiРусиньскыйРусскийScotsShqipSimple EnglishSlovenčinaSlovenščinaکوردیСрпски / srpskiSrpskohrvatski / српскохрватскиSuomiSvenskaTagalogதமிழ்TaqbaylitతెలుగుไทยТоҷикӣTürkçeBasa UgiУкраїнськаاردوTiếng ViệtVõroWalon文言Wolof吴语ייִדיש粵語中文ⵜⴰⵎⴰⵣⵉⵖⵜ ⵜⴰⵏⴰⵡⴰⵢⵜEdit linksArticleTalkEnglishReadEditView historyToolsToolsmove to sidebarhideActionsReadEditView historyGeneralWhat links hereRelated changesUpload fileSpecial pagesPermanent linkPage informationCite this pageGet shortened URLDownload QR codeWikidata itemPrint/exportDownload as PDFPrintable versionIn other projectsWikimedia CommonsAppearancemove to sidebarhideFrom Wikipedia, the free encyclopediaInstructions to be executed by a computerFor the TV program, seeThe Computer Programme.Source codefor a computer program written in theJavaScriptlanguageProgram executionGeneral conceptsCodeTranslationCompilerCompile timeOptimizing compilerIntermediate representation(IR)ExecutionRuntime systemRuntimeExecutableInterpreterVirtual machineTypes of codeSource codeObject codeBytecodeMachine codeMicrocodeCompilation strategiesAhead-of-time(AOT)Just-in-time(JIT)Tracing just-in-timeCompile and go systemPrecompilationTranscompilationRecompilationNotable runtimesAndroid Runtime(ART)BEAM(Erlang)Common Language Runtime(CLR) andMonoCPythonandPyPycrt0(Ctarget-specific initializer)Java virtual machine(JVM)LuaJITObjective-CandSwift'sV8andNode.jsZend Engine(PHP)Notable compilers & toolchainsGNU Compiler Collection(GCC)LLVMandClangMSVCvteAcomputer programis asequenceor set[a]of instructions in aprogramming languagefor acomputertoexecute. It is one component ofsoftware, which also includesdocumentationand other intangible components.[1]Acomputer programin itshuman-readableform is calledsource code. Source code needs another computer program toexecutebecause computers can only execute their nativemachine instructions. Therefore, source code may betranslatedto machine instructions using acompilerwritten for the language. (Assembly languageprograms are translated using anassembler.) The resulting file is called anexecutable. Alternatively, source code may execute within aninterpreterwritten for the language.[2]If the executable is requested for execution, then theoperating systemloadsit intomemoryand starts aprocess.[3]Thecentral processing unitwill soonswitchto this process so it canfetch, decode, and then executeeach machine instruction.[4]If the source code is requested for execution, then the operating system loads the corresponding interpreter into memory and starts a process. The interpreter then loads the source code into memory to translate and execute eachstatement. Running the source code is slower than running anexecutable.[5][b]Moreover, the interpreter must be installed on the computer.Example computer program[edit]The"Hello, World!" programis used to illustrate a language's basicsyntax. The syntax of the languageBASIC(1964) was intentionally limited to make the language easy to learn.[6]For example,variablesare notdeclaredbefore being used.[7]Also, variables are automatically initialized to zero.[7]Here is an example computer program, in Basic, toaveragea list of numbers:[8]10INPUT"How many numbers to average?",A20FORI=1TOA30INPUT"Enter number:",B40LETC=C+B50NEXTI60LETD=C/A70PRINT"The average is",D80ENDOnce the mechanics of basic computer programming are learned, more sophisticated and powerful languages are available to build large computer systems.[9]History[edit]See also:Computer programming § History,Programmer § History,History of computing,History of programming languages, andHistory of softwareImprovements insoftware developmentare the result of improvements incomputer hardware. At each stage in hardware's history, the task ofcomputer programmingchanged dramatically.Analytical Engine[edit]Lovelace's description from Note GIn 1837,Jacquard's loominspiredCharles Babbageto attempt to build theAnalytical Engine.[10]The names of the components of the calculating device were borrowed from the textile industry. In the textile industry, yarn was brought from the store to be milled. The device had astorewhich consisted of memory to hold 1,000 numbers of 50 decimal digits each.[11]Numbers from thestorewere transferred to themillfor processing. It was programmed using two sets of perforated cards. One set directed the operation and the other set inputted the variables.[10][12]However, the thousands of cogged wheels and gears never fully worked together.[13]Ada Lovelaceworked for Charles Babbage to create a description of the Analytical Engine (1843).[14]The description contained Note G which completely detailed a method for calculatingBernoulli numbersusing the Analytical Engine. This note is recognized by some historians as the world's firstcomputer program.[13]Universal Turing machine[edit]In 1936,Alan Turingintroduced theUniversal Turing machine, a theoretical device that can model every computation.[15]It is afinite-state machinethat has an infinitely long read/write tape. The machine can move the tape back and forth, changing its contents as it performs analgorithm. The machine starts in the initial state, goes through a sequence of steps, and halts when it encounters the halt state.[16]All present-day computers areTuring complete.[17]ENIAC[edit]Glenn A. Beck changing a tube in ENIACTheElectronic Numerical Integrator And Computer(ENIAC) was built between July 1943 and Fall 1945. It was aTuring complete, general-purpose computer that used 17,468vacuum tubesto create thecircuits. At its core, it was a series ofPascalineswired together.[18]Its 40 units weighed 30 tons, occupied 1,800 square feet (167 m2), and consumed $650 per hour (in 1940s currency) in electricity when idle.[18]It had 20base-10accumulators. Programming the ENIAC took up to two months.[18]Three function tables were on wheels and needed to be rolled to fixed function panels. Function tables were connected to function panels by plugging heavy black cables intoplugboards. Each function table had 728 rotating knobs. Programming the ENIAC also involved setting some of the 3,000 switches. Debugging a program took a week.[19]It ran from 1947 until 1955 atAberdeen Proving Ground, calculating hydrogen bomb parameters, predicting weather patterns, and producing firing tables to aim artillery guns.[20]Stored-program computers[edit]Instead of plugging in cords and turning switches, astored-program computerloads its instructions intomemoryjust like it loads its data into memory.[21]As a result, the computer could be programmed quickly and perform calculations at very fast speeds.[22]Presper EckertandJohn Mauchlybuilt the ENIAC. The two engineers introduced thestored-program conceptin a three-page memo dated February 1944.[23]Later, in September 1944,John von Neumannbegan working on the ENIAC project. On June 30, 1945, von Neumann published theFirst Draft of a Report on the EDVAC, which equated the structures of the computer with the structures of the human brain.[22]The design became known as thevon Neumann architecture. The architecture was simultaneously deployed in the constructions of theEDVACandEDSACcomputers in 1949.[24]TheIBM System/360(1964) was a family of computers, each having the sameinstruction set architecture. TheModel 20was the smallest and least expensive. Customers could upgrade and retain the sameapplication software.[25]TheModel 195was the most premium.  Each System/360 model featuredmultiprogramming[25]—having multipleprocessesinmemoryat once. When one process was waiting forinput/output, another could compute.IBM planned for each model to be programmed usingPL/1.[26]A committee was formed that includedCOBOL,FortranandALGOLprogrammers. The purpose was to develop a language that was comprehensive, easy to use, extendible, and would replace Cobol and Fortran.[26]The result was a large and complex language that took a long time tocompile.[27]Switches for manual input on aData General Nova3, manufactured in the mid-1970sComputers manufactured until the 1970s had front-panel switches for manual programming.[28]The computer program was written on paper for reference. An instruction was represented by a configuration of on/off settings. After setting the configuration, an execute button was pressed. This process was then repeated. Computer programs also were automatically inputted viapaper tape,punched cardsormagnetic-tape. After the medium was loaded, the starting address was set via switches, and the execute button was pressed.[28]Very Large Scale Integration[edit]A VLSI integrated-circuitdieA major milestone in software development was the invention of theVery Large Scale Integration(VLSI) circuit (1964).[29]FollowingWorld War II, tube-based technology was replaced withpoint-contact transistors(1947) andbipolar junction transistors(late 1950s) mounted on acircuit board.[29]During the 1960s, theaerospaceindustry replaced the circuit board with anintegrated circuit chip.[29]Robert Noyce, co-founder ofFairchild Semiconductor(1957) andIntel(1968), achieved a technological improvement to refine theproductionoffield-effect transistors(1963).[30]The goal is to alter theelectrical resistivity and conductivityof asemiconductor junction. First, naturally occurringsilicate mineralsare converted intopolysiliconrods using theSiemens process.[31]TheCzochralski processthen converts the rods into amonocrystalline silicon,boule crystal.[32]Thecrystalis then thinly sliced to form awafersubstrate. Theplanar processofphotolithographythenintegratesunipolar transistors,capacitors,diodes, andresistorsonto the wafer to build a matrix ofmetal–oxide–semiconductor(MOS) transistors.[33][34]The MOS transistor is the primary component inintegrated circuit chips.[30]Originally, integrated circuit chips had their function set during manufacturing. During the 1960s, controlling the electrical flow migrated to programming amatrixofread-only memory(ROM). The matrix resembled a two-dimensional array of fuses.[29]The process to embed instructions onto the matrix was to burn out the unneeded connections.[29]There were so many connections,firmwareprogrammers wrote acomputer programon another chip to oversee the burning.[29]The technology became known asProgrammable ROM. In 1971, Intelinstalled the computer program onto the chipand named it theIntel 4004microprocessor.[35]IBM's System/360 (1964) CPU was not a microprocessor.The termsmicroprocessorandcentral processing unit(CPU) are now used interchangeably. However, CPUs predate microprocessors. For example, theIBM System/360(1964) had a CPU made fromcircuit boards containing discrete components on ceramic substrates.[36]Sac State 8008[edit]Artist's depiction of Sacramento State University's Intel 8008 microcomputer (1972)The Intel 4004 (1971) was a 4-bitmicroprocessor designed to run theBusicomcalculator. Five months after its release, Intel released theIntel 8008, an 8-bit microprocessor. Bill Pentz led a team atSacramento Stateto build the firstmicrocomputerusing the Intel 8008: theSac State 8008(1972).[37]Its purpose was to store patient medical records. The computer supported adisk operating systemto run aMemorex, 3-megabyte,hard disk drive.[29]It had a color display and keyboard that was packaged in a single console. The disk operating system was programmed usingIBM's Basic Assembly Language (BAL). The medical records application was programmed using aBASICinterpreter.[29]However, the computer was an evolutionary dead-end because it was extremely expensive. Also, it was built at a public university lab for a specific purpose.[37]Nonetheless, the project contributed to the development of theIntel 8080(1974)instruction set.[29]x86 series[edit]The originalIBM Personal Computer(1981) used an Intel 8088 microprocessor.In 1978, the modernsoftware developmentenvironment began when Intel upgraded theIntel 8080to theIntel 8086. Intel simplified the Intel 8086 to manufacture the cheaperIntel 8088.[38]IBMembraced the Intel 8088 when they entered thepersonal computermarket (1981). Asconsumerdemandfor personal computers increased, so did Intel's microprocessor development. The succession of development is known as thex86 series. Thex86 assembly languageis a family ofbackward-compatiblemachine instructions. Machine instructions created in earlier microprocessors were retained throughout microprocessor upgrades. This enabled consumers to purchase new computers without having to purchase newapplication software.  The major categories of instructions are:[c]Memory instructions to set and access numbers andstringsinrandom-access memory.Integerarithmetic logic unit(ALU) instructions to perform the primary arithmetic operations onintegers.Floating point ALU instructions to perform the primary arithmetic operations onreal numbers.Call stackinstructions to push and popwordsneeded to allocate memory and interface withfunctions.Single instruction, multiple data(SIMD) instructions[d]to increase speed when multiple processors are available to perform the samealgorithmon anarray of data.Changing programming environment[edit]TheDECVT100(1978) was a widely usedcomputer terminal.VLSI circuits enabled theprogramming environmentto advance from acomputer terminal(until the 1990s) to agraphical user interface(GUI) computer. Computer terminals limited programmers to a singleshellrunning in acommand-line environment. During the 1970s, full-screen source code editing became possible through atext-based user interface. Regardless of the technology available, the goal is to program in aprogramming language.Programming paradigms and languages[edit]Programming languagefeatures exist to provide building blocks to be combined to express programming ideals.[39]Ideally, a programming language should:[39]express ideas directly in the code.express independent ideas independently.express relationships among ideas directly in the code.combine ideas freely.combine ideas only where combinations make sense.express simple ideas simply.Theprogramming styleof a programming language to provide these building blocks may be categorized intoprogramming paradigms.[40]For example, different paradigms may differentiate:[40]procedural languages,functional languages, andlogical languages.different levels ofdata abstraction.different levels ofclass hierarchy.different levels of inputdatatypes, as incontainer typesandgeneric programming.Each of these programming styles has contributed to the synthesis of differentprogramming languages.[40]Aprogramming languageis a set ofkeywords,symbols,identifiers, and rules by which programmers can communicate instructions to the computer.[41]They follow a set of rules called asyntax.[41]Keywordsare reserved words to formdeclarationsandstatements.Symbolsare characters to formoperations,assignments,control flow, anddelimiters.Identifiersare words created by programmers to formconstants,variable names,structure names, andfunction names.Syntax Rulesare defined in theBackus–Naur form.Programming languagesget their basis fromformal languages.[42]The purpose of defining a solution in terms of itsformal languageis to generate analgorithmto solve the underlining problem.[42]Analgorithmis a sequence of simple instructions that solve a problem.[43]Generations of programming language[edit]Main article:Programming language generationsMachine languagemonitor on aW65C816SmicroprocessorThe evolution of programming languages began when theEDSAC(1949) used the firststored computer programin itsvon Neumann architecture.[44]Programming the EDSAC was in the firstgeneration of programming language.Thefirst generation of programming languageismachine language.[45]Machine languagerequires the programmer to enter instructions usinginstruction numberscalledmachine code. For example, the ADD operation on thePDP-11has instruction number 24576.[46]Thesecond generation of programming languageisassembly language.[45]Assembly languageallows the programmer to usemnemonicinstructionsinstead of remembering instruction numbers. Anassemblertranslates each assembly language mnemonic into its machine language number. For example, on the PDP-11, the operation 24576 can be referenced as ADD in the source code.[46]The four basic arithmetic operations have assembly instructions like ADD, SUB, MUL, and DIV.[46]Computers also have instructions like DW (DefineWord) to reservememorycells. Then the MOV instruction can copyintegersbetweenregistersand memory.The basic structure of an assembly language statement is a label,operation,operand, and comment.[47]Labelsallow the programmer to work withvariable names. The assembler will later translate labels into physicalmemory addresses.Operationsallow the programmer to work with mnemonics. The assembler will later translate mnemonics into instruction numbers.Operandstell the assembler which data the operation will process.Commentsallow the programmer to articulate a narrative because the instructions alone are vague.The key characteristic of an assembly language program is it forms a one-to-one mapping to its corresponding machine language target.[48]Thethird generation of programming languageusescompilersandinterpretersto execute computer programs. The distinguishing feature of athird generationlanguage is its independence from particular hardware.[49]Early languages includeFortran(1958),COBOL(1959),ALGOL(1960), andBASIC(1964).[45]In 1973, theC programming languageemerged as ahigh-level languagethat produced efficient machine language instructions.[50]Whereasthird-generationlanguages historically generated many machine instructions for each statement,[51]C has statements that may generate a single machine instruction.[e]Moreover, anoptimizing compilermight overrule the programmer and produce fewer machine instructions than statements. Today, an entireparadigmof languages fill theimperative,third generationspectrum.Thefourth generation of programming languageemphasizes what output results are desired, rather than how programming statements should be constructed.[45]Declarative languagesattempt to limitside effectsand allow programmers to write code with relatively few errors.[45]One popularfourth generationlanguage is calledStructured Query Language(SQL).[45]Databasedevelopers no longer need to process each database record one at a time. Also, a simple statement can generate output records without having to understand how they are retrieved.Imperative languages[edit]Main article:Imperative programmingA computer program written in an imperative languageImperative languagesspecify a sequentialalgorithmusingdeclarations,expressions, andstatements:[52]Adeclarationintroduces avariablename to thecomputer programand assigns it to adatatype[53]– for example:var x: integer;Anexpressionyields a value – for example:2 + 2yields 4Astatementmightassignan expression to a variable or use the value of a variable to alter the program'scontrol flow– for example:x := 2 + 2;ifx = 4 then do_something();Fortran[edit]FORTRAN(1958) was unveiled as "The IBM Mathematical FORmula TRANslating system". It was designed for scientific calculations, withoutstringhandling facilities. Along withdeclarations,expressions, andstatements, it supported:arrays.subroutines."do" loops.It succeeded because:programming and debugging costs were below computer running costs.it was supported by IBM.applications at the time were scientific.[54]However, non-IBM vendors also wrote Fortran compilers, but with a syntax that would likely fail IBM's compiler.[54]TheAmerican National Standards Institute(ANSI) developed the first Fortran standard in 1966. In 1978, Fortran 77 became the standard until 1991. Fortran 90 supports:records.pointersto arrays.COBOL[edit]COBOL(1959) stands for "COmmon Business Oriented Language". Fortran manipulated symbols. It was soon realized that symbols did not need to be numbers, sostringswere introduced.[55]TheUS Department of Defenseinfluenced COBOL's development, withGrace Hopperbeing a major contributor. The statements were English-like and verbose. The goal was to design a language so managers could read the programs. However, the lack of structured statements hindered this goal.[56]COBOL's development was tightly controlled, so dialects did not emerge to require ANSI standards. As a consequence, it was not changed for 15 years until 1974. The 1990s version did make consequential changes, likeobject-oriented programming.[56]Algol[edit]ALGOL(1960) stands for "ALGOrithmic Language". It had a profound influence on programming language design.[57]Emerging from a committee of European and American programming language experts, it used standard mathematical notation and had a readable, structured design. Algol was first to define itssyntaxusing theBackus–Naur form.[57]This led tosyntax-directedcompilers. It added features like:block structure, where variables were local to their block.arrays with variable bounds."for" loops.functions.recursion.[57]Algol's direct descendants includePascal,Modula-2,Ada,DelphiandOberonon one branch. On another branch the descendants includeC,C++andJava.[57]Basic[edit]BASIC(1964) stands for "Beginner's All-Purpose Symbolic Instruction Code". It was developed atDartmouth Collegefor all of their students to learn.[8]If a student did not go on to a more powerful language, the student would still remember Basic.[8]A Basic interpreter was installed in themicrocomputersmanufactured in the late 1970s. As the microcomputer industry grew, so did the language.[8]Basic pioneered theinteractive session.[8]It offeredoperating systemcommands within its environment:The 'new' command created an empty slate.Statements evaluated immediately.Statements could be programmed by preceding them with line numbers.[f]The 'list' command displayed the program.The 'run' command executed the program.However, the Basic syntax was too simple for large programs.[8]Recent dialects added structure and object-oriented extensions.Microsoft'sVisual Basicis still widely used and produces agraphical user interface.[7]C[edit]C programming language(1973) got its name because the languageBCPLwas replaced withB, andAT&T Bell Labscalled the next version "C". Its purpose was to write theUNIXoperating system.[50]C is a relatively small language, making it easy to write compilers. Its growth mirrored the hardware growth in the 1980s.[50]Its growth also was because it has the facilities ofassembly language, but uses ahigh-level syntax. It added advanced features like:inline assembler.arithmetic on pointers.pointers to functions.bit operations.freely combining complexoperators.[50]Computer memory mapCallows the programmer to control which region of memory data is to be stored.Global variablesandstatic variablesrequire the fewestclock cyclesto store. Thestackis automatically used for the standard variabledeclarations.Heapmemory is returned to apointer variablefrom themalloc()function.Theglobal and static dataregion is located just above theprogramregion. (The program region is technically called thetextregion. It is where machine instructions are stored.)The global and static data region is technically two regions.[58]One region is called theinitializeddata segment, where variables declared with default values are stored. The other region is called theblock started by segment, where variables declared without default values are stored.Variables stored in theglobal and static dataregion have theiraddressesset at compile-time. They retain their values throughout the life of the process.The global and static region stores theglobal variablesthat are declared on top of (outside) themain()function.[59]Global variables are visible tomain()and every other function in the source code.On the other hand, variable declarations inside ofmain(), other functions, or within{}block delimitersarelocal variables. Local variables also includeformal parametervariables. Parameter variables are enclosed within the parenthesis of a function definition.[60]Parameters provide aninterfaceto the function.Local variablesdeclared using thestaticprefix are also stored in theglobal and static dataregion.[58]Unlike global variables, static variables are only visible within the function or block. Static variables always retain their value. An example usage would be the functionint increment_counter(){static int counter = 0; counter++; return counter;}[g]Thestackregion is a contiguous block of memory located near the top memory address.[61]Variables placed in the stack are populated from top to bottom.[h][61]Astack pointeris a special-purposeregisterthat keeps track of the last memory address populated.[61]Variables are placed into the stack via theassembly languagePUSH instruction. Therefore, the addresses of these variables are set duringruntime. The method for stack variables to lose theirscopeis via the POP instruction.Local variablesdeclared without thestaticprefix, including formal parameter variables,[62]are calledautomatic variables[59]and are stored in the stack.[58]They are visible inside the function or block and lose their scope upon exiting the function or block.Theheapregion is located below the stack.[58]It is populated from the bottom to the top. Theoperating systemmanages the heap using aheap pointerand a list of allocated memory blocks.[63]Like the stack, the addresses of heap variables are set during runtime. Anout of memoryerror occurs when the heap pointer and the stack pointer meet.Cprovides themalloc()library function toallocateheap memory.[i][64]Populating the heap with data is an additional copy function.[j]Variables stored in the heap are economically passed to functions using pointers. Without pointers, the entire block of data would have to be passed to the function via the stack.C++[edit]In the 1970s,software engineersneeded language support to break large projects down intomodules.[65]One obvious feature was to decompose large projectsphysicallyinto separatefiles. A less obvious feature was to decompose large projectslogicallyintoabstract data types.[65]At the time, languages supportedconcrete (scalar)datatypes likeintegernumbers,floating-pointnumbers, andstringsofcharacters. Abstract datatypes arestructuresof concrete datatypes, with a new name assigned. For example, alistof integers could be calledinteger_list.In object-oriented jargon, abstract datatypes are calledclasses. However, aclassis only a definition; no memory is allocated. When memory is allocated to a class andboundto anidentifier, it is called anobject.[66]Object-oriented imperative languagesdeveloped by combining the need for classes and the need for safefunctional programming.[67]A function, in an object-oriented language, is assigned to a class. An assigned function is then referred to as amethod,member function, oroperation.Object-oriented programmingis executingoperationsonobjects.[68]Object-oriented languagessupport a syntax to modelsubset/supersetrelationships. Inset theory, anelementof a subset inherits all the attributes contained in the superset. For example, a student is a person. Therefore, the set of students is a subset of the set of persons. As a result, students inherit all the attributes common to all persons. Additionally, students have unique attributes that other people do not have.Object-oriented languagesmodelsubset/supersetrelationships usinginheritance.[69]Object-oriented programmingbecame the dominant language paradigm by the late 1990s.[65]C++(1985) was originally called "C with Classes".[70]It was designed to expandC'scapabilities by adding the object-oriented facilities of the languageSimula.[71]An object-oriented module is composed of two files. The definitions file is called theheader file. Here is a C++header filefor theGRADE classin a simple school application:// grade.h// -------// Used to allow multiple source files to include// this header file without duplication errors.// ----------------------------------------------#ifndef GRADE_H#define GRADE_HclassGRADE{public:// This is the constructor operation.// ----------------------------------GRADE(constcharletter);// This is a class variable.// -------------------------charletter;// This is a member operation.// ---------------------------intgrade_numeric(constcharletter);// This is a class variable.// -------------------------intnumeric;};#endifAconstructoroperation is a function with the same name as the class name.[72]It is executed when the calling operation executes thenewstatement.A module's other file is thesource file. Here is a C++ source file for theGRADE classin a simple school application:// grade.cpp// ---------#include"grade.h"GRADE::GRADE(constcharletter){// Reference the object using the keyword 'this'.// ----------------------------------------------this->letter=letter;// This is Temporal Cohesion// -------------------------this->numeric=grade_numeric(letter);}intGRADE::grade_numeric(constcharletter){if((letter=='A'||letter=='a'))return4;elseif((letter=='B'||letter=='b'))return3;elseif((letter=='C'||letter=='c'))return2;elseif((letter=='D'||letter=='d'))return1;elseif((letter=='F'||letter=='f'))return0;elsereturn-1;}Here is a C++header filefor thePERSON classin a simple school application:// person.h// --------#ifndef PERSON_H#define PERSON_HclassPERSON{public:PERSON(constchar*name);constchar*name;};#endifHere is a C++source filefor thePERSON classin a simple school application:// person.cpp// ----------#include"person.h"PERSON::PERSON(constchar*name){this->name=name;}Here is a C++header filefor theSTUDENT classin a simple school application:// student.h// ---------#ifndef STUDENT_H#define STUDENT_H#include"person.h"#include"grade.h"// A STUDENT is a subset of PERSON.// --------------------------------classSTUDENT:publicPERSON{public:STUDENT(constchar*name);GRADE*grade;};#endifHere is a C++source filefor theSTUDENT classin a simple school application:// student.cpp// -----------#include"student.h"#include"person.h"STUDENT::STUDENT(constchar*name):// Execute the constructor of the PERSON superclass.// -------------------------------------------------PERSON(name){// Nothing else to do.// -------------------}Here is a driver program for demonstration:// student_dvr.cpp// ---------------#include<iostream>#include"student.h"intmain(void){STUDENT*student=newSTUDENT("The Student");student->grade=newGRADE('a');std::cout// Notice student inherits PERSON's name<<student->name<<": Numeric grade = "<<student->grade->numeric<<"\n";return0;}Here is amakefileto compile everything:# makefile# --------all:student_dvrclean:rmstudent_dvr*.ostudent_dvr:student_dvr.cppgrade.ostudent.operson.oc++student_dvr.cppgrade.ostudent.operson.o-ostudent_dvrgrade.o:grade.cppgrade.hc++-cgrade.cppstudent.o:student.cppstudent.hc++-cstudent.cppperson.o:person.cppperson.hc++-cperson.cppDeclarative languages[edit]Main article:Declarative programmingImperative languageshave one major criticism: assigning an expression to anon-localvariable may produce an unintendedside effect.[73]Declarative languagesgenerally omit the assignment statement and the control flow. They describewhatcomputation should be performed and nothowto compute it. Two broad categories of declarative languages arefunctional languagesandlogical languages.The principle behind afunctional languageis to uselambda calculusas a guide for a well definedsemantic.[74]In mathematics, a function is a rule that maps elements from anexpressionto a range ofvalues. Consider the function:times_10(x) = 10 * xTheexpression10 * xis mapped by the functiontimes_10()to a range ofvalues. Onevaluehappens to be 20. This occurs when x is 2. So, the application of the function is mathematically written as:times_10(2) = 20Afunctional languagecompiler will not store this value in a variable. Instead, it willpushthe value onto the computer'sstackbefore setting theprogram counterback to the calling function. The calling function will thenpopthe value from the stack.[75]Imperative languagesdo support functions. Therefore,functional programmingcan be achieved in an imperative language, if the programmer uses discipline. However, afunctional languagewill force this discipline onto the programmer through its syntax. Functional languages have a syntax tailored to emphasize thewhat.[76]A functional program is developed with a set of primitive functions followed by a single driver function.[73]Consider thesnippet:function max( a, b ){/* code omitted */}function min( a, b ){/* code omitted */}function range( a, b, c ) {return max( a, max( b, c ) ) - min( a, min( b, c ) );}The primitives aremax()andmin(). The driver function isrange(). Executing:put( range( 10, 4, 7) );will output 6.Functional languagesare used incomputer scienceresearch to explore new language features.[77]Moreover, their lack of side-effects have made them popular inparallel programmingandconcurrent programming.[78]However, application developers prefer theobject-oriented featuresofimperative languages.[78]Lisp[edit]Lisp(1958) stands for "LISt Processor".[79]It is tailored to processlists. A full structure of the data is formed by building lists of lists. In memory, atree data structureis built. Internally, the tree structure lends nicely forrecursivefunctions.[80]The syntax to build a tree is to enclose the space-separatedelementswithin parenthesis. The following is alistof three elements. The first two elements are themselves lists of two elements:((A B) (HELLO WORLD) 94)Lisp has functions to extract and reconstruct elements.[81]The functionhead()returns a list containing the first element in the list. The functiontail()returns a list containing everything but the first element. The functioncons()returns a list that is the concatenation of other lists. Therefore, the following expression will return the listx:cons(head(x), tail(x))One drawback of Lisp is when many functions are nested, the parentheses may look confusing.[76]Modern Lispenvironmentshelp ensure parenthesis match. As an aside, Lisp does support theimperative languageoperations of the assignment statement and goto loops.[82]Also,Lispis not concerned with thedatatypeof the elements at compile time.[83]Instead, it assigns (and may reassign) the datatypes atruntime. Assigning the datatype at runtime is calleddynamic binding.[84]Whereas dynamic binding increases the language's flexibility, programming errors may linger until late in thesoftware development process.[84]Writing large, reliable, and readable Lisp programs requires forethought. If properly planned, the program may be much shorter than an equivalentimperative languageprogram.[76]Lispis widely used inartificial intelligence. However, its usage has been accepted only because it hasimperative languageoperations, making unintended side-effects possible.[78]ML[edit]ML(1973)[85]stands for "Meta Language". ML checks to make sure only data of the same type are compared with one another.[86]For example, this function has one input parameter (an integer) and returns an integer:funtimes_10(n:int):int=10*n;MLis not parenthesis-eccentric likeLisp. The following is an application oftimes_10():times_10 2It returns "20 : int". (Both the results and the datatype are returned.)LikeLisp,MLis tailored to process lists. UnlikeLisp, each element is the same datatype.[87]Moreover,MLassigns the datatype of an element atcompile-time. Assigning the datatype at compile-time is calledstatic binding. Static binding increases reliability because the compiler checks the context of variables before they are used.[88]Prolog[edit]Prolog(1972) stands for "PROgramming in LOGic". It is alogic programminglanguage, based on formallogic. The language was developed byAlain Colmerauerand Philippe Roussel in Marseille, France. It is an implementation ofSelective Linear Definite clause resolution, pioneered byRobert Kowalskiand others at theUniversity of Edinburgh.[89]The building blocks of a Prolog program arefactsandrules. Here is a simple example:cat(tom).% tom is a catmouse(jerry).% jerry is a mouseanimal(X):-cat(X).% each cat is an animalanimal(X):-mouse(X).% each mouse is an animalbig(X):-cat(X).% each cat is bigsmall(X):-mouse(X).% each mouse is smalleat(X,Y):-mouse(X),cheese(Y).% each mouse eats each cheeseeat(X,Y):-big(X),small(Y).% each big animal eats each small animalAfter all the facts and rules are entered, then a question can be asked:Will Tom eat Jerry??-eat(tom,jerry).trueThe following example shows how Prolog will convert a letter grade to its numeric value:numeric_grade('A',4).numeric_grade('B',3).numeric_grade('C',2).numeric_grade('D',1).numeric_grade('F',0).numeric_grade(X,-1):-notX='A',notX='B',notX='C',notX='D',notX='F'.grade('The Student','A').?-grade('The Student',X),numeric_grade(X,Y).X='A',Y=4Here is a comprehensive example:[90]1) All dragons billow fire, or equivalently, a thing billows fire if the thing is a dragon:billows_fire(X):-is_a_dragon(X).2) A creature billows fire if one of its parents billows fire:billows_fire(X):-is_a_creature(X),is_a_parent_of(Y,X),billows_fire(Y).3) A thing X is a parent of a thing Y if X is the mother of Y or X is the father of Y:is_a_parent_of(X,Y):-is_the_mother_of(X,Y).is_a_parent_of(X,Y):-is_the_father_of(X,Y).4) A thing is a creature if the thing is a dragon:is_a_creature(X):-is_a_dragon(X).5) Norberta is a dragon, and Puff is a creature. Norberta is the mother of Puff.is_a_dragon(norberta).is_a_creature(puff).is_the_mother_of(norberta,puff).Rule (2) is arecursive(inductive) definition. It can be understood declaratively, without the need to understand how it is executed.Rule (3) shows howfunctionsare represented by using relations. Here, the mother and father functions ensure that every individual has only one mother and only one father.Prolog is an untyped language. Nonetheless,inheritancecan be represented by using predicates. Rule (4) asserts that a creature is a superclass of a dragon.Questions are answered usingbackward reasoning. Given the question:?-billows_fire(X).Prolog generates two answers :X=norbertaX=puffPractical applications for Prolog areknowledge representationandproblem solvinginartificial intelligence.Object-oriented programming[edit]Object-oriented programmingis a programming method to executeoperations(functions) onobjects.[91]The basic idea is to group the characteristics of aphenomenoninto an objectcontainerand give the container a name. Theoperationson the phenomenon are also grouped into the container.[91]Object-oriented programmingdeveloped by combining the need for containers and the need for safefunctional programming.[92]This programming method need not be confined to anobject-oriented language.[93]In an object-oriented language, an object container is called aclass. In a non-object-oriented language, adata structure(which is also known as arecord) may become an object container. To turn a data structure into an object container, operations need to be written specifically for the structure. The resulting structure is called anabstract datatype.[94]However,inheritancewill be missing. Nonetheless, this shortcoming can be overcome.Here is aC programming languageheader filefor theGRADE abstract datatypein a simple school application:/* grade.h *//* ------- *//* Used to allow multiple source files to include *//* this header file without duplication errors.   *//* ---------------------------------------------- */#ifndef GRADE_H#define GRADE_Htypedefstruct{charletter;}GRADE;/* Constructor *//* ----------- */GRADE*grade_new(charletter);intgrade_numeric(charletter);#endifThegrade_new()function performs the same algorithm as the C++constructoroperation.Here is a C programming languagesource filefor theGRADE abstract datatypein a simple school application:/* grade.c *//* ------- */#include"grade.h"GRADE*grade_new(charletter){GRADE*grade;/* Allocate heap memory *//* -------------------- */if(!(grade=calloc(1,sizeof(GRADE)))){fprintf(stderr,"ERROR in %s/%s/%d: calloc() returned empty.\n",__FILE__,__FUNCTION__,__LINE__);exit(1);}grade->letter=letter;returngrade;}intgrade_numeric(charletter){if((letter=='A'||letter=='a'))return4;elseif((letter=='B'||letter=='b'))return3;elseif((letter=='C'||letter=='c'))return2;elseif((letter=='D'||letter=='d'))return1;elseif((letter=='F'||letter=='f'))return0;elsereturn-1;}In the constructor, the functioncalloc()is used instead ofmalloc()because each memory cell will be set to zero.Here is a C programming languageheader filefor thePERSON abstract datatypein a simple school application:/* person.h *//* -------- */#ifndef PERSON_H#define PERSON_Htypedefstruct{char*name;}PERSON;/* Constructor *//* ----------- */PERSON*person_new(char*name);#endifHere is a C programming languagesource filefor thePERSON abstract datatypein a simple school application:/* person.c *//* -------- */#include"person.h"PERSON*person_new(char*name){PERSON*person;if(!(person=calloc(1,sizeof(PERSON)))){fprintf(stderr,"ERROR in %s/%s/%d: calloc() returned empty.\n",__FILE__,__FUNCTION__,__LINE__);exit(1);}person->name=name;returnperson;}Here is a C programming languageheader filefor theSTUDENT abstract datatypein a simple school application:/* student.h *//* --------- */#ifndef STUDENT_H#define STUDENT_H#include"person.h"#include"grade.h"typedefstruct{/* A STUDENT is a subset of PERSON. *//* -------------------------------- */PERSON*person;GRADE*grade;}STUDENT;/* Constructor *//* ----------- */STUDENT*student_new(char*name);#endifHere is a C programming languagesource filefor theSTUDENT abstract datatypein a simple school application:/* student.c *//* --------- */#include"student.h"#include"person.h"STUDENT*student_new(char*name){STUDENT*student;if(!(student=calloc(1,sizeof(STUDENT)))){fprintf(stderr,"ERROR in %s/%s/%d: calloc() returned empty.\n",__FILE__,__FUNCTION__,__LINE__);exit(1);}/* Execute the constructor of the PERSON superclass. *//* ------------------------------------------------- */student->person=person_new(name);returnstudent;}Here is a driver program for demonstration:/* student_dvr.c *//* ------------- */#include<stdio.h>#include"student.h"intmain(void){STUDENT*student=student_new("The Student");student->grade=grade_new('a');printf("%s: Numeric grade = %d\n",/* Whereas a subset exists, inheritance does not. */student->person->name,/* Functional programming is executing functions just-in-time (JIT) */grade_numeric(student->grade->letter));return0;}Here is amakefileto compile everything:# makefile# --------all:student_dvrclean:rmstudent_dvr*.ostudent_dvr:student_dvr.cgrade.ostudent.operson.ogccstudent_dvr.cgrade.ostudent.operson.o-ostudent_dvrgrade.o:grade.cgrade.hgcc-cgrade.cstudent.o:student.cstudent.hgcc-cstudent.cperson.o:person.cperson.hgcc-cperson.cThe formal strategy to build object-oriented objects is to:[95]Identify the objects. Most likely these will be nouns.Identify each object's attributes. What helps to describe the object?Identify each object's actions. Most likely these will be verbs.Identify the relationships from object to object. Most likely these will be verbs.For example:A person is a human identified by a name.A grade is an achievement identified by a letter.A student is a person who earns a grade.Syntax and semantics[edit]Production rules consist of a set of terminals and non-terminals.Thesyntaxof acomputer programis alistofproduction ruleswhich form itsgrammar.[96]A programming language's grammar correctly places itsdeclarations,expressions, andstatements.[97]Complementing thesyntaxof a language are itssemantics. Thesemanticsdescribe the meanings attached to various syntactic constructs.[98]A syntactic construct may need a semantic description because a production rule may have an invalid interpretation.[99]Also, different languages might have the same syntax; however, their behaviors may be different.The syntax of a language is formally described by listing the production rules. Whereas the syntax of anatural languageis extremely complicated, a subset of the English language can have this production rule listing:[100]asentenceis made up of anoun-phrasefollowed by averb-phrase;anoun-phraseis made up of anarticlefollowed by anadjectivefollowed by anoun;averb-phraseis made up of averbfollowed by anoun-phrase;anarticleis 'the';anadjectiveis 'big' oranadjectiveis 'small';anounis 'cat' oranounis 'mouse';averbis 'eats';The words inbold-faceare known asnon-terminals. The words in 'single quotes' are known asterminals.[101]From this production rule listing, complete sentences may be formed using a series of replacements.[102]The process is to replacenon-terminalswith either a validnon-terminalor a validterminal. The replacement process repeats until onlyterminalsremain. One valid sentence is:sentencenoun-phraseverb-phrasearticleadjectivenounverb-phrasetheadjectivenounverb-phrasethebignounverb-phrasethebigcatverb-phrasethebigcatverbnoun-phrasethebigcateatsnoun-phrasethebigcateatsarticleadjectivenounthebigcateatstheadjectivenounthebigcateatsthesmallnounthebigcateatsthesmallmouseHowever, another combination results in an invalid sentence:thesmallmouseeatsthebigcatTherefore, asemanticis necessary to correctly describe the meaning of aneatactivity.Oneproduction rulelisting method is called theBackus–Naur form(BNF).[103]BNF describes the syntax of a language and itself has asyntax. This recursive definition is an example of ameta-language.[98]Thesyntaxof BNF includes:::=which translates tois made up of a[n]when a non-terminal is to its right. It translates toiswhen a terminal is to its right.|which translates toor.<and>which surroundnon-terminals.Using BNF, a subset of the English language can have thisproduction rulelisting:<sentence>::=<noun-phrase><verb-phrase><noun-phrase>::=<article><adjective><noun><verb-phrase>::=<verb><noun-phrase><article>::=the<adjective>::=big | small<noun>::=cat | mouse<verb>::=eatsUsing BNF, a signed-integerhas theproduction rulelisting:[104]<signed-integer>::=<sign><integer><sign>::=+ | -<integer>::=<digit>|<digit><integer><digit>::=0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9Notice the recursive production rule:<integer>::=<digit>|<digit><integer>This allows for an infinite number of possibilities. Therefore, asemanticis necessary to describe a limitation of the number of digits.Notice the leading zero possibility in the production rules:<integer>::=<digit>|<digit><integer><digit>::=0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9Therefore, asemanticis necessary to describe that leading zeros need to be ignored.Two formal methods are available to describesemantics. They aredenotational semanticsandaxiomatic semantics.[105]Software engineering and computer programming[edit]Prior to programming languages,Betty JenningsandFran Bilasprogrammed theENIACby moving cables and setting switches.Software engineeringis a variety of techniques to producequalitycomputer programs.[106]Computer programmingis the process of writing or editingsource code. In a formal environment, asystems analystwill gather information from managers about all the organization's processes to automate. This professional then prepares adetailed planfor the new or modified system.[107]The plan is analogous to an architect's blueprint.[107]Performance objectives[edit]The systems analyst has the objective to deliver the right information to the right person at the right time.[108]The critical factors to achieve this objective are:[108]The quality of the output. Is the output useful for decision-making?The accuracy of the output. Does it reflect the true situation?The format of the output. Is the output easily understood?The speed of the output. Time-sensitive information is important when communicating with the customer in real time.Cost objectives[edit]Achieving performance objectives should be balanced with all of the costs, including:[109]Development costs.Uniqueness costs. A reusable system may be expensive. However, it might be preferred over a limited-use system.Hardware costs.Operating costs.Applying asystems development processwill mitigate the axiom: the later in the process an error is detected, the more expensive it is to correct.[110]Waterfall model[edit]Thewaterfall modelis an implementation of asystems development process.[111]As thewaterfalllabel implies, the basic phases overlap each other:[112]Theinvestigation phaseis to understand the underlying problem.Theanalysis phaseis to understand the possible solutions.Thedesign phaseis toplanthe best solution.Theimplementation phaseis to program the best solution.Themaintenance phaselasts throughout the life of the system. Changes to the system after it is deployed may be necessary.[113]Faults may exist, including specification faults, design faults, or coding faults. Improvements may be necessary. Adaption may be necessary to react to a changing environment.Computer programmer[edit]Acomputer programmeris a specialist responsible for writing or modifying the source code to implement the detailed plan.[107]A programming team is likely to be needed because most systems are too large to be completed by a single programmer.[114]However, adding programmers to a project may not shorten the completion time. Instead, it may lower the quality of the system.[114]To be effective, program modules need to be defined and distributed to team members.[114]Also, team members must interact with one another in a meaningful and effective way.[114]Computer programmers may beprogramming in the small: programming within a single module.[115]Chances are a module will execute modules located in other source code files. Therefore, computer programmers may beprogramming in the large: programming modules so they will effectively couple with each other.[115]Programming-in-the-large includes contributing to theapplication programming interface(API).Program modules[edit]Modular programmingis a technique to refineimperative languageprograms. Refined programs may reduce the software size, separate responsibilities, and thereby mitigatesoftware aging. Aprogram moduleis a sequence of statements that are bounded within ablockand together identified by a name.[116]Modules have afunction,context, andlogic:[117]Thefunctionof a module is what it does.Thecontextof a module are the elements being performed upon.Thelogicof a module is how it performs the function.The module's name should be derived first by itsfunction, then by itscontext. Itslogicshould not be part of the name.[117]For example,function compute_square_root( x )orfunction compute_square_root_integer( i : integer )are appropriate module names. However,function compute_square_root_by_division( x )is not.The degree of interactionwithina module is its level ofcohesion.[117]Cohesionis a judgment of the relationship between a module's name and itsfunction. The degree of interactionbetweenmodules is the level ofcoupling.[118]Couplingis a judgement of the relationship between a module'scontextand the elements being performed upon.Cohesion[edit]The levels of cohesion from worst to best are:[119]Coincidental Cohesion: A module has coincidental cohesion if it performs multiple functions, and the functions are completely unrelated. For example,function read_sales_record_print_next_line_convert_to_float(). Coincidental cohesion occurs in practice if management enforces silly rules. For example, "Every module will have between 35 and 50 executable statements."[119]Logical Cohesion: A module has logical cohesion if it has available a series of functions, but only one of them is executed. For example,function perform_arithmetic( perform_addition, a, b ).Temporal Cohesion: A module has temporal cohesion if it performs functions related to time. One example,function initialize_variables_and_open_files(). Another example,stage_one(),stage_two(), ...Procedural Cohesion: A module has procedural cohesion if it performs multiple loosely related functions. For example,function read_part_number_update_employee_record().Communicational Cohesion: A module has communicational cohesion if it performs multiple closely related functions. For example,function read_part_number_update_sales_record().Informational Cohesion: A module has informational cohesion if it performs multiple functions, but each function has its own entry and exit points. Moreover, the functions share the same data structure. Object-oriented classes work at this level.Functional Cohesion: a module has functional cohesion if it achieves a single goal working only on local variables. Moreover, it may be reusable in other contexts.Coupling[edit]The levels of coupling from worst to best are:[118]Content Coupling: A module has content coupling if it modifies a local variable of another function. COBOL used to do this with thealterverb.Common Coupling: A module has common coupling if it modifies a global variable.Control Coupling: A module has control coupling if another module can modify itscontrol flow. For example,perform_arithmetic( perform_addition, a, b ). Instead, control should be on the makeup of the returned object.Stamp Coupling: A module has stamp coupling if an element of a data structure passed as a parameter is modified. Object-oriented classes work at this level.Data Coupling: A module has data coupling if all of its input parameters are needed and none of them are modified. Moreover, the result of the function is returned as a single object.Data flow analysis[edit]A sample function-level data-flow diagramData flow analysisis a design method used to achieve modules offunctional cohesionanddata coupling.[120]The input to the method is adata-flow diagram. A data-flow diagram is a set of ovals representing modules. Each module's name is displayed inside its oval. Modules may be at the executable level or the function level.The diagram also has arrows connecting modules to each other. Arrows pointing into modules represent a set of inputs. Each module should have only one arrow pointing out from it to represent its single output object. (Optionally, an additional exception arrow points out.) Adaisy chainof ovals will convey an entirealgorithm. The input modules should start the diagram. The input modules should connect to the transform modules. The transform modules should connect to the output modules.[121]Functional categories[edit]A diagram showing that theuserinteracts with theapplication software. The application software interacts with theoperating system, which interacts with thehardware.Computer programsmay be categorized along functional lines. The main functional categories areapplication softwareandsystem software. System software includes theoperating system, which couplescomputer hardwarewith application software.[122]The purpose of the operating system is to provide an environment where application software executes in a convenient and efficient manner.[122]Both application software and system software executeutility programs. At the hardware level, amicrocode programcontrols the circuits throughout thecentral processing unit.Application software[edit]Main article:Application softwareApplication software is the key to unlocking the potential of the computer system.[123]Enterprise application softwarebundles accounting, personnel, customer, and vendor applications. Examples includeenterprise resource planning,customer relationship management, andsupply chain management software.Enterprise applications may be developed in-house as a one-of-a-kindproprietary software.[124]Alternatively, they may be purchased asoff-the-shelf software. Purchased software may be modified to providecustom software. If the application is customized, then either the company's resources are used or the resources are outsourced. Outsourced software development may be from the original software vendor or a third-party developer.[125]The potential advantages of in-house software are features and reports may be developed exactly to specification.[126]Management may also be involved in the development process and offer a level of control.[127]Management may decide to counteract a competitor's new initiative or implement a customer or vendor requirement.[128]A merger or acquisition may necessitate enterprise software changes. The potential disadvantages of in-house software are time and resource costs may be extensive.[124]Furthermore, risks concerning features and performance may be looming.The potential advantages of off-the-shelf software are upfront costs are identifiable, the basic needs should be fulfilled, and its performance and reliability have a track record.[124]The potential disadvantages of off-the-shelf software are it may have unnecessary features that confuse end users, it may lack features the enterprise needs, and the data flow may not match the enterprise's work processes.[124]One approach to economically obtaining a customized enterprise application is through anapplication service provider.[129]Specialty companies provide hardware, custom software, and end-user support. They may speed the development of new applications because they possess skilled information system staff. The biggest advantage is it frees in-house resources from staffing and managing complex computer projects.[129]Many application service providers target small, fast-growing companies with limited information system resources.[129]On the other hand, larger companies with major systems will likely have their technical infrastructure in place. One risk is having to trust an external organization with sensitive information. Another risk is having to trust the provider's infrastructure reliability.[129]Operating system[edit]See also:Operating systemProgram vs.Processvs.ThreadScheduling,Preemption,Context SwitchingAnoperating systemis the low-level software that supports a computer's basic functions, such asschedulingprocessesand controllingperipherals.[122]In the 1950s, the programmer, who was also the operator, would write a program and run it. After the program finished executing, the output may have been printed, or it may have been punched onto paper tape or cards for later processing.[28]More often than not the program did not work. The programmer then looked at the console lights and fiddled with the console switches. If less fortunate, a memory printout was made for further study. In the 1960s, programmers reduced the amount of wasted time by automating the operator's job. A program called anoperating systemwas kept in the computer at all times.[130]The termoperating systemmay refer to two levels of software.[131]The operating system may refer to thekernel programthat manages theprocesses,memory, anddevices. More broadly, the operating system may refer to the entire package of the central software. The package includes a kernel program,command-line interpreter,graphical user interface,utility programs, andeditor.[131]Kernel Program[edit]A kernel connects the application software to the hardware of a computer.The kernel's main purpose is to manage the limited resources of a computer:The kernel program should performprocess scheduling,[132]which is also known as acontext switch. The kernel creates aprocess control blockwhen acomputer programisselected for execution. However, an executing program gets exclusive access to thecentral processing unitonly for atime slice. To provide each user with theappearance of continuous access, the kernel quicklypreemptseach process control block to execute another one. The goal forsystem developersis to minimizedispatch latency.Physical memory is scattered around RAM and the hard disk. Virtual memory is one continuous block.The kernel program should performmemory management.When the kernel initiallyloadsan executable into memory, it divides the address space logically intoregions.[133]The kernel maintains a master-region table and many per-process-region (pregion) tables—one for each runningprocess.[133]These tables constitute thevirtual address space. The master-region table is used to determine where its contents are located inphysical memory. The pregion tables allow each process to have its own program (text) pregion, data pregion, and stack pregion.The program pregion stores machine instructions. Since machine instructions do not change, the program pregion may be shared by many processes of the same executable.[133]To save time and memory, the kernel may load only blocks of execution instructions from the disk drive, not the entire execution file completely.[132]The kernel is responsible for translating virtual addresses intophysical addresses. The kernel may request data from thememory controllerand, instead, receive apage fault.[134]If so, the kernel accesses thememory management unitto populate the physical data region and translate the address.[135]The kernel allocates memory from theheapupon request by a process.[64]When the process is finished with the memory, the process may request for it to befreed. If the process exits without requesting all allocated memory to be freed, then the kernel performsgarbage collectionto free the memory.The kernel also ensures that a process only accesses its own memory, and not that of the kernel or other processes.[132]The kernel program should performfile system management.[132]The kernel has instructions to create, retrieve, update, and delete files.The kernel program should performdevice management.[132]The kernel provides programs to standardize and simplify the interface to the mouse, keyboard, disk drives, printers, and other devices. Moreover, the kernel should arbitrate access to a device if two processes request it at the same time.The kernel program should performnetwork management.[136]The kernel transmits and receivespacketson behalf of processes. One key service is to find an efficientrouteto the target system.The kernel program should providesystem level functionsfor programmers to use.[137]Programmers access files through a relatively simple interface that in turn executes a relatively complicated low-level I/O interface. The low-level interface includes file creation,file descriptors, file seeking, physical reading, and physical writing.Programmers create processes through a relatively simple interface that in turn executes a relatively complicated low-level interface.Programmers perform date/time arithmetic through a relatively simple interface that in turn executes a relatively complicated low-level time interface.[138]The kernel program should provide acommunication channelbetween executing processes.[139]For a large software system, it may be desirable toengineerthe system into smaller processes. Processes may communicate with one another by sending and receivingsignals.Originally, operating systems were programmed inassembly; however, modern operating systems are typically written in higher-level languages likeC,Objective-C, andSwift.[k]Utility program[edit]Autility programis designed to aid system administration and software execution. Operating systems execute hardware utility programs to check the status of disk drives, memory, speakers, and printers.[140]A utility program may optimize the placement of a file on a crowded disk. System utility programs monitor hardware and network performance. When a metric is outside an acceptable range, a trigger alert is generated.[141]Utility programs include compression programs so data files are stored on less disk space.[140]Compressed programs also save time when data files are transmitted over the network.[140]Utility programs can sort and merge data sets.[141]Utility programs detectcomputer viruses.[141]Microcode program[edit]Main article:MicrocodeNOT gateNAND gateNOR gateAND gateOR gateAmicrocode programis the bottom-level interpreter that controls thedata pathof software-driven computers.[142](Advances inhardwarehave migrated these operations tohardware execution circuits.)[142]Microcode instructions allow the programmer to more easily implement thedigital logic level[143]—the computer's real hardware. The digital logic level is the boundary betweencomputer scienceandcomputer engineering.[144]Alogic gateis a tinytransistorthat can return one of two signals: on or off.[145]Having one transistor forms theNOT gate.Connecting two transistors in series forms theNAND gate.Connecting two transistors in parallel forms theNOR gate.Connecting a NOT gate to a NAND gate forms theAND gate.Connecting a NOT gate to a NOR gate forms theOR gate.These five gates form the building blocks ofbinary algebra—the digital logic functions of the computer.Microcode instructions aremnemonicsprogrammers may use to execute digital logic functions instead of forming them in binary algebra. They are stored in acentral processing unit's(CPU)control store.[146]These hardware-level instructions move data throughout thedata path.The micro-instruction cycle begins when themicrosequenceruses its microprogram counter tofetchthe nextmachine instructionfromrandom-access memory.[147]The next step is todecodethe machine instruction by selecting the proper output line to the hardware module.[148]The final step is toexecutethe instruction using the hardware module's set of gates.A symbolic representation of an ALUInstructions to perform arithmetic are passed through anarithmetic logic unit(ALU).[149]The ALU has circuits to perform elementary operations to add, shift, and compare integers. By combining and looping the elementary operations through the ALU, the CPU performs its complex arithmetic.Microcode instructions move data between the CPU and thememory controller. Memory controller microcode instructions manipulate tworegisters. Thememory address registeris used to access each memory cell's address. Thememory data registeris used to set and read each cell's contents.[150]Microcode instructions move data between the CPU and the manycomputer buses. Thedisk controller buswrites to and reads fromhard disk drives. Data is also moved between the CPU and other functional units via theperipheral component interconnect express bus.[151]Notes[edit]^TheProloglanguage allows for a database of facts and rules to be entered in any order. However, a question about a database must be at the very end.^An executable has eachmachine instructionready for theCPU.^For more information, visitX86 assembly language#Instruction types.^introduced in 1999^Operatorslikex++will usually compile to a single instruction.^The line numbers were typically incremented by 10 to leave room if additional statements were added later.^This function could be written more concisely asint increment_counter(){ static int counter; return ++counter;}. 1) Static variables are automatically initialized to zero. 2)++counteris a prefixincrement operator.^This is despite the metaphor of astack,which normally grows from bottom to top.^Calso provides thecalloc()function to allocate heap memory. It provides two additional services: 1) It allows the programmer to create anarrayof arbitrary size. 2) It sets eachmemory cellto zero.^Forstringvariables,Cprovides thestrdup()function. It executes both the allocation function and the copy function.^TheUNIXoperating system was written in C,macOSwas written in Objective-C, and Swift replaced Objective-C.References[edit]^"ISO/IEC 2382:2015".ISO. 2020-09-03.Archivedfrom the original on 2016-06-17. Retrieved2022-05-26.[Software includes] all or part of the programs, procedures, rules, and associated documentation of an information processing system.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 7.ISBN0-201-71012-9.An alternative to compiling a source program is to use an interpreter. An interpreter can directly execute a source program[.]^Silberschatz, Abraham (1994).Operating System Concepts, Fourth Edition. Addison-Wesley. p. 98.ISBN978-0-201-50480-4.^Tanenbaum, Andrew S. (1990).Structured Computer Organization, Third Edition. Prentice Hall. p.32.ISBN978-0-13-854662-5.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 7.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 30.ISBN0-201-71012-9.Their intention was to produce a language that was very simple for students to learn[.]^abcWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 31.ISBN0-201-71012-9.^abcdefWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 30.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 30.ISBN0-201-71012-9.The idea was that students could be merely casual users or go on from Basic to more sophisticated and powerful languages[.]^abMcCartney, Scott (1999).ENIAC – The Triumphs and Tragedies of the World's First Computer. Walker and Company. p.16.ISBN978-0-8027-1348-3.^Tanenbaum, Andrew S. (1990).Structured Computer Organization, Third Edition. Prentice Hall. p.14.ISBN978-0-13-854662-5.^Bromley, Allan G.(1998)."Charles Babbage's Analytical Engine, 1838"(PDF).IEEE Annals of the History of Computing.20(4): 29–45.doi:10.1109/85.728228.S2CID2285332.Archived(PDF)from the original on 2016-03-04. Retrieved2015-10-30.^abTanenbaum, Andrew S. (1990).Structured Computer Organization, Third Edition. Prentice Hall. p.15.ISBN978-0-13-854662-5.^J. Fuegi; J. Francis (October–December 2003), "Lovelace & Babbage and the creation of the 1843 'notes'",Annals of the History of Computing,25(4): 16, 19, 25,doi:10.1109/MAHC.2003.1253887^Rosen, Kenneth H. (1991).Discrete Mathematics and Its Applications. McGraw-Hill, Inc. p.654.ISBN978-0-07-053744-6.Turing machines can model all the computations that can be performed on a computing machine.^Linz, Peter (1990).An Introduction to Formal Languages and Automata. D. C. Heath and Company. p. 234.ISBN978-0-669-17342-0.^Linz, Peter (1990).An Introduction to Formal Languages and Automata. D. C. Heath and Company. p. 243.ISBN978-0-669-17342-0.[A]ll the common mathematical functions, no matter how complicated, are Turing-computable.^abcMcCartney, Scott (1999).ENIAC – The Triumphs and Tragedies of the World's First Computer. Walker and Company. p.102.ISBN978-0-8027-1348-3.^McCartney, Scott (1999).ENIAC – The Triumphs and Tragedies of the World's First Computer. Walker and Company. p.94.ISBN978-0-8027-1348-3.^McCartney, Scott (1999).ENIAC – The Triumphs and Tragedies of the World's First Computer. Walker and Company. p.107.ISBN978-0-8027-1348-3.^McCartney, Scott (1999).ENIAC – The Triumphs and Tragedies of the World's First Computer. Walker and Company. p.120.ISBN978-0-8027-1348-3.^abMcCartney, Scott (1999).ENIAC – The Triumphs and Tragedies of the World's First Computer. Walker and Company. p.118.ISBN978-0-8027-1348-3.^McCartney, Scott (1999).ENIAC – The Triumphs and Tragedies of the World's First Computer. Walker and Company. p.119.ISBN978-0-8027-1348-3.^McCartney, Scott (1999).ENIAC – The Triumphs and Tragedies of the World's First Computer. Walker and Company. p.123.ISBN978-0-8027-1348-3.^abTanenbaum, Andrew S. (1990).Structured Computer Organization, Third Edition. Prentice Hall. p.21.ISBN978-0-13-854662-5.^abWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 27.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 29.ISBN0-201-71012-9.^abcSilberschatz, Abraham (1994).Operating System Concepts, Fourth Edition. Addison-Wesley. p. 6.ISBN978-0-201-50480-4.^abcdefghi"Bill Pentz — A bit of Background: the Post-War March to VLSI". Digibarn Computer Museum. August 2008.Archivedfrom the original on March 21, 2022. RetrievedJanuary 31,2022.^abTo the Digital Age: Research Labs, Start-up Companies, and the Rise of MOS. Johns Hopkins University Press. 2002.ISBN9780801886393.Archivedfrom the original on February 2, 2023. RetrievedFebruary 3,2022.^Chalamala, Babu (2017)."Manufacturing of Silicon Materials for Microelectronics and Solar PV". Sandia National Laboratories.Archivedfrom the original on March 23, 2023. RetrievedFebruary 8,2022.^"Fabricating ICs Making a base wafer". Britannica.Archivedfrom the original on February 8, 2022. RetrievedFebruary 8,2022.^"Introduction to NMOS and PMOS Transistors". Anysilicon. 4 November 2021.Archivedfrom the original on 6 February 2022. RetrievedFebruary 5,2022.^"microprocessor definition". Britannica.Archivedfrom the original on April 1, 2022. RetrievedApril 1,2022.^"Chip Hall of Fame: Intel 4004 Microprocessor". Institute of Electrical and Electronics Engineers. July 2, 2018.Archivedfrom the original on February 7, 2022. RetrievedJanuary 31,2022.^"360 Revolution"(PDF). Father, Son & Co. 1990.Archived(PDF)from the original on 2022-10-10. RetrievedFebruary 5,2022.^ab"Inside the world's long-lost first microcomputer". c/net. January 8, 2010.Archivedfrom the original on February 1, 2022. RetrievedJanuary 31,2022.^"Bill Gates, Microsoft and the IBM Personal Computer". InfoWorld. August 23, 1982.Archivedfrom the original on 18 February 2023. Retrieved1 February2022.^abStroustrup, Bjarne (2013).The C++ Programming Language, Fourth Edition. Addison-Wesley. p. 10.ISBN978-0-321-56384-2.^abcStroustrup, Bjarne (2013).The C++ Programming Language, Fourth Edition. Addison-Wesley. p. 11.ISBN978-0-321-56384-2.^abStair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 159.ISBN0-619-06489-7.^abLinz, Peter (1990).An Introduction to Formal Languages and Automata. D. C. Heath and Company. p. 2.ISBN978-0-669-17342-0.^Weiss, Mark Allen (1994).Data Structures and Algorithm Analysis in C++. Benjamin/Cummings Publishing Company, Inc. p. 29.ISBN0-8053-5443-3.^Tanenbaum, Andrew S. (1990).Structured Computer Organization, Third Edition. Prentice Hall. p.17.ISBN978-0-13-854662-5.^abcdefStair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 160.ISBN0-619-06489-7.^abcTanenbaum, Andrew S. (1990).Structured Computer Organization, Third Edition. Prentice Hall. p.399.ISBN978-0-13-854662-5.^Tanenbaum, Andrew S. (1990).Structured Computer Organization, Third Edition. Prentice Hall. p.400.ISBN978-0-13-854662-5.^Tanenbaum, Andrew S. (1990).Structured Computer Organization, Third Edition. Prentice Hall. p.398.ISBN978-0-13-854662-5.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 26.ISBN0-201-71012-9.^abcdWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 37.ISBN0-201-71012-9.^Stair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 160.ISBN0-619-06489-7.With third-generation and higher-level programming languages, each statement in the language translates into several instructions in machine language.^Wilson, Leslie B. (1993).Comparative Programming Languages, Second Edition. Addison-Wesley. p. 75.ISBN978-0-201-56885-1.^Stroustrup, Bjarne (2013).The C++ Programming Language, Fourth Edition. Addison-Wesley. p. 40.ISBN978-0-321-56384-2.^abWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 16.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 24.ISBN0-201-71012-9.^abWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 25.ISBN0-201-71012-9.^abcdWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 19.ISBN0-201-71012-9.^abcd"Memory Layout of C Programs". 12 September 2011.Archivedfrom the original on 6 November 2021. Retrieved6 November2021.^abKernighan, Brian W.; Ritchie, Dennis M. (1988).The C Programming Language Second Edition. Prentice Hall. p. 31.ISBN0-13-110362-8.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 128.ISBN0-201-71012-9.^abcKerrisk, Michael (2010).The Linux Programming Interface. No Starch Press. p. 121.ISBN978-1-59327-220-3.^Kerrisk, Michael (2010).The Linux Programming Interface. No Starch Press. p. 122.ISBN978-1-59327-220-3.^Kernighan, Brian W.; Ritchie, Dennis M. (1988).The C Programming Language Second Edition. Prentice Hall. p. 185.ISBN0-13-110362-8.^abKernighan, Brian W.; Ritchie, Dennis M. (1988).The C Programming Language Second Edition. Prentice Hall. p. 187.ISBN0-13-110362-8.^abcWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 38.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 193.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 39.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 35.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 192.ISBN0-201-71012-9.^Stroustrup, Bjarne (2013).The C++ Programming Language, Fourth Edition. Addison-Wesley. p. 22.ISBN978-0-321-56384-2.^Stroustrup, Bjarne (2013).The C++ Programming Language, Fourth Edition. Addison-Wesley. p. 21.ISBN978-0-321-56384-2.^Stroustrup, Bjarne (2013).The C++ Programming Language, Fourth Edition. Addison-Wesley. p. 49.ISBN978-0-321-56384-2.^abWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 218.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 217.ISBN0-201-71012-9.^Weiss, Mark Allen (1994).Data Structures and Algorithm Analysis in C++. Benjamin/Cummings Publishing Company, Inc. p. 103.ISBN0-8053-5443-3.When there is a function call, all the important information needs to be saved, such as register values (corresponding to variable names) and the return address (which can be obtained from the program counter)[.] ... When the function wants to return, it ... restores all the registers. It then makes the return jump. Clearly, all of this work can be done using a stack, and that is exactly what happens in virtually every programming language that implements recursion.^abcWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 230.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 240.ISBN0-201-71012-9.^abcWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 241.ISBN0-201-71012-9.^Jones, Robin; Maynard, Clive; Stewart, Ian (December 6, 2012).The Art of Lisp Programming. Springer Science & Business Media. p. 2.ISBN9781447117193.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 220.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 221.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 229.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 227.ISBN0-201-71012-9.^abWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 222.ISBN0-201-71012-9.^Gordon, Michael J. C.(1996)."From LCF to HOL: a short history".Archivedfrom the original on 2016-09-05. Retrieved2021-10-30.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 233.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 235.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 55.ISBN0-201-71012-9.^Colmerauer, A.; Roussel, P. (1992)."The birth of Prolog"(PDF).ACM SIGPLAN Notices.28(3). Association for Computing Machinery: 5.doi:10.1145/155360.155362.^Kowalski, R., Dávila, J., Sartor, G. and Calejo, M., 2023. Logical English for law and education. In Prolog: The Next 50 Years (pp. 287-299). Cham: Springer Nature Switzerland.^abWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 35.ISBN0-201-71012-9.Simula was based on Algol 60 with one very important addition — the class concept. ... The basic idea was that the data (or data structure) and the operations performed on it belong together[.]^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 39.ISBN0-201-71012-9.Originally, a large number of experimental languages were designed, many of which combined object-oriented and functional programming.^Schach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. 284.ISBN0-256-08515-3.While it is true that OOD [(object oriented design)] as such is not supported by the majority of popular languages, a large subset of OOD can be used.^Weiss, Mark Allen (1994).Data Structures and Algorithm Analysis in C++. Benjamin/Cummings Publishing Company, Inc. p. 57.ISBN0-8053-5443-3.^Schach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. 285.ISBN0-256-08515-3.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 290.ISBN0-201-71012-9.The syntax (or grammar) of a programming language describes the correct form in which programs may be written[.]^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 78.ISBN0-201-71012-9.The main components of an imperative language are declarations, expressions, and statements.^abWilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 290.ISBN0-201-71012-9.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 294.ISBN0-201-71012-9.^Rosen, Kenneth H. (1991).Discrete Mathematics and Its Applications. McGraw-Hill, Inc. p.615.ISBN978-0-07-053744-6.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 291.ISBN0-201-71012-9.^Rosen, Kenneth H. (1991).Discrete Mathematics and Its Applications. McGraw-Hill, Inc. p.616.ISBN978-0-07-053744-6.^Rosen, Kenneth H. (1991).Discrete Mathematics and Its Applications. McGraw-Hill, Inc. p.623.ISBN978-0-07-053744-6.^Rosen, Kenneth H. (1991).Discrete Mathematics and Its Applications. McGraw-Hill, Inc. p.624.ISBN978-0-07-053744-6.^Wilson, Leslie B. (2001).Comparative Programming Languages, Third Edition. Addison-Wesley. p. 297.ISBN0-201-71012-9.^Schach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. Preface.ISBN0-256-08515-3.^abcStair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 507.ISBN0-619-06489-7.^abStair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 513.ISBN0-619-06489-7.^Stair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 514.ISBN0-619-06489-7.^Stair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 516.ISBN0-619-06489-7.^Schach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. 8.ISBN0-256-08515-3.^Stair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 517.ISBN0-619-06489-7.^Schach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. 345.ISBN0-256-08515-3.^abcdSchach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. 319.ISBN0-256-08515-3.^abSchach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. 331.ISBN0-256-08515-3.^Schach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. 216.ISBN0-256-08515-3.^abcSchach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. 219.ISBN0-256-08515-3.^abSchach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. 226.ISBN0-256-08515-3.^abSchach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. 220.ISBN0-256-08515-3.^Schach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. 258.ISBN0-256-08515-3.^Schach, Stephen R. (1990).Software Engineering. Aksen Associates Incorporated Publishers. p. 259.ISBN0-256-08515-3.^abcSilberschatz, Abraham (1994).Operating System Concepts, Fourth Edition. Addison-Wesley. p. 1.ISBN978-0-201-50480-4.^Stair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 147.ISBN0-619-06489-7.The key to unlocking the potential of any computer system is application software.^abcdStair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 147.ISBN0-619-06489-7.^Stair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 147.ISBN0-619-06489-7.[A] third-party software firm, often called a value-added software vendor, may develop or modify a software program to meet the needs of a particular industry or company.^Stair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 148.ISBN0-619-06489-7.Heading: Proprietary Software; Subheading: Advantages; Quote: You can get exactly what you need in terms of features, reports, and so on.^Stair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 148.ISBN0-619-06489-7.Heading: Proprietary Software; Subheading: Advantages; Quote: Being involved in the development offers a further level of control over the results.^Stair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 147.ISBN0-619-06489-7.Heading: Proprietary Software; Subheading: Advantages; Quote: There is more flexibility in making modifications that may be required to counteract a new initiative by one of your competitors or to meet new supplier and/or customer requirements.^abcdStair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 149.ISBN0-619-06489-7.^Tanenbaum, Andrew S. (1990).Structured Computer Organization, Third Edition. Prentice Hall. p.11.ISBN978-0-13-854662-5.^abKerrisk, Michael (2010).The Linux Programming Interface. No Starch Press. p. 21.ISBN978-1-59327-220-3.^abcdeKerrisk, Michael (2010).The Linux Programming Interface. No Starch Press. p. 22.ISBN978-1-59327-220-3.^abcBach, Maurice J. (1986).The Design of the UNIX Operating System. Prentice-Hall, Inc. p. 152.ISBN0-13-201799-7.^Tanenbaum, Andrew S. (2013).Structured Computer Organization, Sixth Edition. Pearson. p. 443.ISBN978-0-13-291652-3.^Lacamera, Daniele (2018).Embedded Systems Architecture. Packt. p. 8.ISBN978-1-78883-250-2.^Kerrisk, Michael (2010).The Linux Programming Interface. No Starch Press. p. 23.ISBN978-1-59327-220-3.^Kernighan, Brian W. (1984).The Unix Programming Environment. Prentice Hall. p. 201.ISBN0-13-937699-2.^Kerrisk, Michael (2010).The Linux Programming Interface. No Starch Press. p. 187.ISBN978-1-59327-220-3.^Haviland, Keith (1987).Unix System Programming. Addison-Wesley Publishing Company. p. 121.ISBN0-201-12919-1.^abcStair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 145.ISBN0-619-06489-7.^abcStair, Ralph M. (2003).Principles of Information Systems, Sixth Edition. Thomson. p. 146.ISBN0-619-06489-7.^abTanenbaum, Andrew S. (2013).Structured Computer Organization, Sixth Edition. Pearson. p. 6.ISBN978-0-13-291652-3.^Tanenbaum, Andrew S. (2013).Structured Computer Organization, Sixth Edition. Pearson. p. 243.ISBN978-0-13-291652-3.^Tanenbaum, Andrew S. (2013).Structured Computer Organization, Sixth Edition. Pearson. p. 147.ISBN978-0-13-291652-3.^Tanenbaum, Andrew S. (2013).Structured Computer Organization, Sixth Edition. Pearson. p. 148.ISBN978-0-13-291652-3.^Tanenbaum, Andrew S. (2013).Structured Computer Organization, Sixth Edition. Pearson. p. 253.ISBN978-0-13-291652-3.^Tanenbaum, Andrew S. (2013).Structured Computer Organization, Sixth Edition. Pearson. p. 255.ISBN978-0-13-291652-3.^Tanenbaum, Andrew S. (2013).Structured Computer Organization, Sixth Edition. Pearson. p. 161.ISBN978-0-13-291652-3.^Tanenbaum, Andrew S. (2013).Structured Computer Organization, Sixth Edition. Pearson. p. 166.ISBN978-0-13-291652-3.^Tanenbaum, Andrew S. (2013).Structured Computer Organization, Sixth Edition. Pearson. p. 249.ISBN978-0-13-291652-3.^Tanenbaum, Andrew S. (2013).Structured Computer Organization, Sixth Edition. Pearson. p. 111.ISBN978-0-13-291652-3.Retrieved from "https://en.wikipedia.org/w/index.php?title=Computer_program&oldid=1242619805"Categories:Computer programmingSoftwareHidden categories:Articles with short descriptionShort description is different from WikidataThis page was last edited on 27 August 2024, at 19:54(UTC).Text is available under theCreative Commons Attribution-ShareAlike License 4.0;
additional terms may apply. By using this site, you agree to theTerms of UseandPrivacy Policy. Wikipedia® is a registered trademark of theWikimedia Foundation, Inc., a non-profit organization.Privacy policyAbout WikipediaDisclaimersContact WikipediaCode of ConductDevelopersStatisticsCookie statementMobile view