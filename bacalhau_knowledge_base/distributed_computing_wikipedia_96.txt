URL: https://en.wikipedia.org/wiki/Event_driven_architecture

Jump to contentMain menuMain menumove to sidebarhideNavigationMain pageContentsCurrent eventsRandom articleAbout WikipediaContact usDonateContributeHelpLearn to editCommunity portalRecent changesUpload fileSearchSearchAppearanceCreate accountLog inPersonal toolsCreate accountLog inPages for logged out editorslearn moreContributionsTalkContentsmove to sidebarhide(Top)1Overview2Topologies3Event structure4Event flow layersToggle Event flow layers subsection4.1Event Producer4.2Event channel4.3Event processing engine4.4Downstream event-driven activity5Event processing stylesToggle Event processing styles subsection5.1Simple event processing5.2Event stream processing5.3Complex event processing5.4Online event processing6Extreme loose coupling and well distributedToggle Extreme loose coupling and well distributed subsection6.1Semantic Coupling and further research7Implementations and examplesToggle Implementations and examples subsection7.1Java Swing7.2JavaScript7.3Object Pascal8See also9Articles10References11External linksToggle the table of contentsEvent-driven architecture11 languagesČeštinaDeutschEspañolفارسیFrançais한국어עבריתMagyarРусскийУкраїнська粵語Edit linksArticleTalkEnglishReadEditView historyToolsToolsmove to sidebarhideActionsReadEditView historyGeneralWhat links hereRelated changesUpload fileSpecial pagesPermanent linkPage informationCite this pageGet shortened URLDownload QR codeWikidata itemPrint/exportDownload as PDFPrintable versionIn other projectsAppearancemove to sidebarhideFrom Wikipedia, the free encyclopedia(Redirected fromEvent driven architecture)Software architecture modelEvent-driven architecture(EDA) is asoftware architectureparadigm concerning the production and detection ofevents.Overview[edit]Aneventcan be defined as "a significant change instate".[1]For example, when a consumer purchases a car, the car's state changes from "for sale" to "sold". A car dealer's system architecture may treat this state change as an event whose occurrence can be made known to other applications within the architecture. From a formal perspective, what is produced, published, propagated, detected or consumed is a (typically asynchronous) message called the event notification, and not the event itself, which is the state change that triggered the message emission. Events do not travel, they just occur. However, the termeventis often usedmetonymicallyto denote the notification message itself, which may lead to some confusion. This is due to Event-driven architectures often being designed atopmessage-driven architectures, where such communication pattern requires one of the inputs to be text-only, the message, to differentiate how each communication should be handled.Thisarchitectural patternmay be applied by the design and implementation of applications and systems that transmit events amongloosely coupled software componentsandservices. An event-driven system typically consists of event emitters (or agents), event consumers (or sinks), and event channels. Emitters have the responsibility to detect, gather, and transfer events. An Event Emitter does not know the consumers of the event, it does not even know if a consumer exists, and in case it exists, it does not know how the event is used or further processed. Sinks have the responsibility of applying a reaction as soon as an event is presented. The reaction might or might not be completely provided by the sink itself. For instance, the sink might just have the responsibility to filter, transform and forward the event to another component or it might provide a self-contained reaction to such an event. Event channels are conduits in which events are transmitted from event emitters to event consumers. The knowledge of the correct distribution of events is exclusively present within the event channel.[citation needed]The physical implementation of event channels can be based on traditional components such asmessage-oriented middlewareor point-to-point communication which might require a more appropriatetransactional executive framework[clarify].Building systems around an event-driven architecture simplifies horizontal scalability indistributed computingmodels and makes them more resilient to failure. This is because application state can be copied across multiple parallel snapshots for high-availability.[2]New events can be initiated anywhere, but more importantly propagate across the network of data stores updating each as they arrive. Adding extra nodes becomes trivial as well: you can simply take a copy of the application state, feed it a stream of events and run with it.[3]Event-driven architecture can complementservice-oriented architecture(SOA) because services can be activated by triggers fired on incoming events.[4][5]This paradigm is particularly useful whenever the sink does not provide anyself-contained executive[clarify].SOA 2.0evolves the implications SOA and EDA architectures provide to a richer, more robust level by leveraging previously unknown causal relationships to form a new event pattern.[vague]This newbusiness intelligencepattern triggers further autonomous human or automated processing that adds exponential value to the enterprise by injecting value-added information into the recognized pattern which could not have been achieved previously.[vague]Topologies[edit]Event driven architecture has two primary topologies: “broker topology” wherein components broadcast events to the entire system without any orchestrator. It provides the highest performance and scalability. Whereas in “mediator topology” there is a central orchestrator which controls workflow of events. It provides better control and error handling capabilities. You can also use a hybrid model and combine these two topologies.[6]Event structure[edit]An event can be made of two parts, the event header and the event body. The event header might include information such as event name, time stamp for the event, and type of event.
The event body provides the details of the state change detected. An event body should not be confused with the pattern or the logic that may be applied in reaction to the occurrence of the event itself.Event flow layers[edit]An event driven architecture may be built on four logical layers, starting with the sensing of an event (i.e., a significant temporal state or fact), proceeding to the creation of its technical representation in the form of an event structure and ending with a non-empty set of reactions to that event.[7]Event Producer[edit]The first logical layer is the event producer, which senses a fact and represents that fact as an event message. As an example, an event producer could be an email client, an E-commerce system, a monitoring agent or some type of physical sensor.Converting the data collected from such a diverse set of data sources to a single standardized form of data for evaluation is a significant task in the design and implementation of this first logical layer.[7]However, considering that an event is a strongly declarative frame, any informational operations can be easily applied, thus eliminating the need for a high level of standardization.[citation needed]Event channel[edit]This is the second logical layer. An event channel is a mechanism of propagating the information collected from an event generator to the event engine[7]or sink.
This could be a TCP/IP connection, or any type of an input file (flat, XML format, e-mail, etc.). Several event channels can be opened at the same time. Usually, because the event processing engine has to process them in near real time, the event channels will be read asynchronously. The events are stored in a queue, waiting to be processed later by the event processing engine.Event processing engine[edit]The event processing engine is the logical layer responsible for identifying an event, and then selecting and executing the appropriate reaction. It can also trigger a number of assertions. For example, if the event that comes into the event processing engine is a product ID low in stock, this may trigger reactions such as “Order product ID” and “Notify personnel”.[7]Downstream event-driven activity[edit]This is the logical layer where the consequences of the event are shown. This can be done in many different ways and forms; e.g., an email is sent to someone and an application may display some kind of warning on the screen.[7]Depending on the level of automation provided by the sink (event processing engine) the downstream activity might not be required.Event processing styles[edit]There are three general styles of event processing: simple, stream, and complex. The three styles are often used together in a mature event-driven architecture.[7]Simple event processing[edit]Simple event processing concerns events that are directly related to specific, measurable changes of condition. In simple event processing, a notable event happens which initiates downstream action(s). Simple event processing is commonly used to drive the real-time flow of work, thereby reducing lag time and cost.[7]For example, simple events can be created by a sensor detecting changes in tire pressures or ambient temperature. The car's tire incorrect pressure will generate a simple event from the sensor that will trigger a yellow light advising the driver about the state of a tire.Event stream processing[edit]Main article:Event stream processingInevent stream processing(ESP), both ordinary and notable events happen. Ordinary events (orders, RFID transmissions) are screened for notability and streamed to information subscribers. Event stream processing is commonly used to drive the real-time flow of information in and around the enterprise, which enables in-time decision making.[7]Complex event processing[edit]Main article:Complex event processingComplex event processing(CEP) allows patterns of simple and ordinary events to be considered to infer that a complex event has occurred. Complex event processing evaluates a confluence of events and then takes action. The events (notable or ordinary) may cross event types and occur over a long period of time. The event correlation may be causal, temporal, or spatial. CEP requires the employment of sophisticated event interpreters, event pattern definition and matching, and correlation techniques. CEP is commonly used to detect and respond to business anomalies, threats, and opportunities.[7]Online event processing[edit]Online event processing(OLEP) uses asynchronous distributed event logs to process complex events and manage persistent data.[8]OLEP allows reliably composing related events of a complex scenario across heterogeneous systems.  It thereby enables very flexible distribution patterns with high scalability and offers strong consistency. However, it cannot guarantee upper bounds on processing time.Extreme loose coupling and well distributed[edit]An event-driven architecture is extremely loosely coupled and well distributed. The great distribution of this architecture exists because an event can be almost anything and exist almost anywhere. The architecture is extremely loosely coupled because the event itself doesn't know about the consequences of its cause. e.g. If we have an alarm system that records information when the front door opens, the door itself doesn't know that the alarm system will add information when the door opens, just that the door has been opened.[7]Semantic Coupling and further research[edit]Event-driven architectures have loose coupling within space, time and synchronization, providing a scalable infrastructure for information exchange and distributed workflows. However, event-architectures are tightly coupled, via event subscriptions and patterns, to the semantics of the underlying event schema and values. The high degree of semantic heterogeneity of events in large and open deployments such as smart cities and the sensor web makes it difficult to develop and maintain event-based systems. In order to address semantic coupling within event-based systems the use of approximatesemantic matchingof events is an active area of research.[9]Implementations and examples[edit]Java Swing[edit]Main article:Swing (Java)TheJavaSwingAPI is based on an event-driven architecture. This works particularly well with the motivation behind Swing to provide user interface related components and functionality. The API uses a nomenclature convention (e.g. "ActionListener" and "ActionEvent") to relate and organize event concerns. A class which needs to be aware of a particular event simply implements the appropriate listener, overrides the inherited methods, and is then added to the object that fires the event. A very simple example could be:publicclassFooPanelextendsJPanelimplementsActionListener{publicFooPanel(){super();JButtonbtn=newJButton("Click Me!");btn.addActionListener(this);this.add(btn);}@OverridepublicvoidactionPerformed(ActionEventae){System.out.println("Button has been clicked!");}}Alternatively, another implementation choice is to add the listener to the object as ananonymous classand thus use the lambda notation (since Java 1.8). Below is an example.publicclassFooPanelextendsJPanel{publicFooPanel(){super();JButtonbtn=newJButton("Click Me!");btn.addActionListener(ae->System.out.println("Button has been clicked!"));this.add(btn);}}JavaScript[edit](()=>{'use strict';classEventEmitter{constructor(){this.events=newMap();}on(event,listener){if(typeoflistener!=='function'){thrownewTypeError('The listener must be a function');}letlisteners=this.events.get(event);if(!listeners){listeners=newSet();this.events.set(event,listeners);}listeners.add(listener);returnthis;}off(event,listener){if(!arguments.length){this.events.clear();}elseif(arguments.length===1){this.events.delete(event);}else{constlisteners=this.events.get(event);if(listeners){listeners.delete(listener);}}returnthis;}emit(event,...args){constlisteners=this.events.get(event);if(listeners){for(letlisteneroflisteners){listener.apply(this,args);}}returnthis;}}this.EventEmitter=EventEmitter;})();Usage:constevents=newEventEmitter();events.on('foo',()=>{console.log('foo');});events.emit('foo');// Prints "foo"events.off('foo');events.emit('foo');// Nothing will happenObject Pascal[edit]Main article:Object PascalEvents are one of the fundamental elements of theObject Pascallanguage. The uni-cast model (one-to-one) is used here, i.e. the sender sends information to only one recipient. This limitation has the advantage that it does not need a special event listener. The event itself is a pointer to a method in another object. If the pointer is not empty, when an event occurs, the event handler is called. Events are commonly used in classes that support GUI. This is not the only area of application for events, however. The following code is an example of using events:unitMyCustomClass;interfaceusesClasses;type{definition of your own event}TAccidentEvent=procedure(Sender:TObject;constAValue:Integer)ofobject;TMyCustomObject=class(TObject)privateFData:Integer;// an example of a simple field in a classFOnAccident:TAccidentEvent;// event - reference to a method in some objectFOnChange:TNotifyEvent;// event - reference to a method in some objectprocedureSetData(Value:Integer);// a method that sets the value of a field in the classprotectedprocedureDoAccident(constAValue:Integer);virtual;// a method that generates an event based on your own definitionprocedureDoChange;// a method that generates an event based on a definition from the VCL librarypublicconstructorCreate;virtual;// class constructordestructorDestroy;override;// class destructorpublishedpropertyData:TAccidentEventreadFDatawriteSetData;// declaration of a property in a classpropertyOnAccident:TAccidentEventreadFOnAccidentwriteFOnAccident;// exposing the event outside the classpropertyOnChange:TNotifyEventreadFOnChangewriteFOnChange;// exposing the event outside the classprocedureMultiplyBy(constAValue:Integer);// a method that uses its own definition of the eventend;implementationconstructorTMyCustomObject.Create;beginFData:=0;end;destructorTMyCustomObject.Destroy;beginFData:=0;inheritedDestroy;end;procedureTMyCustomObject.DoAccident(constAValue:Integer);beginifAssigned(FOnAccident)thenFOnAccident(Self,AValue);end;procedureTMyCustomObject.DoChange;beginifAssigned(FOnChange)thenFOnChange(Self);end;procedureTMyCustomObject.MultiplyBy(constAValue:Integer);beginFData:=FData*AValue;ifFData>1000000thenDoAccident(FData);end;procedureTMyCustomObject.SetData(Value:Integer);beginifFData<>ValuethenbeginFData:=Value;DoChange;end;end.The created class can be used as follows:...procedureTMyForm.ShowCustomInfo(Sender:TObject);beginifSenderisTMyCustomObjectthenShowMessage('Data has changed.');end;procedureTMyForm.PerformAcident(Sender:TObject;constAValue:Integer);beginifSenderisTMyCustomObjectthenShowMessage('The data has exceeded 1000000! New value is: '+AValue.ToString);end;...{declaring a variable that is an object of the specified class}varLMyObject:TMyCustomObject;...{creation of the object}LMyObject:=TMyCustomObject.Create;...{assigning a methods to an events}LMyObject.OnChange:=MyForm.ShowCustomInfo;LMyObject.OnAccident:=MyForm.PerformAcident;...{removing an object when it is no longer needed}LMyObject.Free;...See also[edit]Event-driven programmingProcess Driven Messaging ServiceService-oriented architectureEvent-driven SOASpace-based architectureComplex event processingEvent stream processingEvent Processing Technical SocietyStaged event-driven architecture(SEDA)Reactor patternAutonomous peripheral operationArticles[edit]Article defining the differences between EDA and SOA:How EDA extends SOA and why it is importantby Jack van Hoof.Real-world example of business events flowing in an SOA:SOA, EDA, and CEP - a winning comboby Udi Dahan.Article describing the concept of event data:Analytics for hackers, how to think about event databy Michelle Wetzler. (Web archive)References[edit]^K. Mani Chandy Event-driven Applications: Costs, Benefits and Design Approaches,California Institute of Technology, 2006^Martin Fowler,Event Sourcing, December, 2005^Martin Fowler,Parallel Model, December, 2005^Hanson, Jeff (January 31, 2005)."Event-driven services in SOA".JavaWorld. Retrieved2020-07-21.^Sliwa, Carol (May 12, 2003)."Event-driven architecture poised for wide adoption".Computerworld. Retrieved2020-07-21.^Richards, Mark.Fundamentals of Software Architecture: An Engineering Approach. O'Reilly Media.ISBN978-1492043454.^abcdefghijBrenda M. Michelson, Event-Driven Architecture Overview,Patricia Seybold Group, February 2, 2006^"Online Event Processing - ACM Queue".queue.acm.org. Retrieved2019-05-30.^Hasan, Souleiman, Sean O’Riain, and Edward Curry. 2012.“Approximate Semantic Matching of Heterogeneous Events.”In 6th ACM International Conference on Distributed Event-Based Systems (DEBS 2012), 252–263. Berlin, Germany: ACM.“DOI”.External links[edit]Event-Driven Applications: Costs, Benefits and Design ApproachesArchived2013-10-23 at theWayback Machine5th Anniversary Edition: Event-Driven Architecture Overview, Brenda M. MichelsonComplex Event Processing and Service Oriented ArchitectureRetrieved from "https://en.wikipedia.org/w/index.php?title=Event-driven_architecture&oldid=1243058645"Categories:Enterprise application integrationSoftware architectureService-oriented (business computing)Events (computing)Hidden categories:Articles with short descriptionShort description is different from WikidataAll articles with unsourced statementsArticles with unsourced statements from August 2018All Wikipedia articles needing clarificationWikipedia articles needing clarification from September 2013Articles with unsourced statements from January 2017Webarchive template wayback linksArticles with example Java codeThis page was last edited on 30 August 2024, at 07:41(UTC).Text is available under theCreative Commons Attribution-ShareAlike License 4.0;
additional terms may apply. By using this site, you agree to theTerms of UseandPrivacy Policy. Wikipedia® is a registered trademark of theWikimedia Foundation, Inc., a non-profit organization.Privacy policyAbout WikipediaDisclaimersContact WikipediaCode of ConductDevelopersStatisticsCookie statementMobile view