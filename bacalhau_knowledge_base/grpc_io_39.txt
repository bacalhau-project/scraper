URL: https://grpc.io/docs/languages/dart/basics/

gRPCAboutMeetDocsGuidesShowcaseBlogCommunitygRPConf 2024 is happening NEXT WEEK onAug. 27th!-Register nowand get 25% off with the code GOOGLE25.DocsWhat is gRPC?IntroductionCore conceptsFAQLanguagesC# / .NETAPI (legacy)Daily builds (legacy)C++Quick startBasics tutorialAsync-API tutorialAsynchronous Callback API TutorialBest Practices for gRPC C++ API and FAQALTSAPIDartQuick startBasics tutorialAPIGoQuick startBasics tutorialALTSAPIGenerated codeJavaQuick startBasics tutorialALTSAPIGenerated codeKotlinQuick startBasics tutorialAPINodeQuick startBasics tutorialAPIObjective-CQuick startBasics tutorialOAuth2APIPHPQuick startBasics tutorialAPIDaily buildsPythonQuick startBasics tutorialALTSGenerated codeAPIDaily buildsRubyQuick startBasics tutorialAPIDaily buildsPlatformsAndroidJavaQuick startBasics tutorialAPIKotlinQuick startAPIWebQuick startBasics tutorialGuidesAuthenticationBenchmarkingCancellationCompressionCustom Backend MetricsCustom Load Balancing PoliciesCustom Name ResolutionDeadlinesDebuggingError handlingFlow ControlHealth CheckingInterceptorsKeepaliveMetadataOpenTelemetry MetricsPerformance Best PracticesReflectionRequest HedgingRetryService ConfigStatus CodesWait-for-ReadyView page sourceEdit this pageCreate child pageCreate documentation issueCreate project issueWhy use gRPC?Example code and setupDefining the serviceGenerating client and server codeCreating the serverImplementing RouteGuideSimple RPCServer-side streaming RPCClient-side streaming RPCBidirectional streaming RPCStarting the serverCreating the clientCreating a stubCalling service methodsSimple RPCServer-side streaming RPCClient-side streaming RPCBidirectional streaming RPCTry it out!Reporting issuesDocsLanguagesDartBasics tutorialBasics tutorialA basic tutorial introduction to gRPC in Dart.ContentsWhy use gRPC?Example code and setupDefining the serviceGenerating client and server codeCreating the serverImplementing RouteGuideSimple RPCServer-side streaming RPCClient-side streaming RPCBidirectional streaming RPCStarting the serverCreating the clientCreating a stubCalling service methodsSimple RPCServer-side streaming RPCClient-side streaming RPCBidirectional streaming RPCTry it out!Reporting issuesBasics tutorialA basic tutorial introduction to gRPC in Dart.This tutorial provides a basic Dart programmer’s introduction to working with
gRPC.By walking through this example you’ll learn how to:Define a service in a.protofile.Generate server and client code using the protocol buffer compiler.Use the Dart gRPC API to write a simple client and server for your service.It assumes that you have read theIntroduction to gRPCand are familiar
withprotocol buffers. Note that the
example in this tutorial uses the proto3 version of the protocol buffers
language: you can find out more in theproto3 language
guide.Why use gRPC?Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.With gRPC we can define our service once in a.protofile and generate clients
and servers in any of gRPC’s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.Example code and setupThe example code for our tutorial is ingrpc/grpc-dart/example/route_guide.
To download the example, clone thegrpc-dartrepository by running the following
command:$ git clone --depth1https://github.com/grpc/grpc-dartThen change your current directory togrpc-dart/example/route_guide:$cdgrpc-dart/example/route_guideYou should have already installed the tools needed to generate client and server
interface code – if you haven’t, seeQuick startfor setup instructions.Defining the serviceOur first step (as you’ll know from theIntroduction to gRPC) is to
define the gRPCserviceand the methodrequestandresponsetypes usingprotocol buffers. You can see the
complete.protofile inexample/route_guide/protos/route_guide.proto.To define a service, you specify a namedservicein your.protofile:serviceRouteGuide {...}Then you definerpcmethods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in theRouteGuideservice:Asimple RPCwhere the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.// Obtains the feature at a given position.rpcGetFeature(Point)returns(Feature) {}Aserver-side streaming RPCwhere the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing thestreamkeyword before theresponsetype.// Obtains the Features available within the given Rectangle.  Results are// streamed rather than returned at once (e.g. in a response message with a// repeated field), as the rectangle may cover a large area and contain a// huge number of features.rpcListFeatures(Rectangle)returns(stream Feature) {}Aclient-side streaming RPCwhere the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
thestreamkeyword before therequesttype.// Accepts a stream of Points on a route being traversed, returning a// RouteSummary when traversal is completed.rpcRecordRoute(stream Point)returns(RouteSummary) {}Abidirectional streaming RPCwhere both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing thestreamkeyword before both the request and the response.// Accepts a stream of RouteNotes sent while a route is being traversed,// while receiving other RouteNotes (e.g. from other users).rpcRouteChat(stream RouteNote)returns(stream RouteNote) {}Our.protofile also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here’s
thePointmessage type:// Points are represented as latitude-longitude pairs in the E7 representation// (degrees multiplied by 10**7 and rounded to the nearest integer).// Latitudes should be in the range +/- 90 degrees and longitude should be in// the range +/- 180 degrees (inclusive).messagePoint{int32latitude=1;int32longitude=2;}Generating client and server codeNext we need to generate the gRPC client and server interfaces from our.protoservice definition. We do this using the protocol buffer compilerprotocwith
a special Dart plugin. This is similar to what we did in theQuick start.From theroute_guideexample directory run:protoc -I protos/ protos/route_guide.proto --dart_out=grpc:lib/src/generatedRunning this command generates the following files in thelib/src/generateddirectory under theroute_guideexample directory:route_guide.pb.dartroute_guide.pbenum.dartroute_guide.pbgrpc.dartroute_guide.pbjson.dartThis contains:All the protocol buffer code to populate, serialize, and retrieve our request
and response message typesAn interface type (orstub) for clients to call with the methods defined in
theRouteGuideservice.An interface type for servers to implement, also with the methods defined in
theRouteGuideservice.Creating the serverFirst let’s look at how we create aRouteGuideserver. If you’re only
interested in creating gRPC clients, you can skip this section and go straight
toCreating the client(though you might find it interesting
anyway!).There are two parts to making ourRouteGuideservice do its job:Implementing the service interface generated from our service definition:
doing the actual “work” of our service.Running a gRPC server to listen for requests from clients and dispatch them to
the right service implementation.You can find our exampleRouteGuideserver ingrpc-dart/example/route_guide/lib/src/server.dart.
Let’s take a closer look at how it works.Implementing RouteGuideAs you can see, our server has aRouteGuideServiceclass that extends the
generated abstractRouteGuideServiceBaseclass:classRouteGuideServiceextendsRouteGuideServiceBase {Future<Feature>getFeature(grpc.ServiceCall call, Point request)async{...}Stream<Feature>listFeatures(grpc.ServiceCall call, Rectangle request)async*{...}Future<RouteSummary>recordRoute(grpc.ServiceCall call, Stream<Point>request)async{...}Stream<RouteNote>routeChat(grpc.ServiceCall call, Stream<RouteNote>request)async*{...}...}Simple RPCRouteGuideServiceimplements all our service methods. Let’s look at the
simplest type first,GetFeature, which just gets aPointfrom the client and
returns the corresponding feature information from its database in aFeature./// GetFeature handler. Returns a feature for the given location./// The [context] object provides access to client metadata, cancellation, etc.@overrideFuture<Feature>getFeature(grpc.ServiceCall call, Point request)async{returnfeaturesDb.firstWhere((f)=>f.location==request,orElse:()=>Feature()..location=request);}The method is passed a context object for the RPC and the client’sPointprotocol buffer request. It returns aFeatureprotocol buffer object with the
response information. In the method we populate theFeaturewith the appropriate
information, and thenreturnit to the gRPC framework, which sends it back to
the client.Server-side streaming RPCNow let’s look at one of our streaming RPCs.ListFeaturesis a server-side
streaming RPC, so we need to send back multipleFeatures to our client./// ListFeatures handler. Returns a stream of features within the given/// rectangle.@overrideStream<Feature>listFeatures(grpc.ServiceCall call, Rectangle request)async*{finalnormalizedRectangle=_normalize(request);// For each feature, check if it is in the given bounding boxfor(varfeatureinfeaturesDb) {if(feature.name.isEmpty)continue;finallocation=feature.location;if(_contains(normalizedRectangle, location)) {yieldfeature;}}}As you can see, instead of getting and returning simple request and response
objects in our method, this time we get a request object (theRectanglein
which our client wants to findFeatures) and return aStreamofFeatureobjects.In the method, we populate as manyFeatureobjects as we need to return,
adding them to the returned stream usingyield. The stream is automatically
closed when the method returns, telling gRPC that we have finished writing
responses.Should any error happen in this call, the error will be added as an exception
to the stream, and the gRPC layer will translate it into an appropriate RPC
status to be sent on the wire.Client-side streaming RPCNow let’s look at something a little more complicated: the client-side
streaming methodRecordRoute, where we get a stream ofPoints from the
client and return a singleRouteSummarywith information about their trip. As
you can see, this time the request parameter is a stream, which the server can
use to both read request messages from the client. The server returns its single
response just like in the simple RPC case./// RecordRoute handler. Gets a stream of points, and responds with statistics/// about the "trip": number of points, number of known features visited,/// total distance traveled, and total time spent.@overrideFuture<RouteSummary>recordRoute(grpc.ServiceCall call, Stream<Point>request)async{intpointCount=0;intfeatureCount=0;doubledistance=0.0;Point previous;finaltimer=Stopwatch();awaitfor(varlocationinrequest) {if(!timer.isRunning) timer.start();pointCount++;finalfeature=featuresDb.firstWhereOrNull((f)=>f.location==location);if(feature!=null) {featureCount++;}// For each point after the first, add the incremental distance from the// previous point to the total distance value.if(previous!=null) distance+=_distance(previous, location);previous=location;}timer.stop();returnRouteSummary()..pointCount=pointCount..featureCount=featureCount..distance=distance.round()..elapsedTime=timer.elapsed.inSeconds;}In the method body we useawait forin the request stream to repeatedly read
in our client’s requests (in this casePointobjects) until there are no more
messages. Once the request stream is done, the server can return itsRouteSummary.Bidirectional streaming RPCFinally, let’s look at our bidirectional streaming RPCRouteChat()./// RouteChat handler. Receives a stream of message/location pairs, and/// responds with a stream of all previous messages at each of those/// locations.@overrideStream<RouteNote>routeChat(grpc.ServiceCall call, Stream<RouteNote>request)async*{awaitfor(varnoteinrequest) {finalnotes=routeNotes.putIfAbsent(note.location, ()=><RouteNote>[]);for(varnoteinnotes)yieldnote;notes.add(note);}}This time we get a stream ofRouteNotethat, as in our client-side streaming
example, can be used to read messages. However, this time we return values via
our method’s returned stream while the client is still writing messages totheirmessage stream.The syntax for reading and writing here is the same as our client-streaming and
server-streaming methods. Although each side will always get the other’s messages
in the order they were written, both the client and server can read and write in
any order — the streams operate completely independently.Starting the serverOnce we’ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for ourRouteGuideservice:Future<void>main(List<String>args)async{finalserver=grpc.Server.create([RouteGuideService()]);awaitserver.serve(port:8080);print('Server listening...');}To build and start a server, we:Create an instance of the gRPC server usinggrpc.Server.create(),
giving a list of service implementations.Callserve()on the server to start listening for requests, optionally passing
in the address and port to listen on. The server will continue to serve requests
asynchronously untilshutdown()is called on it.Creating the clientIn this section, we’ll look at creating a Dart client for ourRouteGuideservice. The complete client code is available fromgrpc-dart/example/route_guide/lib/src/client.dart.Creating a stubTo call service methods, we first need to create a gRPCchannelto communicate
with the server. We create this by passing the server address and port number toClientChannel()as follows:finalchannel=ClientChannel('127.0.0.1',port:8080,options:constChannelOptions(credentials:ChannelCredentials.insecure()));You can useChannelOptionsto set TLS options (for example, trusted
certificates) for the channel, if necessary.Once the gRPCchannelis setup, we need a clientstubto perform RPCs. We
get it by instantiatingRouteGuideClient, which is provided by the package
generated from the example.protofile.stub=RouteGuideClient(channel,options:CallOptions(timeout:Duration(seconds:30)));You can useCallOptionsto set auth credentials (for example, GCE credentials
or JWT credentials) when a service requires them. TheRouteGuideservice
doesn’t require any credentials.Calling service methodsNow let’s look at how we call our service methods. Note that in gRPC-Dart, RPCs
are always asynchronous, which means that the RPC returns aFutureorStreamthat must be listened to, to get the response from the server or an error.Simple RPCCalling the simple RPCGetFeatureis nearly as straightforward as calling a
local method.finalpoint=Point()..latitude=409146138..longitude=-746188906;finalfeature=awaitstub.getFeature(point));As you can see, we call the method on the stub we got earlier. In our method
parameters we pass a request protocol buffer object (in our casePoint).
We can also pass an optionalCallOptionsobject which lets us change our RPC’s
behavior if necessary, such as time-out. If the call doesn’t return an error,
the returnedFuturecompletes with the response information from the server.
If there is an error, theFuturewill complete with the error.Server-side streaming RPCHere’s where we call the server-side streaming methodListFeatures, which
returns a stream of geographicalFeatures. If you’ve already readCreating
the serversome of this may look very familiar - streaming RPCs are
implemented in a similar way on both sides.finalrect=Rectangle()...;// initialize a Rectangletry{awaitfor(varfeatureinstub.listFeatures(rect)) {print(feature);}catch(e) {print('ERROR:$e');}As in the simple RPC, we pass the method a request. However, instead of getting
aFutureback, we get aStream. The client can use the stream to read the
server’s responses.We useawait foron the returned stream to repeatedly read in the server’s
responses to a response protocol buffer object (in this case aFeature) until
there are no more messages.Client-side streaming RPCThe client-side streaming methodRecordRouteis similar to the server-side
method, except that we pass the method aStreamand get aFutureback.finalrandom=Random();// Generate a number of random pointsStream<Point>generateRoute(intcount)async*{for(inti=0; i<count; i++) {finalpoint=featuresDb[random.nextInt(featuresDb.length)].location;yieldpoint;}}finalpointCount=random.nextInt(100)+2;// Traverse at least two pointsfinalsummary=awaitstub.recordRoute(generateRoute(pointCount));print('Route summary:$summary');Since thegenerateRoute()method isasync*, the points will be generated when
gRPC listens to the request stream and sends the point messages to the server. Once
the stream is done (whengenerateRoute()returns), gRPC knows that we’ve finished
writing and are expecting to receive a response. The returnedFuturewill either
complete with theRouteSummarymessage received from the server, or an error.Bidirectional streaming RPCFinally, let’s look at our bidirectional streaming RPCRouteChat(). As in the
case ofRecordRoute, we pass the method a stream where we will write the request
messages, and like inListFeatures, we get back a stream that we can use to read
the response messages. However, this time we will send values via our method’s stream
while the server is also writing messages totheirmessage stream.Stream<RouteNote>outgoingNotes=...;finalresponses=stub.routeChat(outgoingNotes);awaitfor(varnoteinresponses) {print('Got message${note.message}at${note.location.latitude},${note.location.longitude}');}The syntax for reading and writing here is very similar to our client-side and
server-side streaming methods. Although each side will always get the other’s
messages in the order they were written, both the client and server can read and
write in any order — the streams operate completely independently.Try it out!Work from the example directory:$cdexample/route_guideGet packages:$ dart pub getRun the server:$ dart bin/server.dartFrom a different terminal, run the client:$ dart bin/client.dartReporting issuesIf you find a problem with Dart gRPC, pleasefile an issuein our issue tracker.Last modified April 2, 2024:Update basics.md (#1276) (0c569cb)View page sourceEdit this pageCreate child pageCreate documentation issueCreate project issue© 2024 gRPC AuthorsTerms|Privacy|Trademarks|License|About