URL: https://grpc.io/docs/languages/cpp/callback/

gRPCAboutMeetDocsGuidesShowcaseBlogCommunitygRPConf 2024 is happening NEXT WEEK onAug. 27th!-Register nowand get 25% off with the code GOOGLE25.DocsWhat is gRPC?IntroductionCore conceptsFAQLanguagesC# / .NETAPI (legacy)Daily builds (legacy)C++Quick startBasics tutorialAsync-API tutorialAsynchronous Callback API TutorialBest Practices for gRPC C++ API and FAQALTSAPIDartQuick startBasics tutorialAPIGoQuick startBasics tutorialALTSAPIGenerated codeJavaQuick startBasics tutorialALTSAPIGenerated codeKotlinQuick startBasics tutorialAPINodeQuick startBasics tutorialAPIObjective-CQuick startBasics tutorialOAuth2APIPHPQuick startBasics tutorialAPIDaily buildsPythonQuick startBasics tutorialALTSGenerated codeAPIDaily buildsRubyQuick startBasics tutorialAPIDaily buildsPlatformsAndroidJavaQuick startBasics tutorialAPIKotlinQuick startAPIWebQuick startBasics tutorialGuidesAuthenticationBenchmarkingCancellationCompressionCustom Backend MetricsCustom Load Balancing PoliciesCustom Name ResolutionDeadlinesDebuggingError handlingFlow ControlHealth CheckingInterceptorsKeepaliveMetadataOpenTelemetry MetricsPerformance Best PracticesReflectionRequest HedgingRetryService ConfigStatus CodesWait-for-ReadyView page sourceEdit this pageCreate child pageCreate documentation issueCreate project issueOverviewExample CodeService to ImplementUnary RPCServerCustom Unary ReactorClientServer-side streaming RPCServerClientClient-side streaming RPCServerClientBidirectional streaming RPCServerClientDocsLanguagesC++Asynchronous Callback API TutorialAsynchronous Callback API TutorialContentsOverviewExample CodeService to ImplementUnary RPCServerCustom Unary ReactorClientServer-side streaming RPCServerClientClient-side streaming RPCServerClientBidirectional streaming RPCServerClientAsynchronous Callback API TutorialThis tutorial shows you how to write a simple server and client in C++ using
gRPC’s asynchronous callback APIs. The example used in this tutorial follows theRouteGuide example.OverviewgRPC C++ offers two kinds of APIs: sync APIs and async APIs. More specifically,
we have two kinds of async APIs: the old one is completion-queue based; the new
one is callback-based, which is easier to use. In this tutorial, we will focus
on the callback-based async APIs (callback APIs for short). You will learn how
to use the callback APIs to implement the server and the client for the
following kinds of RPCs:Unary RPCServer-side streaming RPCClient-side streaming RPCBidirectional streaming RPCExample CodeIn this tutorial, we are going to create a route guiding application. The
clients can get information about features on their route, create a summary of
their route, and exchange route information such as traffic updates with the
server and other clients.Below is the service interface defined in Protocol Buffers.// Interface exported by the server.serviceRouteGuide {// A simple RPC.//// Obtains the feature at a given position.//// A feature with an empty name is returned if there's no feature at the given// position.rpcGetFeature(Point)returns(Feature) {}// A server-to-client streaming RPC.//// Obtains the Features available within the given Rectangle.  Results are// streamed rather than returned at once (e.g. in a response message with a// repeated field), as the rectangle may cover a large area and contain a// huge number of features.rpcListFeatures(Rectangle)returns(stream Feature) {}// A client-to-server streaming RPC.//// Accepts a stream of Points on a route being traversed, returning a// RouteSummary when traversal is completed.rpcRecordRoute(stream Point)returns(RouteSummary) {}// A Bidirectional streaming RPC.//// Accepts a stream of RouteNotes sent while a route is being traversed,// while receiving other RouteNotes (e.g. from other users).rpcRouteChat(stream RouteNote)returns(stream RouteNote) {}}The same example is also implemented using thesyncAPIs. If you are
interested, you can compare the two implementations.Service to ImplementSince we want to implement the service using the callback APIs, the service
interface we should implement isRouteGuide::CallbackService.classRouteGuideImplfinal:publicRouteGuide::CallbackService {...};We will implement all the four RPCs in this service in theServersubsections
of the following sections.Unary RPCLet’s begin with the simplest RPC:GetFeature, which is a unary RPC. ByGetFeature, the client sends aPointto the server, and then the server
returns theFeatureof thatPointto the client.ServerThe implementation of this RPC is quite simple and straightforward.grpc::ServerUnaryReactor*GetFeature(CallbackServerContext*context,constPoint*point,Feature*feature)override{feature->set_name(GetFeatureName(*point, feature_list_));feature->mutable_location()->CopyFrom(*point);auto*reactor=context->DefaultReactor();reactor->Finish(Status::OK);returnreactor;}After setting the output fields ofFeature, we return the final status via theServerUnaryReactor.Custom Unary ReactorThe above example uses the Default Reactor. We could also use a custom reactor
here if we want to handle specific actions such as RPC cancellation or run an
action asynchronously when the RPC is done. In the below example we add logs for
both actions.grpc::ServerUnaryReactor*GetFeature(grpc::CallbackServerContext*context,constPoint*point,Feature*feature)override{classReactor:publicgrpc::ServerUnaryReactor {public:Reactor(constPoint&point,conststd::vector<Feature>&feature_list,Feature*feature) {feature->set_name(GetFeatureName(point, feature_list));*feature->mutable_location()=point;Finish(grpc::Status::OK);}private:voidOnDone()override{LOG(INFO)<<"RPC Completed";deletethis;}voidOnCancel()override{ LOG(ERROR)<<"RPC Cancelled"; }};returnnewReactor(*point, feature_list_, feature);}ForServerUnaryReactor, we need to overrideOnDone(), and optionallyOnCancel().NOTEThe callback methods (e.g.,OnDone()) are supposed to return
quickly. Never perform blocking work (e.g., waiting for an event) in such
callbacks.TheServerUnaryReactor’s constructor is called whenGetFeature()constructs
and provides the reactor in response to the started RPC. It collects the requestPoint, the responseFeatureand thefeature_list. It then gets the
responseFeaturefrom thePointand adds it to the feature_list as well. To
finish the RPC we callFinish(Status::OK).OnDone()reacts to the RPC completion. We will do the final cleanup inOnDone()and log the end of the RPC.OnCancel()reacts to the cancellation of the RPC. Here, we log the occurrence
of a cancellation in this method.ClientNOTE: For simplicity, we will not discuss how to create a channel and a stub in
this tutorial. Please refer toBasics tutorialfor that.To start aGetFeatureRPC, besides aClientContext, a request (i.e.,Point), and a response (i.e.,Feature), the client also needs to pass a
callback (i.e.,std::function<void(::grpc::Status)>) tostub_->async()->GetFeature(). The callback will be invoked after the server
has fulfilled the request and the RPC is finished.boolGetOneFeature(constPoint&point, Feature*feature) {ClientContext context;boolresult;std::mutex mu;std::condition_variable cv;booldone=false;stub_->async()->GetFeature(&context,&point, feature,[&result,&mu,&cv,&done, feature,this](Status status) {boolret;if(!status.ok()) {std::cout<<"GetFeature rpc failed."<<std::endl;ret=false;}elseif(!feature->has_location()) {std::cout<<"Server returns incomplete feature."<<std::endl;ret=false;}elseif(feature->name().empty()) {std::cout<<"Found no feature at "<<feature->location().latitude()/kCoordFactor_<<", "<<feature->location().longitude()/kCoordFactor_<<std::endl;ret=true;}else{std::cout<<"Found feature called "<<feature->name()<<" at "<<feature->location().latitude()/kCoordFactor_<<", "<<feature->location().longitude()/kCoordFactor_<<std::endl;ret=true;}std::lock_guard<std::mutex>lock(mu);result=ret;done=true;cv.notify_one();});std::unique_lock<std::mutex>lock(mu);cv.wait(lock, [&done] {returndone; });returnresult;}A callback can do various follow-up work for a unary RPC. For example, the
callback in the above snippet checks the status and the returned feature, frees
the heap-allocated objects for this call, and finally notifies that the RPC is
done.For simplicity, the example shows the same function waiting on the notification
for the RPC completion, but that’s not necessary.Server-side streaming RPCNow let’s look at a more complex RPC -ListFeatures.ListFeaturesis a
server-side streaming RPC. The client sends aRectangleto the server, and the
server will return a sequence ofFeatures to the client, each of which is sent
in a separate message.ServerFor any streaming RPC, including the server-side streaming RPC, the RPC
handler’s interface is similar. The handler does not have any input parameters;
the return type is some kind of server reactor, which handles all the business
logic for one RPC.Below is the handler interface ofListFeatures.grpc::ServerWriteReactor<Feature>*ListFeatures(CallbackServerContext*context,constrouteguide::Rectangle*rectangle);BecauseListFeaturesis a server-streaming RPC, the return type should beServerWriteReactor.ServerWriteReactorhas two template parameters:Rectangleis the type of the request from the client;Featureis the type of
each response message from the server.The complexity of handling an RPC is delegated to theServerWriteReactor.
Below is how we implement theServerWriteReactorto handle aListFeaturesRPC.grpc::ServerWriteReactor<Feature>*ListFeatures(CallbackServerContext*context,constrouteguide::Rectangle*rectangle)override{classLister:publicgrpc::ServerWriteReactor<Feature>{public:Lister(constrouteguide::Rectangle*rectangle,conststd::vector<Feature>*feature_list):left_((std::min)(rectangle->lo().longitude(),rectangle->hi().longitude())),right_((std::max)(rectangle->lo().longitude(),rectangle->hi().longitude())),top_((std::max)(rectangle->lo().latitude(),rectangle->hi().latitude())),bottom_((std::min)(rectangle->lo().latitude(),rectangle->hi().latitude())),feature_list_(feature_list),next_feature_(feature_list_->begin()) {NextWrite();}voidOnWriteDone(boolok)override{if(!ok) {Finish(Status(grpc::StatusCode::UNKNOWN,"Unexpected Failure"));}NextWrite();}voidOnDone()override{LOG(INFO)<<"RPC Completed";deletethis;}voidOnCancel()override{ LOG(ERROR)<<"RPC Cancelled"; }private:voidNextWrite() {while(next_feature_!=feature_list_->end()) {constFeature&f=*next_feature_;next_feature_++;if(f.location().longitude()>=left_&&f.location().longitude()<=right_&&f.location().latitude()>=bottom_&&f.location().latitude()<=top_) {StartWrite(&f);return;}}// Didn't write anything, all is done.Finish(Status::OK);}constlongleft_;constlongright_;constlongtop_;constlongbottom_;conststd::vector<Feature>*feature_list_;std::vector<Feature>::const_iterator next_feature_;};returnnewLister(rectangle,&feature_list_);}Different reactors have different callback methods. We need to override the
methods we are interested in to implement our RPC. ForListFeatures, we need
to overrideOnWriteDone(),OnDone()and optionallyOnCancel.TheServerWriteReactor’s constructor is called whenListFeatures()constructs and provides the reactor in response to the started RPC. It collects
all theFeatures withinrectangleintofeatures_to_send_, and starts
sending them, if any.OnWriteDone()reacts to a write completion. If the write was done
successfully, we continue to send the nextFeatureuntilfeatures_to_send_is empty, at which point we will callFinish(Status::OK)to finish the call.OnDone()reacts to the RPC completion. We will do the final cleanup inOnDone().OnCancel()reacts to the cancellation of the RPC. We log the occurrence of a
cancellation in this method.ClientSimilar to the server side, the client side needs to implement some kind of
client reactor to interact with the server. A client reactor encapsulates all
the operations needed to process an RPC.SinceListFeaturesis server-streaming, we should implement aClientReadReactor, which has a name that is symmetric toServerWriteReactor.classReader:publicgrpc::ClientReadReactor<Feature>{public:Reader(RouteGuide::Stub*stub,floatcoord_factor,constrouteguide::Rectangle&rect):coord_factor_(coord_factor) {stub->async()->ListFeatures(&context_,&rect,this);StartRead(&feature_);StartCall();}voidOnReadDone(boolok)override{if(ok) {std::cout<<"Found feature called "<<feature_.name()<<" at "<<feature_.location().latitude()/coord_factor_<<", "<<feature_.location().longitude()/coord_factor_<<std::endl;StartRead(&feature_);}}voidOnDone(constStatus&s)override{std::unique_lock<std::mutex>l(mu_);status_=s;done_=true;cv_.notify_one();}StatusAwait() {std::unique_lock<std::mutex>l(mu_);cv_.wait(l, [this] {returndone_; });returnstd::move(status_);}private:ClientContext context_;floatcoord_factor_;Feature feature_;std::mutex mu_;std::condition_variable cv_;Status status_;booldone_=false;};TheClientReadReactoris templatized with one parameter,Feature, which is
the type of response message from the server.In the constructor ofReader, we pass theClientContext,&rectangle_(the
request object), and theReaderto the RPC methodstub->async()->ListFeatures(). Then we pass the&feature_toStartRead()to specify where to store the received response. Finally, we callStartCall()to activate the RPC!OnReadDone()reacts to read completion. If the read was done successfully, we
continue to read the nextFeatureuntil we fail to do so, indicated byokbeingfalse.OnDone()reacts to the RPC completion. It checks the RPC status outcome and
notifies the conditional variable waiting forOnDone().Await()is not a method ofClientReadReactor. This is just added for
simplicity, so that the example knows that the RPC is done. Alternatively, if
there were no need for a notification on completion,OnDone()could simply
perform return after cleanup, for example, freeing up heap allocated objects.To initiate an RPC, the client simply instantiates aReadReactorand waits for
the RPC completion.routeguide::Rectangle rect;Feature feature;rect.mutable_lo()->set_latitude(400000000);rect.mutable_lo()->set_longitude(-750000000);rect.mutable_hi()->set_latitude(420000000);rect.mutable_hi()->set_longitude(-730000000);std::cout<<"Looking for features between 40, -75 and 42, -73"<<std::endl;Readerreader(stub_.get(), kCoordFactor_, rect);Status status=reader.Await();if(status.ok()) {std::cout<<"ListFeatures rpc succeeded."<<std::endl;}else{std::cout<<"ListFeatures rpc failed."<<std::endl;}Client-side streaming RPCOnce you understand the idea of server-side streaming RPC in the previous
section, you should find the client-side streaming RPC easy to learn.RecordRouteis the client-side streaming RPC we will discuss. The client sends
a sequence ofPoints to the server, and the server will return aRouteSummaryafter the client has finished sending thePoints.ServerThe RPC handler’s interface for a client-side streaming RPC does not have any
input parameters, and its return type is a server reactor, namely, aServerReadReactor.TheServerReadReactorhas two template parameters:Pointis the type of each
request message from the client;RouteSummaryis the type of the response from
the server.Similar toServerWriteReactor,ServerReadReactoris the class that handles
an RPC.grpc::ServerReadReactor<Point>*RecordRoute(CallbackServerContext*context,RouteSummary*summary)override{classRecorder:publicgrpc::ServerReadReactor<Point>{public:Recorder(RouteSummary*summary,conststd::vector<Feature>*feature_list):start_time_(system_clock::now()),summary_(summary),feature_list_(feature_list) {StartRead(&point_);}voidOnReadDone(boolok)override{if(ok) {point_count_++;if(!GetFeatureName(point_,*feature_list_).empty()) {feature_count_++;}if(point_count_!=1) {distance_+=GetDistance(previous_, point_);}previous_=point_;StartRead(&point_);}else{summary_->set_point_count(point_count_);summary_->set_feature_count(feature_count_);summary_->set_distance(static_cast<long>(distance_));autosecs=std::chrono::duration_cast<std::chrono::seconds>(system_clock::now()-start_time_);summary_->set_elapsed_time(secs.count());Finish(Status::OK);}}voidOnDone()override{LOG(INFO)<<"RPC Completed";deletethis;}voidOnCancel()override{ LOG(ERROR)<<"RPC Cancelled"; }private:system_clock::time_point start_time_;RouteSummary*summary_;conststd::vector<Feature>*feature_list_;Point point_;intpoint_count_=0;intfeature_count_=0;floatdistance_=0.0;Point previous_;};returnnewRecorder(summary,&feature_list_);}TheServerReadReactor’s constructor is called whenRecordRoute()constructs
and provides the reactor in response to the started RPC. The constructor stores
theRouteSummary*to return the response later, and initiates a read operation
by callingStartRead(&point_).OnReadDone()reacts to a read completion. If the read was done successfully,
we update the stats with the newly receivedPoint, and continue to read nextPointuntil we fail to do so, indicated byokbeingfalse. Upon read
failure, the server will set the response intosummary_and callFinish(Status::OK)to finish the RPC.OnDone()reacts to the RPC completion. We will do the final cleanup inOnDone().OnCancel()reacts to the cancellation of the RPC. We log the occurrence of a
cancellation in this method.ClientUnsurprisingly, we need to implement a client reactor for the client side, and
that client reactor is calledClientWriteReactor.classRecorder:publicgrpc::ClientWriteReactor<Point>{public:Recorder(RouteGuide::Stub*stub,floatcoord_factor,conststd::vector<Feature>*feature_list):coord_factor_(coord_factor),feature_list_(feature_list),generator_(std::chrono::system_clock::now().time_since_epoch().count()),feature_distribution_(0, feature_list->size()-1),delay_distribution_(500,1500) {stub->async()->RecordRoute(&context_,&stats_,this);// Use a hold since some StartWrites are invoked indirectly from a// delayed lambda in OnWriteDone rather than directly from the reaction// itselfAddHold();NextWrite();StartCall();}voidOnWriteDone(boolok)override{// Delay and then do the next write or WritesDonealarm_.Set(std::chrono::system_clock::now()+std::chrono::milliseconds(delay_distribution_(generator_)),[this](bool/*ok*/) { NextWrite(); });}voidOnDone(constStatus&s)override{std::unique_lock<std::mutex>l(mu_);status_=s;done_=true;cv_.notify_one();}StatusAwait(RouteSummary*stats) {std::unique_lock<std::mutex>l(mu_);cv_.wait(l, [this] {returndone_; });*stats=stats_;returnstd::move(status_);}private:voidNextWrite() {if(points_remaining_!=0) {constFeature&f=(*feature_list_)[feature_distribution_(generator_)];std::cout<<"Visiting point "<<f.location().latitude()/coord_factor_<<", "<<f.location().longitude()/coord_factor_<<std::endl;StartWrite(&f.location());points_remaining_--;}else{StartWritesDone();RemoveHold();}}ClientContext context_;floatcoord_factor_;intpoints_remaining_=10;Point point_;RouteSummary stats_;conststd::vector<Feature>*feature_list_;std::default_random_engine generator_;std::uniform_int_distribution<int>feature_distribution_;std::uniform_int_distribution<int>delay_distribution_;grpc::Alarm alarm_;std::mutex mu_;std::condition_variable cv_;Status status_;booldone_=false;};TheClientWriteReactoris templatized with one parameter,Point, which is
the type of request message from the client.In the constructor ofRecorder, we pass theClientContext,&stats_(the
response object), and theRecorderto the RPC method
sstub->async()->RecordRoute(). Then we add an operation to send the firstPointinpoints_to_send_, if any. Note that if there is nothing to send at
the startup of the RPC, we need to callStartWritesDone()to inform the server
that we are done with writes. Finally, callingStartCall()activates the RPC.OnWriteDone()reacts to write completion. If the write was done successfully,
we continue to write the nextPointuntilpoints_to_send_is empty. For the
lastPointto send, we callStartWriteLast()to piggyback the signal that
writes are done.StartWriteLast()is effectively the same with combinedStartWrite()andStartWritesDone(), but is more efficient.OnDone()reacts to the RPC completion. It checks the RPC status outcome and
the response instats_, and notifies the conditional variable waiting forOnDone().Await()is not a method ofClientWriteReactor. We addAwait()so that the
caller can wait until the RPC is done.To initiate an RPC, the client simply instantiates aRecorderand waits for
the RPC completion.Recorderrecorder(stub_.get(), kCoordFactor_,&feature_list_);RouteSummary stats;Status status=recorder.Await(&stats);if(status.ok()) {std::cout<<"Finished trip with "<<stats.point_count()<<" points\n"<<"Passed "<<stats.feature_count()<<" features\n"<<"Travelled "<<stats.distance()<<" meters\n"<<"It took "<<stats.elapsed_time()<<" seconds"<<std::endl;}else{std::cout<<"RecordRoute rpc failed."<<std::endl;}Bidirectional streaming RPCFinally, we will look at the bidirectional streaming RPCRouteChat. In this
case, the client sends a sequence ofRouteNotes to the server. Each time aRouteNoteat aPointis sent, the server will return a sequence ofRouteNotes at the samePointthat have been sent by all the clients before.ServerAgain, the RPC handler’s interface for a bidirectional streaming RPC does not
have any input parameters, and its return type is a server reactor, namely, aServerBidiReactor.TheServerBidiReactorhas two template parameters, both of which areRouteNote, becauseRouteNoteis the message type of both request and
response. After all,RouteChatmeans to let clients chat and share information
with each other!Since we have already discussedServerWriteReactorandServerReadReactor,ServerBidiReactorshould be quite straightforward.grpc::ServerBidiReactor<RouteNote, RouteNote>*RouteChat(CallbackServerContext*context)override{classChatter:publicgrpc::ServerBidiReactor<RouteNote, RouteNote>{public:Chatter(absl::Mutex*mu, std::vector<RouteNote>*received_notes):mu_(mu), received_notes_(received_notes) {StartRead(&note_);}voidOnReadDone(boolok)override{if(ok) {// Unlike the other example in this directory that's not using// the reactor pattern, we can't grab a local lock to secure the// access to the notes vector, because the reactor will most likely// make us jump threads, so we'll have to use a different locking// strategy. We'll grab the lock locally to build a copy of the// list of nodes we're going to send, then we'll grab the lock// again to append the received note to the existing vector.mu_->Lock();std::copy_if(received_notes_->begin(), received_notes_->end(),std::back_inserter(to_send_notes_),[this](constRouteNote&note) {returnnote.location().latitude()==note_.location().latitude()&&note.location().longitude()==note_.location().longitude();});mu_->Unlock();notes_iterator_=to_send_notes_.begin();NextWrite();}else{Finish(Status::OK);}}voidOnWriteDone(bool/*ok*/)override{ NextWrite(); }voidOnDone()override{LOG(INFO)<<"RPC Completed";deletethis;}voidOnCancel()override{ LOG(ERROR)<<"RPC Cancelled"; }private:voidNextWrite() {if(notes_iterator_!=to_send_notes_.end()) {StartWrite(&*notes_iterator_);notes_iterator_++;}else{mu_->Lock();received_notes_->push_back(note_);mu_->Unlock();StartRead(&note_);}}RouteNote note_;absl::Mutex*mu_;std::vector<RouteNote>*received_notes_ ABSL_GUARDED_BY(mu_);std::vector<RouteNote>to_send_notes_;std::vector<RouteNote>::iterator notes_iterator_;};returnnewChatter(&mu_,&received_notes_);}TheServerBidiReactor’s constructor is called whenRouteChat()constructs
and provides the reactor in response to the started RPC. The constructor
initiates a read operation by callingStartRead(&received_note_).OnReadDone()reacts to a read completion. If the read was done successfully
(i.e.,okistrue), we will continue to read nextRouteNote; otherwise, we
will record that reads are all finished, and finish the RPC. As for the newly
receivedRouteNoteupon a successful read, we add it toreceived_notes_, and
append the previously received notes at the samePointtoto_send_notes_.
Wheneverto_send_notes_becomes non-empty, we start to send theRouteNotes
into_send_notes_.OnWriteDone()reacts to a write completion. If the write was done
successfully, we continue to send nextRouteNoteuntilto_send_notes_is
empty, at which point we will continue reading nextRouteNoteor finish the
RPC if reads are also finished.OnDone()reacts to the RPC completion. We will do the final cleanup inOnDone().OnCancel()reacts to the cancellation of the RPC. We log the occurrence of a
cancellation in this method.ClientYes, the client reactor for a bidirectional streaming RPC isClientBidiReactor.classChatter:publicgrpc::ClientBidiReactor<RouteNote, RouteNote>{public:explicitChatter(RouteGuide::Stub*stub):notes_{MakeRouteNote("First message",0,0),MakeRouteNote("Second message",0,1),MakeRouteNote("Third message",1,0),MakeRouteNote("Fourth message",0,0)},notes_iterator_(notes_.begin()) {stub->async()->RouteChat(&context_,this);NextWrite();StartRead(&server_note_);StartCall();}voidOnWriteDone(boolok)override{if(ok) {NextWrite();}}voidOnReadDone(boolok)override{if(ok) {std::cout<<"Got message "<<server_note_.message()<<" at "<<server_note_.location().latitude()<<", "<<server_note_.location().longitude()<<std::endl;StartRead(&server_note_);}}voidOnDone(constStatus&s)override{std::unique_lock<std::mutex>l(mu_);status_=s;done_=true;cv_.notify_one();}StatusAwait() {std::unique_lock<std::mutex>l(mu_);cv_.wait(l, [this] {returndone_; });returnstd::move(status_);}private:voidNextWrite() {if(notes_iterator_!=notes_.end()) {constauto&note=*notes_iterator_;std::cout<<"Sending message "<<note.message()<<" at "<<note.location().latitude()<<", "<<note.location().longitude()<<std::endl;StartWrite(&note);notes_iterator_++;}else{StartWritesDone();}}ClientContext context_;conststd::vector<RouteNote>notes_;std::vector<RouteNote>::const_iterator notes_iterator_;RouteNote server_note_;std::mutex mu_;std::condition_variable cv_;Status status_;booldone_=false;};TheClientBidiReactoris templatized with two parameters, the message types of
the request and the response, which are bothRouteNotein the case of RPCRouteChat.In the constructor ofChatter, we pass theClientContextand theChatterto the RPC methodstub->async()->RouteChat(). Then we add an operation to send
the firstRouteNoteinnotes_, if any. Note that if there is nothing to send
at the startup of the RPC, we need to callStartWritesDone()to inform the
server that we are done with writes. We also callStartRead()to add a read
operation. Finally, callingStartCall()activates the RPC.OnReadDone()reacts to read completion. If the read was done successfully, we
continue to read nextRouteNoteuntil we fail to do so, indicated byokbeingfalse.OnWriteDone()reacts to write completion. If the write was done successfully,
we continue to write nextRouteNoteuntilnotes_is empty. For the lastRouteNoteto send, we callStartWriteLast()to piggyback the signal that
writes are done.StartWriteLast()is effectively the same with combinedStartWrite()andStartWritesDone(), but is more efficient.OnDone()reacts to the RPC completion. It checks the RPC status outcome and
the message stats, and notifies the conditional variable waiting forOnDone().Await()is not a method ofClientBidiReactor. We addAwait()so that the
caller can wait until the RPC is done.To initiate an RPC, the client simply instantiates aChatterand waits for the
RPC completion.Chatterchatter(stub_.get());Status status=chatter.Await();if(!status.ok()) {std::cout<<"RouteChat rpc failed."<<std::endl;}Last modified June 18, 2024:C++ Callback API Tutorial (#1305) (18b12d6)View page sourceEdit this pageCreate child pageCreate documentation issueCreate project issue© 2024 gRPC AuthorsTerms|Privacy|Trademarks|License|About