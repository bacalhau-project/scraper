URL: https://grpc.io/docs/languages/cpp/best_practices/

gRPCAboutMeetDocsGuidesShowcaseBlogCommunitygRPConf 2024 is happening NEXT WEEK onAug. 27th!-Register nowand get 25% off with the code GOOGLE25.DocsWhat is gRPC?IntroductionCore conceptsFAQLanguagesC# / .NETAPI (legacy)Daily builds (legacy)C++Quick startBasics tutorialAsync-API tutorialAsynchronous Callback API TutorialBest Practices for gRPC C++ API and FAQALTSAPIDartQuick startBasics tutorialAPIGoQuick startBasics tutorialALTSAPIGenerated codeJavaQuick startBasics tutorialALTSAPIGenerated codeKotlinQuick startBasics tutorialAPINodeQuick startBasics tutorialAPIObjective-CQuick startBasics tutorialOAuth2APIPHPQuick startBasics tutorialAPIDaily buildsPythonQuick startBasics tutorialALTSGenerated codeAPIDaily buildsRubyQuick startBasics tutorialAPIDaily buildsPlatformsAndroidJavaQuick startBasics tutorialAPIKotlinQuick startAPIWebQuick startBasics tutorialGuidesAuthenticationBenchmarkingCancellationCompressionCustom Backend MetricsCustom Load Balancing PoliciesCustom Name ResolutionDeadlinesDebuggingError handlingFlow ControlHealth CheckingInterceptorsKeepaliveMetadataOpenTelemetry MetricsPerformance Best PracticesReflectionRequest HedgingRetryService ConfigStatus CodesWait-for-ReadyView page sourceEdit this pageCreate child pageCreate documentation issueCreate project issueGeneralStreaming RPCsCallback API SpecificStreamingFAQGeneralCallback Streaming APIDocsLanguagesC++Best Practices for gRPC C++ API and FAQBest PracticesContentsGeneralStreaming RPCsCallback API SpecificStreamingFAQGeneralCallback Streaming APIBest PracticesGeneralPleaseuse the callback API.Look for header files with commentsinthird_party/grpc/include/grpcpp.Always set a deadline on RPCs.Here’s ablog postwith some explanation. It’s
harder to do so for long-lasting streaming RPCs, but applications can
implement custom logic to add deadlines for messages.Streaming RPCsRead all messages until failureif you need all sent messages. Read
until the reaction is called with boolok=falsefor callback API or the
tag hasok=falsefor the async API, or Read fails for the sync API. This
is more reliable than counting messages.There can only be one read and one write in flight at a timeThis is an
API requirement rather than a best practice, but worth mentioning again.If your application has a two-way stream of data, use bi-directional
streaming rather a client-server and server-client model.This will allow
for consistent load balancing and is better supported in gRPC.Callback API SpecificIn this section, “operations” here are defined asStartRead,StartWrite(and
variants), andSendInitialMetadata.Finishis also an operation, but often
not relevant to the discussion.“Reactions” are defined as the overridable callbacks within the reactor, such asOnReadDone,OnWriteDone,OnCancel, andOnInitialMetadataDone.OnDoneis also a reaction, but as the final reaction, the directions here may not be
relevant to it.Best practices:Reactions should be fast.Do not do blocking or long-running/heavy
weight tasks or sleep. It could impact other RPCs within the process.StreamingUse Holds for starting operations outside reactions.If you are starting
operations on the client from outside reactions, you may need to useholds.
This prevents OnDone() from running until holds are removed, preventing
races for final cleanup with outstanding operations if the stream has an
error. Thebool okvalue in the reactions will reflect if the stream has
ended, and operations started after this will all haveok=false.Synchronize reactions.Reactions can run in parallel. For example,OnReadDonemay run at the same time asOnWriteDone. Synchronize
accordingly.Read until falseRather than counting number of messages, etc. read
untilOnReadDone(ok=false).On the server side, note that this requires the client to call writes done,
which is recommended. The server side does not have to do anything special -Finishsignals the end of stream.A status sent by the application through theFinishcall may not be
visible to the client until all incoming messages have been consumed.FAQGeneralHow do I debug gRPC issues?Seetroubleshooting.Callback Streaming APIIs a client half-close required or expected?A client half-close is strongly recommended so that the server can continue
to read untilOnReadDone(ok=false), which is recommended on both the
server and client side. However, it is not required – a server could also
always choose to Finish() before consuming all client data.How do I cancel operations on the client side?ClientContext::TryCancel()Does the client need to read the data on the wire beforeOnDoneis called?The best practice is always to read untilok=falseon the client side.The client must read all incoming data before it can see an OK status from
serverFinish. However, an error status such as from cancellation or
deadline or stream abort may arrive anytime.There are no guarantees about whether an explicit serverFinishwith an
error status will be queued behind server writes or delivered immediately.
Therefore, the client should always consume all incoming messages by reading
untilok=falseto guarantee delivery of the status.Since messages are not guaranteed to be delivered if the server callsFinishwith an error status, the error status should not be used to
communicate success and further directions to a client; trailing metadata
should be used for this purpose instead.When isOnDonecalled on the client?It is called when there is a status available for the client (all incoming
data is read and the server has calledFinishOR the status is an error
that will be delivered immediately), all user reactions have finished
running, and all holds are removed.When isOnDonecalled on the server?All reactions must finish running (includingOnCancelwhen relevant) and
server must have calledFinish.What is “within-reactor flow” vs. “outside-reactor flow” and why does it
matter?Within-reactor flow is when operations are started from inside reactions (or
the reactor constructor) such asOnWriteDonestarting another write. These
make sense since there can only be one read and one write in flight and
starting them from the reaction can help maintain that.Outside-reactor flow is when operations on the stream are started from
outside reactions. This makes sense since reactions aren’t supposed to block
and the application may not be ready to perform its next read or write. Note
that outside-reactor flows require the use of holds to synchronize on the
client side. Server side uses Finish to synchronize outside-reactor calls;
the application should not start more operations after calling Finish.What are holds and how and when do I use them?They are used to synchronize when OnDone is called and are only needed with
outside-reactor flow is used. Note that holds are only on the client side.What if the server callsFinishbut the client keeps starting new
operations, such as withStartWrite?OnWriteDone(ok=false)will be called each time the write is started up
untilOnDoneis called.How do we know when a reactor can be deleted?The reactor can be deleted inOnDone. No methods on the reactor base class
may be invoked fromOnDone, and the reactor object will not be accessed by
gRPC afterOnDoneis called. It is the application’s responsibility to
ensure no operations are started when OnDone is running.Can reactions run at the same time, e.g. canOnReadInitialMetadataDonerun
at the same time asOnReadDone?Yes, most reactions may run in parallel. OnlyOnDoneruns by itself as the
final operation.IsOnReadInitialMetadataDonecalled every time, even if the metadata is
empty?Yes, this is used to communicate to the client that the metadata is empty.
As with all reactions, the user application need not override this reaction.IsOnSendInitialMetadataDonecalled on the server if the initial metadata
goes out with the first write rather than because of an explicitSendInitialMetadata?No, it has to be explicitly requested. Implicit calls don’t get callbacks.If a client callsWriteLast, do they get bothOnWriteDoneandOnWritesDoneDonecallbacks invoked? What happens if they callWrite(options.set_last_message = true)?If there’s a payload, onlyOnWriteDone()will be called.OnWritesDoneDonewill be called only in response toWritesDone().Can you callWritesDone()while you have a write outstanding (i.e.OnWriteDone()hasn’t been called yet)?Yes, the transport orders these.When doesOnReadInitialMetadataDoneget called withok=falsefor the
client?This would be called only if there is an error.Can a user callSendInitialMetadata,StartWritewithout waiting forOnSendInitialMetadataDonein the middle?This is similar toStartWriteandWritesDone. We do not need to enforce
ordering if the transport orders it, but the user may get callbacks invoked
in any order.When does serverOnCancelrun?Note that this is not specific to streaming. It is called for an out-of-band
cancellation, i.e. when there is an error on the stream (such as connection
abort), a cancellation requested on the client or server side, or a deadline
that expires. It can be used as a signal that the client is no longer
processing any data.It may run in parallel with other reactions. Operations called afterOnCancelor started withinOnCancelwill have their reactions called
withok=false.Note thatOnCancelno longer runs if the server callsFinishspecifying
an error status because that is not considered an out-of-band cancellation.Depending on ordering,OnCancelmay or may not run ifFinishis called.
However,OnDoneis always the final callback.Does server still need to callFinishifOnCancelis run?Yes, although the status passed toFinishis ignored.WillOnDonestill be called ifOnCancelis called?Yes,OnDoneis the final callback and will be called once the server has
also calledFinishand all other reactions have completed running.Can the user call additional operations (Start*) afterOnCancel?Yes, but they will all have reactions run withok=false. It is not valid
to call them after calling serverFinish.When doesIsCancelled()return true on thecontext?This is set when there is an error on the stream, a cancellation requested
on the client or server side, or a deadline that expires. Once b/138186533
is resolved, if this kind of error is the reason why reactions are called
withok=false, it will be setbeforethese reactions are called.Is there a per operation (e.g.StartRead) deadline, or only per RPC?It is only per RPC.If a user doesstub->MyBidiStreamRPC(); context->TryCancel(), does the
user still need to callStartCall?Yes, it is required oncestub->MyBidiStreamRPC()is called.Is it legal for the server to callFinishwhile there is a Read or Write
outstanding?This is fine for reads andOnReadDone(ok=false)is called. CallingFinishwith a write outstanding is not valid API usage, since a Finish can
be considered a final write with no data, which would violate the
one-write-in-flight rule.What happens when the server callsFinishwith a read outstanding?OnReadDone(ok=false)is called.Can you start another operation (e.g. read or write) in the client reactor’sOnDone?No, that is not a legal use of the API.Can you start operations on the server after callingFinish?This is not a good practice. However, if you start new operations within
reactions, their corresponding reactions will be called withok=false.
Starting them with outside-reaction flow is illegal and problematic since
the operations may race withOnDone.Last modified June 25, 2024:C++ Best Practices (#1309) (4709643)View page sourceEdit this pageCreate child pageCreate documentation issueCreate project issue© 2024 gRPC AuthorsTerms|Privacy|Trademarks|License|About