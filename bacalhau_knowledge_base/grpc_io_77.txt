URL: https://grpc.io/docs/languages/ruby/basics/

gRPCAboutMeetDocsGuidesShowcaseBlogCommunitygRPConf 2024 is happening NEXT WEEK onAug. 27th!-Register nowand get 25% off with the code GOOGLE25.DocsWhat is gRPC?IntroductionCore conceptsFAQLanguagesC# / .NETAPI (legacy)Daily builds (legacy)C++Quick startBasics tutorialAsync-API tutorialAsynchronous Callback API TutorialBest Practices for gRPC C++ API and FAQALTSAPIDartQuick startBasics tutorialAPIGoQuick startBasics tutorialALTSAPIGenerated codeJavaQuick startBasics tutorialALTSAPIGenerated codeKotlinQuick startBasics tutorialAPINodeQuick startBasics tutorialAPIObjective-CQuick startBasics tutorialOAuth2APIPHPQuick startBasics tutorialAPIDaily buildsPythonQuick startBasics tutorialALTSGenerated codeAPIDaily buildsRubyQuick startBasics tutorialAPIDaily buildsPlatformsAndroidJavaQuick startBasics tutorialAPIKotlinQuick startAPIWebQuick startBasics tutorialGuidesAuthenticationBenchmarkingCancellationCompressionCustom Backend MetricsCustom Load Balancing PoliciesCustom Name ResolutionDeadlinesDebuggingError handlingFlow ControlHealth CheckingInterceptorsKeepaliveMetadataOpenTelemetry MetricsPerformance Best PracticesReflectionRequest HedgingRetryService ConfigStatus CodesWait-for-ReadyView page sourceEdit this pageCreate child pageCreate documentation issueCreate project issueWhy use gRPC?Example code and setupDefining the serviceGenerating client and server codeCreating the serverImplementing RouteGuideStarting the serverCreating the clientCreating a stubCalling service methodsSimple RPCStreaming RPCsTry it out!DocsLanguagesRubyBasics tutorialBasics tutorialA basic tutorial introduction to gRPC in Ruby.ContentsWhy use gRPC?Example code and setupDefining the serviceGenerating client and server codeCreating the serverImplementing RouteGuideStarting the serverCreating the clientCreating a stubCalling service methodsSimple RPCStreaming RPCsTry it out!Basics tutorialA basic tutorial introduction to gRPC in Ruby.This tutorial provides a basic Ruby programmer’s introduction to working with gRPC.By walking through this example you’ll learn how to:Define a service in a .proto file.Generate server and client code using the protocol buffer compiler.Use the Ruby gRPC API to write a simple client and server for your service.It assumes that you have read theIntroduction to gRPCand are familiar
withprotocol
buffers. Note
that the example in this tutorial uses the proto3 version of the protocol
buffers language: you can find out more in
theproto3 language
guide.Why use gRPC?Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.With gRPC we can define our service once in a.protofile and generate clients
and servers in any of gRPC’s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.Example code and setupThe example code for our tutorial is ingrpc/grpc/examples/ruby/route_guide.
To download the example, clone thegrpcrepository by running the following
command:$ git clone -b v1.66.0 --depth1--shallow-submodules https://github.com/grpc/grpc$cdgrpcThen change your current directory toexamples/ruby/route_guide:$cdexamples/ruby/route_guideYou also should have the relevant tools installed to generate the server and
client interface code - if you don’t already, follow the setup instructions inQuick start.Defining the serviceOur first step (as you’ll know from theIntroduction to gRPC) is to
define the gRPCserviceand the methodrequestandresponsetypes usingprotocol
buffers. You can
see the complete .proto file inexamples/protos/route_guide.proto.To define a service, you specify a namedservicein your .proto file:serviceRouteGuide {...}Then you definerpcmethods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in theRouteGuideservice:Asimple RPCwhere the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.// Obtains the feature at a given position.rpcGetFeature(Point)returns(Feature) {}Aserver-side streaming RPCwhere the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing thestreamkeyword before theresponsetype.// Obtains the Features available within the given Rectangle.  Results are// streamed rather than returned at once (e.g. in a response message with a// repeated field), as the rectangle may cover a large area and contain a// huge number of features.rpcListFeatures(Rectangle)returns(stream Feature) {}Aclient-side streaming RPCwhere the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
thestreamkeyword before therequesttype.// Accepts a stream of Points on a route being traversed, returning a// RouteSummary when traversal is completed.rpcRecordRoute(stream Point)returns(RouteSummary) {}Abidirectional streaming RPCwhere both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing thestreamkeyword before both the request and the response.// Accepts a stream of RouteNotes sent while a route is being traversed,// while receiving other RouteNotes (e.g. from other users).rpcRouteChat(stream RouteNote)returns(stream RouteNote) {}Our.protofile also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here’s
thePointmessage type:// Points are represented as latitude-longitude pairs in the E7 representation// (degrees multiplied by 10**7 and rounded to the nearest integer).// Latitudes should be in the range +/- 90 degrees and longitude should be in// the range +/- 180 degrees (inclusive).messagePoint{int32latitude=1;int32longitude=2;}Generating client and server codeNext we need to generate the gRPC client and server interfaces from our .proto
service definition. We do this using the protocol buffer compilerprotocwith
a special gRPC Ruby plugin.If you want to run this yourself, make sure you have installedgRPCandprotoc.Once that’s done, the following command can be used to generate the ruby code.$ grpc_tools_ruby_protoc -I ../../protos --ruby_out=../lib --grpc_out=../lib ../../protos/route_guide.protoRunning this command regenerates the following files in the lib directory:lib/route_guide.pbdefines a moduleExamples::RouteGuideThis contain all the protocol buffer code to populate, serialize, and
retrieve our request and response message typeslib/route_guide_services.pb, extendsExamples::RouteGuidewith stub and
service classesa classServicefor use as a base class when defining RouteGuide service
implementationsa classStubthat can be used to access remote RouteGuide instancesCreating the serverFirst let’s look at how we create aRouteGuideserver. If you’re only
interested in creating gRPC clients, you can skip this section and go straight
toCreating the client(though you might find it interesting
anyway!).There are two parts to making ourRouteGuideservice do its job:Implementing the service interface generated from our service definition:
doing the actual “work” of our service.Running a gRPC server to listen for requests from clients and return the
service responses.You can find our exampleRouteGuideserver inexamples/ruby/route_guide/route_guide_server.rb.
Let’s take a closer look at how it works.Implementing RouteGuideAs you can see, our server has aServerImplclass that extends the generatedRouteGuide::Service:# ServerImpl provides an implementation of the RouteGuide service.classServerImpl<RouteGuide::ServiceServerImplimplements all our service methods. Let’s look at the simplest type
first,GetFeature, which just gets aPointfrom the client and returns the
corresponding feature information from its database in aFeature.defget_feature(point, _call)name=@feature_db[{'longitude'=>point.longitude,'latitude'=>point.latitude }]||''Feature.new(location: point,name:name)endThe method is passed a _call for the RPC, the client’sPointprotocol buffer
request, and returns aFeatureprotocol buffer. In the method we create theFeaturewith the appropriate information, and thenreturnit.Now let’s look at something a bit more complicated - a streaming RPC.ListFeaturesis a server-side streaming RPC, so we need to send back multipleFeatures to our client.# in ServerImpldeflist_features(rectangle, _call)RectangleEnum.new(@feature_db, rectangle).eachendAs you can see, here the request object is aRectanglein which our client
wants to findFeatures, but instead of returning a simple response we need to
return anEnumeratorthat
yields the responses. In the method, we use a helper classRectangleEnum, to
act as an Enumerator implementation.Similarly, the client-side streaming methodrecord_routeuses anEnumerable, but here it’s
obtained from the call object, which we’ve ignored in the earlier examples.call.each_remote_readyields each message sent by the client in turn.call.each_remote_readdo|point|...endFinally, let’s look at our bidirectional streaming RPCroute_chat.defroute_chat(notes)RouteChatEnumerator.new(notes, @received_notes).each_itemendHere the method receives anEnumerable, but also returns
anEnumeratorthat yields the
responses. Although each side will always get the other’s messages in the order they were written,
both the client and server can read and write in any order — the streams operate completely
independently.Starting the serverOnce we’ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for ourRouteGuideservice:port='0.0.0.0:50051's=GRPC::RpcServer.news.add_http2_port(port,:this_port_is_insecure)GRPC.logger.info("... running insecurely on#{port}")s.handle(ServerImpl.new(feature_db))# Runs the server with SIGHUP, SIGINT and SIGQUIT signal handlers to#   gracefully shutdown.# User could also choose to run server via call to run_till_terminateds.run_till_terminated_or_interrupted([1,'int','SIGQUIT'])As you can see, we build and start our server using aGRPC::RpcServer. To do
this, we:Create an instance of our service implementation classServerImpl.Specify the address and port we want to use to listen for client requests
using the builder’sadd_http2_portmethod.Register our service implementation with theGRPC::RpcServer.Callrunon theGRPC::RpcServerto create and start an RPC server for our
service.Creating the clientIn this section, we’ll look at creating a Ruby client for ourRouteGuideservice. You can see our complete example client code inexamples/ruby/route_guide/route_guide_client.rb.Creating a stubTo call service methods, we first need to create astub.We use theStubclass of theRouteGuidemodule generated from our .proto.stub=RouteGuide::Stub.new('localhost:50051')Calling service methodsNow let’s look at how we call our service methods. Note that the gRPC Ruby only
providesblocking/synchronousversions of each method: this means that the
RPC call waits for the server to respond, and will either return a response or
raise an exception.Simple RPCCalling the simple RPCGetFeatureis nearly as straightforward as calling a
local method.GET_FEATURE_POINTS=[Point.new(latitude:409_146_138,longitude:-746_188_906),Point.new(latitude:0,longitude:0)]..GET_FEATURE_POINTS.eachdo|pt|resp=stub.get_feature(pt)...p"- found '#{resp.name}' at#{pt.inspect}"endAs you can see, we create and populate a request protocol buffer object (in our
casePoint), and create a response protocol buffer object for the server to
fill in. Finally, we call the method on the stub, passing it the context,
request, and response. If the method returnsOK, then we can read the response
information from the server from our response object.Streaming RPCsNow let’s look at our streaming methods. If you’ve already readCreating the
serversome of this may look very familiar - streaming RPCs are
implemented in a similar way on both sides. Here’s where we call the server-side
streaming methodlist_features, which returns anEnumerableofFeatures.resps=stub.list_features(LIST_FEATURES_RECT)resps.eachdo|r|p"- found '#{r.name}' at#{r.location.inspect}"endNon-blocking usage of the RPC stream can be achieved with multiple threads and
thereturn_op: trueflag. When passing thereturn_op: trueflag, the
execution of the RPC is deferred and anOperationobject is returned. The RPC
can then be executed in another thread by calling the operationexecutefunction. The main thread can utilize contextual methods and getters such asstatus,cancelled?, andcancelto manage the RPC. This can be useful for
persistent or long running RPC sessions that would block the main thread for an
unacceptable period of time.op=stub.list_features(LIST_FEATURES_RECT,return_op:true)Thread.newdoresps=op.executeresps.eachdo|r|p"- found '#{r.name}' at#{r.location.inspect}"endrescueGRPC::Cancelled=>ep"operation cancel called -#{e}"end# controls for the operationop.statusop.cancelled?op.cancel# attempts to cancel the RPC with a GRPC::Cancelled status; there's a fundamental race condition where cancelling the RPC can race against RPC termination for a different reason - invoking `cancel` doesn't necessarily guarantee a `Cancelled` statusThe client-side streaming methodrecord_routeis similar, except there we pass
the server anEnumerable....reqs=RandomRoute.new(features, points_on_route)resp=stub.record_route(reqs.each)...Finally, let’s look at our bidirectional streaming RPCroute_chat. In this
case, we passEnumerableto the method and get back anEnumerable.sleeping_enumerator=SleepingEnumerator.new(ROUTE_CHAT_NOTES,1)stub.route_chat(sleeping_enumerator.each_item) {|r|p"received#{r.inspect}"}Although it’s not shown well by this example, each enumerable is independent of
the other - both the client and server can read and write in any order — the
streams operate completely independently.Try it out!Work from the example directory:$cdexamples/rubyBuild the client and server:$ gem install bundler&&bundle installRun the server:$ bundleexecroute_guide/route_guide_server.rb ../python/route_guide/route_guide_db.jsonNoteTheroute_guide_db.jsonfile is actually language-agnostic, it happens to be located in thepythonfolder.From a different terminal, run the client:$ bundleexecroute_guide/route_guide_client.rb ../python/route_guide/route_guide_db.jsonLast modified November 14, 2023:Fixes #918 - Ruby Multithreaded Client Streaming Documentation (#946) (b34c592)View page sourceEdit this pageCreate child pageCreate documentation issueCreate project issue© 2024 gRPC AuthorsTerms|Privacy|Trademarks|License|About