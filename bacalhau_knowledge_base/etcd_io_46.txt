URL: https://etcd.io/docs/v3.6/learning/api/

etcdDocsBlogCommunityInstallPlayVersionsv3.6v3.5v3.4v3.3v3.2v3.1v2.3Versionsv3.6-DRAFTQuickstartDemoTutorialsHow to Set Up a Demo etcd ClusterReading from etcdWriting to etcdHow to get keys by prefixHow to delete keysHow to make multiple writes in a transactionHow to watch keysHow to create leaseHow to create locksHow to conduct leader election in etcd clusterHow to check Cluster statusHow to save the databaseHow to migrate etcd from v2 to v3How to Add and Remove MembersInstallFAQLibraries and toolsMetricsReporting bugsTuningDiscovery service protocolLogging conventionsGolang modulesLearningData modeletcd client designetcd learner designetcd v3 authentication designetcd APIetcd persistent storage filesetcd API guaranteesetcd versus other key-value storesGlossaryDeveloper guideDiscovery service protocolSet up a local clusterInteracting with etcdWhy gRPC gatewaygRPC naming and discoverySystem limitsetcd featuresAPI referenceAPI reference: concurrencyOperations guideAuthentication GuidesRole-based access controlAuthenticationConfiguration optionsTransport security modelClustering GuideRun etcd clusters as a Kubernetes StatefulSetRun etcd clusters inside containersFailure modesDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMonitoring etcdPerformanceDesign of runtime reconfigurationRuntime reconfigurationSupported platformsVersioningData CorruptionBenchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkBenchmarking etcd v3Benchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0Benchmarking etcd v2.1.0UpgradingUpgrading etcd clusters and applicationsUpgrade etcd from 3.4 to 3.5Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.0 to 3.1Upgrade etcd from 2.3 to 3.0TriageIssue triage guidelinesPR managementv3.5QuickstartDemoTutorialsHow to Set Up a Demo etcd ClusterReading from etcdWriting to etcdHow to get keys by prefixHow to delete keysHow to make multiple writes in a transactionHow to watch keysHow to create leaseHow to create locksHow to conduct leader election in etcd clusterHow to check Cluster statusHow to save the databaseHow to migrate etcd from v2 to v3How to Add and Remove MembersInstallFAQLibraries and toolsMetricsReporting bugsTuningDiscovery service protocolLogging conventionsGolang modulesLearningData modeletcd client designetcd learner designetcd v3 authentication designetcd APIetcd persistent storage filesetcd API guaranteesetcd versus other key-value storesGlossaryDeveloper guideDiscovery service protocolSet up a local clusterInteracting with etcdWhy gRPC gatewaygRPC naming and discoverySystem limitsetcd featuresAPI referenceAPI reference: concurrencyOperations guideAuthentication GuidesRole-based access controlAuthenticationConfiguration optionsTransport security modelClustering GuideRun etcd clusters as a Kubernetes StatefulSetRun etcd clusters inside containersFailure modesDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMonitoring etcdPerformanceDesign of runtime reconfigurationRuntime reconfigurationSupported platformsVersioningData CorruptionBenchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkBenchmarking etcd v3Benchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0Benchmarking etcd v2.1.0DowngradingDowngrading etcd clusters and applicationsDowngrade etcd from 3.5 to 3.4UpgradingUpgrading etcd clusters and applicationsUpgrade etcd from 3.4 to 3.5Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.0 to 3.1Upgrade etcd from 2.3 to 3.0TriageIssue triage guidelinesPR managementv3.4QuickstartOverviewDemoInstallFAQLibraries and toolsMetricsReporting bugsTuningDiscovery service protocolLogging conventionsLearningData modeletcd client designetcd learner designetcd v3 authentication designetcd3 APIetcd API guaranteesetcd versus other key-value storesGlossaryDeveloper guideDiscovery service protocolSet up a local clusterInteracting with etcdWhy gRPC gatewaygRPC naming and discoverySystem limitsetcd featuresAPI referenceAPI reference: concurrencyOperations guideConfiguration optionsRole-based access controlTransport security modelClustering GuideRun etcd clusters inside containersFailure modesDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenancePerformanceDesign of runtime reconfigurationRuntime reconfigurationSupported platformsMigrate applications from using API v2 to API v3VersioningData CorruptionMonitoring etcdBenchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkBenchmarking etcd v3Benchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0Benchmarking etcd v2.1.0UpgradingUpgrading etcd clusters and applicationsUpgrade etcd from 3.4 to 3.5Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.0 to 3.1Upgrade etcd from 2.3 to 3.0PlatformsAmazon Web ServicesContainer Linux with systemdFreeBSDTriageIssue Triage Guidelinesv3.3InstallLibraries and toolsMetricsBenchmarksBenchmarking etcd v2.1.0Benchmarking etcd v2.2.0Benchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v3Storage Memory Usage BenchmarkWatch Memory Usage BenchmarkDemoDeveloper guideDiscovery service protocoletcd API Referenceetcd concurrency API ReferenceExperimental APIs and featuresgRPC naming and discoveryInteracting with etcdSet up a local clusterSystem limitsWhy gRPC gatewayDiscovery service protocoletcd v3 APIFrequently Asked Questions (FAQ)Learningetcd client architectureClient feature matrixData modeletcd v3 authentication designetcd versus other key-value storesetcd3 APIGlossaryKV API guaranteesLearnerLogging conventionsOperations guideMonitoring etcdVersioningClustering GuideConfiguration flagsDesign of runtime reconfigurationDisaster recoveryetcd gatewayFailure modesgRPC proxyHardware recommendationsMaintenanceMigrate applications from using API v2 to API v3PerformanceRole-based access controlRun etcd clusters inside containersRuntime reconfigurationSupported systemsTransport security modelPlatformsAmazon Web ServicesContainer Linux with systemdFreeBSDProduction usersReporting bugsTuningUpgradingUpgrade etcd from 2.3 to 3.0Upgrade etcd from 3.0 to 3.1Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.4 to 3.5Upgrading etcd clusters and applicationsv3.2BenchmarksBenchmarking etcd v2.1.0Benchmarking etcd v2.2.0Benchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v3-demoStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkData modelDemoDeveloper guideDiscovery service protocoletcd API referenceetcd concurrency API ReferenceExperimental APIs and featuresgRPC gatewaygRPC naming and discoveryInteracting with etcdSet up a local clusterSystem limitsetcd dev internalDiscovery service protocolLogging conventionsetcd operations guideAuthentication GuideClustering GuideConfiguration flagsDesign of runtime reconfigurationDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMigrate applications from using API v2 to API v3Monitoring etcdPerformanceRun etcd clusters inside containersRuntime reconfigurationSecurity modelSupported platformsUnderstand failuresVersioningetcd upgradesUpgrade etcd from 2.3 to 3.0Upgrade etcd from 3.0 to 3.1Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.3 to 3.4Upgrading etcd clusters and applicationsetcd v3 authentication designetcd versus other key-value storesetcd3 APIFrequently Asked Questions (FAQ)GlossaryInstallKV API guaranteesLibraries and toolsMetricsPlatformsAmazon Web ServicesFreeBSDRun etcd on Container Linux with systemdProduction usersReporting bugsRFCetcd v3 APITuningv3.1Data modelDemoetcd benchmarksetcd v2.1.0-alpha benchmarksetcd v2.2.0 benchmarksetcd v2.2.0-rc benchmarksetcd v2.2.0-rc-memory benchmarksetcd v3-demo benchmarksStorage Memory Usage BenchmarkWatch Memory Usage Benchmarketcd developer guideDiscovery service protocoletcd API ReferenceExperimental APIs and featuresgRPC GatewaygRPC naming and discoveryInteracting with etcdSetup a local clusterSystem limitsetcd internal devDiscovery service protocolLogging conventionsetcd operations guideClustering GuideConfiguration flagsDesign of runtime reconfigurationDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMigrate applications from using API v2 to API v3Monitoring etcdPerformanceRun etcd clusters inside containersRuntime reconfigurationSecurity modelSupported platformsUnderstand failuresVersioningetcd3 APIFrequently Asked Questions (FAQ)GlossaryInstallKV API guaranteesLibraries and toolsMetricsPlatformsFreeBSDProduction usersReporting bugsRFCetcd v3 APITuningUpgrading etcd clusters and applicationsUpgrade etcd from 2.3 to 3.0Upgrade etcd from 3.0 to 3.1Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.3 to 3.4Why etcdv2.3AdministrationAuthentication GuideBackward CompatibilityBenchmarksBenchmarking etcd v2.2.0etcd 2.1.0-alpha benchmarksetcd 2.2.0-rc benchmarksetcd 2.2.0-rc memory benchmarksetcd 3 demo benchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkClustering GuideConfiguration FlagsDesign of Runtime ReconfigurationDevelopmentDiscovery Service ProtocolError Codeetcd APIetcd v3 APIFAQGlossaryLibraries and ToolsMembers APIMetricsMiscellaneous APIsPlatformsFreeBSProduction UsersProxyReporting BugsRunning etcd under DockerRuntime ReconfigurationSecurity ModelSnapshot MigrationTuningUpgrade etcd from 2.1 to 2.2Upgrade etcd from 2.1 to 2.2Upgrade etcd from 2.2 to 2.3v2 Auth and SecurityVersioningView page sourceEdit this pageCreate child pageCreate documentation issueCreate project issuegRPC ServicesRequests and ResponsesResponse headerKey-Value APISystem primitivesKey-Value pairRangePutDelete RangeTransactionWatch APIEventsWatch streamsLease APIObtaining leasesKeep alivesVersionsv3.6-DRAFTLearningetcd APIetcd APIetcd API central design overviewThis document is meant to give an overview of the v3 etcd APIs central design.
This should not be mistaken with etcd v2 API, deprecated in etcd v3.5.
It is by no means all encompassing, but intended to focus on the basic ideas needed to understand etcd without the distraction of less common API calls.
All etcd APIs are defined ingRPC services, which categorize remote procedure calls (RPCs) understood by the etcd server.
A full listing of all etcd RPCs are documented in markdown in thegRPC API listing.gRPC ServicesEvery API request sent to an etcd server is a gRPC remote procedure call. RPCs in etcd are categorized based on functionality into services.Services important for dealing with etcd’s key space include:KV - Creates, updates, fetches, and deletes key-value pairs.Watch - Monitors changes to keys.Lease - Primitives for consuming client keep-alive messages.Services which manage the cluster itself include:Auth - Role based authentication mechanism for authenticating users.Cluster - Provides membership information and configuration facilities.Maintenance - Takes recovery snapshots, defragments the store, and returns per-member status information.Requests and ResponsesAll RPCs in etcd follow the same format. Each RPC has a functionNamewhich takesNameRequestas an argument and returnsNameResponseas a response. For example, here is theRangeRPC description:serviceKV{Range(RangeRequest)returns(RangeResponse)...}Response headerAll Responses from etcd API have an attached response header which includes cluster metadata for the response:messageResponseHeader{uint64cluster_id=1;uint64member_id=2;int64revision=3;uint64raft_term=4;}Cluster_ID - the ID of the cluster generating the response.Member_ID - the ID of the member generating the response.Revision - the revision of the key-value store when generating the response.Raft_Term - the Raft term of the member when generating the response.An application may read theCluster_IDorMember_IDfield to ensure it is communicating with the intended cluster (member).Applications can use theRevisionfield to know the latest revision of the key-value store. This is especially useful when applications specify a historical revision to make atime travel queryand wish to know the latest revision at the time of the request.Applications can useRaft_Termto detect when the cluster completes a new leader election.Key-Value APIThe Key-Value API manipulates key-value pairs stored inside etcd. The majority of requests made to etcd are usually key-value requests.System primitivesKey-Value pairA key-value pair is the smallest unit that the key-value API can manipulate. Each key-value pair has a number of fields, defined inprotobuf format:messageKeyValue{byteskey=1;int64create_revision=2;int64mod_revision=3;int64version=4;bytesvalue=5;int64lease=6;}Key - key in bytes. An empty key is not allowed.Value - value in bytes.Version - version is the version of the key. A deletion resets the version to zero and any modification of the key increases its version.Create_Revision - revision of the last creation on the key.Mod_Revision - revision of the last modification on the key.Lease - the ID of the lease attached to the key. If lease is 0, then no lease is attached to the key.In addition to just the key and value, etcd attaches additional revision metadata as part of the key message. This revision information orders keys by time of creation and modification, which is useful for managing concurrency for distributed synchronization. The etcd client’sdistributed shared locksuse the creation revision to wait for lock ownership. Similarly, the modification revision is used for detectingsoftware transactional memoryread set conflicts and waiting onleader electionupdates.Revisionsetcd maintains a 64-bit cluster-wide counter, the store revision, that is incremented each time the key space is modified. The revision serves as a global logical clock, sequentially ordering all updates to the store. The change represented by a new revision is incremental; the data associated with a revision is the data that changed the store. Internally, a new revision means writing the changes to the backend’s B+tree, keyed by the incremented revision.Revisions become more valuable when considering etcd’smulti-version concurrency controlbackend. The MVCC model means that the key-value store can be viewed from past revisions since historical key revisions are retained. The retention policy for this history can be configured by cluster administrators for fine-grained storage management; usually etcd discards old revisions of keys on a timer. A typical etcd cluster retains superseded key data for hours. This also provides reliable handling for long client disconnection, not just transient network disruptions: watchers simply resume from the last observed historical revision. Similarly, to read from the store at a particular point-in-time, read requests can be tagged with a revision to return keys from a view of the key space at the point-in-time that revision was committed.Key rangesThe etcd data model indexes all keys over a flat binary key space. This differs from other key-value store systems that use a hierarchical system of organizing keys into directories. Instead of listing keys by directory, keys are listed by key intervals[a, b).These intervals are often referred to as “ranges” in etcd. Operations over ranges are more powerful than operations on directories. Like a hierarchical store, intervals support single key lookups via[a, a+1)(e.g., [‘a’, ‘a\x00’) looks up ‘a’) and directory lookups by encoding keys by directory depth. In addition to those operations, intervals can also encode prefixes; for example the interval['a', 'b')looks up all keys prefixed by the string ‘a’.By convention, ranges for a request are denoted by the fieldskeyandrange_end. Thekeyfield is the first key of the range and should be non-empty. Therange_endis the key following the last key of the range. Ifrange_endis not given or empty, the range is defined to contain only the key argument. Ifrange_endiskeyplus one (e.g., “aa”+1 == “ab”, “a\xff”+1 == “b”), then the range represents all keys prefixed with key. If bothkeyandrange_endare ‘\0’, then range represents all keys. Ifrange_endis ‘\0’, the range is all keys greater than or equal to the key argument.RangeKeys are fetched from the key-value store using theRangeAPI call, which takes aRangeRequest:messageRangeRequest{enumSortOrder{NONE=0;// default, no sortingASCEND=1;// lowest target value firstDESCEND=2;// highest target value first}enumSortTarget{KEY=0;VERSION=1;CREATE=2;MOD=3;VALUE=4;}byteskey=1;bytesrange_end=2;int64limit=3;int64revision=4;SortOrdersort_order=5;SortTargetsort_target=6;boolserializable=7;boolkeys_only=8;boolcount_only=9;int64min_mod_revision=10;int64max_mod_revision=11;int64min_create_revision=12;int64max_create_revision=13;}Key, Range_End - The key range to fetch.Limit - the maximum number of keys returned for the request. When limit is set to 0, it is treated as no limit.Revision - the point-in-time of the key-value store to use for the range. If revision is less or equal to zero, the range is over the latest key-value store. If the revision is compacted, ErrCompacted is returned as a response.Sort_Order - the ordering for sorted requests.Sort_Target - the key-value field to sort.Serializable - sets the range request to use serializable member-local reads. By default, Range is linearizable; it reflects the current consensus of the cluster. For better performance and availability, in exchange for possible stale reads, a serializable range request is served locally without needing to reach consensus with other nodes in the cluster.Keys_Only - return only the keys and not the values.Count_Only - return only the count of the keys in the range.Min_Mod_Revision - the lower bound for key mod revisions; filters out lesser mod revisions.Max_Mod_Revision - the upper bound for key mod revisions; filters out greater mod revisions.Min_Create_Revision - the lower bound for key create revisions; filters out lesser create revisions.Max_Create_Revision - the upper bound for key create revisions; filters out greater create revisions.The client receives aRangeResponsemessage from theRangecall:messageRangeResponse{ResponseHeaderheader=1;repeatedmvccpb.KeyValuekvs=2;boolmore=3;int64count=4;}Kvs - the list of key-value pairs matched by the range request. WhenCount_Onlyis set,Kvsis empty.More - indicates if there are more keys to return in the requested range iflimitis set.Count - the total number of keys satisfying the range request.PutKeys are saved into the key-value store by issuing aPutcall, which takes aPutRequest:messagePutRequest{byteskey=1;bytesvalue=2;int64lease=3;boolprev_kv=4;boolignore_value=5;boolignore_lease=6;}Key - the name of the key to put into the key-value store.Value - the value, in bytes, to associate with the key in the key-value store.Lease - the lease ID to associate with the key in the key-value store. A lease value of 0 indicates no lease.Prev_Kv - when set, responds with the key-value pair data before the update from thisPutrequest.Ignore_Value - when set, update the key without changing its current value. Returns an error if the key does not exist.Ignore_Lease - when set, update the key without changing its current lease. Returns an error if the key does not exist.The client receives aPutResponsemessage from thePutcall:messagePutResponse{ResponseHeaderheader=1;mvccpb.KeyValueprev_kv=2;}Prev_Kv - the key-value pair overwritten by thePut, ifPrev_Kvwas set in thePutRequest.Delete RangeRanges of keys are deleted using theDeleteRangecall, which takes aDeleteRangeRequest:messageDeleteRangeRequest{byteskey=1;bytesrange_end=2;boolprev_kv=3;}Key, Range_End - The key range to delete.Prev_Kv - when set, return the contents of the deleted key-value pairs.The client receives aDeleteRangeResponsemessage from theDeleteRangecall:messageDeleteRangeResponse{ResponseHeaderheader=1;int64deleted=2;repeatedmvccpb.KeyValueprev_kvs=3;}Deleted - number of keys deleted.Prev_Kv - a list of all key-value pairs deleted by theDeleteRangeoperation.TransactionA transaction is an atomic If/Then/Else construct over the key-value store. It provides a primitive for grouping requests together in atomic blocks (i.e., then/else) whose execution is guarded (i.e., if) based on the contents of the key-value store. Transactions can be used for protecting keys from unintended concurrent updates, building compare-and-swap operations, and developing higher-level concurrency control.A transaction can atomically process multiple requests in a single request. For modifications to the key-value store, this means the store’s revision is incremented only once for the transaction and all events generated by the transaction will have the same revision. However, modifications to the same key multiple times within a single transaction are forbidden.All transactions are guarded by a conjunction of comparisons, similar to anIfstatement. Each comparison checks a single key in the store. It may check for the absence or presence of a value, compare with a given value, or check a key’s revision or version. Two different comparisons may apply to the same or different keys. All comparisons are applied atomically; if all comparisons are true, the transaction is said to succeed and etcd applies the transaction’s then /successrequest block, otherwise it is said to fail and applies the else /failurerequest block.Each comparison is encoded as aComparemessage:messageCompare{enumCompareResult{EQUAL=0;GREATER=1;LESS=2;NOT_EQUAL=3;}enumCompareTarget{VERSION=0;CREATE=1;MOD=2;VALUE=3;}CompareResultresult=1;// target is the key-value field to inspect for the comparison.CompareTargettarget=2;// key is the subject key for the comparison operation.byteskey=3;oneoftarget_union{int64version=4;int64create_revision=5;int64mod_revision=6;bytesvalue=7;}}Result - the kind of logical comparison operation (e.g., equal, less than, etc).Target - the key-value field to be compared. Either the key’s version, create revision, modification revision, or value.Key - the key for the comparison.Target_Union - the user-specified data for the comparison.After processing the comparison block, the transaction applies a block of requests. A block is a list ofRequestOpmessages:messageRequestOp{// request is a union of request types accepted by a transaction.oneofrequest{RangeRequestrequest_range=1;PutRequestrequest_put=2;DeleteRangeRequestrequest_delete_range=3;}}Request_Range - aRangeRequest.Request_Put - aPutRequest. The keys must be unique. It may not share keys with any other Puts or Deletes.Request_Delete_Range - aDeleteRangeRequest. It may not share keys with any Puts or Deletes requests.All together, a transaction is issued with aTxnAPI call, which takes aTxnRequest:messageTxnRequest{repeatedComparecompare=1;repeatedRequestOpsuccess=2;repeatedRequestOpfailure=3;}Compare - A list of predicates representing a conjunction of terms for guarding the transaction.Success - A list of requests to process if all compare tests evaluate to true.Failure - A list of requests to process if any compare test evaluates to false.The client receives aTxnResponsemessage from theTxncall:messageTxnResponse{ResponseHeaderheader=1;boolsucceeded=2;repeatedResponseOpresponses=3;}Succeeded - WhetherCompareevaluated to true or false.Responses - A list of responses corresponding to the results from applying theSuccessblock if succeeded is true or theFailureif succeeded is false.TheResponseslist corresponds to the results from the appliedRequestOplist, with each response encoded as aResponseOp:messageResponseOp{oneofresponse{RangeResponseresponse_range=1;PutResponseresponse_put=2;DeleteRangeResponseresponse_delete_range=3;}}TheResponseHeaderincluded in each inner response shouldn’t be interpreted in any way.
If clients need to get the latest revision, then they should always check the top levelResponseHeaderinTxnResponse.Watch APITheWatchAPI provides an event-based interface for asynchronously monitoring changes to keys. An etcd watch waits for changes to keys by continuously watching from a given revision, either current or historical, and streams key updates back to the client.EventsEvery change to every key is represented withEventmessages. AnEventmessage provides both the update’s data and the type of update:messageEvent{enumEventType{PUT=0;DELETE=1;}EventTypetype=1;KeyValuekv=2;KeyValueprev_kv=3;}Type - The kind of event. A PUT type indicates new data has been stored to the key. A DELETE indicates the key was deleted.KV - The KeyValue associated with the event. A PUT event contains current kv pair. A PUT event with kv.Version=1 indicates the creation of a key. A DELETE event contains the deleted key with its modification revision set to the revision of deletion.Prev_KV - The key-value pair for the key from the revision immediately before the event. To save bandwidth, it is only filled out if the watch has explicitly enabled it.Watch streamsWatches are long-running requests and use gRPC streams to stream event data. A watch stream is bi-directional; the client writes to the stream to establish watches and reads to receive watch events. A single watch stream can multiplex many distinct watches by tagging events with per-watch identifiers. This multiplexing helps reducing the memory footprint and connection overhead on the core etcd cluster.To read about guarantees made about watch events, please readetcd api guarantees.A client creates a watch by sending aWatchCreateRequestover a stream returned byWatch:messageWatchCreateRequest{byteskey=1;bytesrange_end=2;int64start_revision=3;boolprogress_notify=4;enumFilterType{NOPUT=0;NODELETE=1;}repeatedFilterTypefilters=5;boolprev_kv=6;}Key, Range_End - The key range to watch.Start_Revision - An optional revision for where to inclusively begin watching. If not given, it will stream events following the revision of the watch creation response header revision. The entire available event history can be watched starting from the last compaction revision.Progress_Notify - When set, the watch will periodically receive a WatchResponse with no events, if there are no recent events. It is useful when clients wish to recover a disconnected watcher starting from a recent known revision. The etcd server decides how often to send notifications based on current server load.Filters - A list of event types to filter away at server side.Prev_Kv - When set, the watch receives the key-value data from before the event happens. This is useful for knowing what data has been overwritten.In response to aWatchCreateRequestor if there is a new event for some established watch, the client receives aWatchResponse:messageWatchResponse{ResponseHeaderheader=1;int64watch_id=2;boolcreated=3;boolcanceled=4;int64compact_revision=5;repeatedmvccpb.Eventevents=11;}Watch_ID - the ID of the watch that corresponds to the response.Created - set to true if the response is for a create watch request. The client should store the ID and expect to receive events for the watch on the stream. All events sent to the created watcher will have the same watch_id.Canceled - set to true if the response is for a cancel watch request. No further events will be sent to the canceled watcher.Compact_Revision - set to the minimum historical revision available to etcd if a watcher tries watching at a compacted revision. This happens when creating a watcher at a compacted revision or the watcher cannot catch up with the progress of the key-value store. The watcher will be canceled; creating new watches with the same start_revision will fail.Events - a list of new events in sequence corresponding to the given watch ID.If the client wishes to stop receiving events for a watch, it issues aWatchCancelRequest:messageWatchCancelRequest{int64watch_id=1;}Watch_ID - the ID of the watch to cancel so that no more events are transmitted.Lease APILeases are a mechanism for detecting client liveness. The cluster grants leases with a time-to-live. A lease expires if the etcd cluster does not receive a keepAlive within a given TTL period.To tie leases into the key-value store, each key may be attached to at most one lease. When a lease expires or is revoked, all keys attached to that lease will be deleted. Each expired key generates a delete event in the event history.Obtaining leasesLeases are obtained through theLeaseGrantAPI call, which takes aLeaseGrantRequest:messageLeaseGrantRequest{int64TTL=1;int64ID=2;}TTL - the advisory time-to-live, in seconds.ID - the requested ID for the lease. If ID is set to 0, etcd will choose an ID.The client receives aLeaseGrantResponsefrom theLeaseGrantcall:messageLeaseGrantResponse{ResponseHeaderheader=1;int64ID=2;int64TTL=3;}ID - the lease ID for the granted lease.TTL - is the server selected time-to-live, in seconds, for the lease.messageLeaseRevokeRequest{int64ID=1;}ID - the lease ID to revoke. When the lease is revoked, all attached keys are deleted.Keep alivesLeases are refreshed using a bi-directional stream created with theLeaseKeepAliveAPI call. When the client wishes to refresh a lease, it sends aLeaseKeepAliveRequestover the stream:messageLeaseKeepAliveRequest{int64ID=1;}ID - the lease ID for the lease to keep alive.The keep alive stream responds with aLeaseKeepAliveResponse:messageLeaseKeepAliveResponse{ResponseHeaderheader=1;int64ID=2;int64TTL=3;}ID - the lease that was refreshed with a new TTL.TTL - the new time-to-live, in seconds, that the lease has remaining.FeedbackWas this page helpful?YesNoGlad to hear it! Pleasetell us how we can improve.Sorry to hear that. Pleasetell us how we can improve.Last modified April 27, 2023:Update the api guarantees based on Kubernetes-etcd implicit contract document (7a0f738)©
2013–2024etcd AuthorsTerms|Privacy|Trademarks|LicenseAll Rights Reserved