URL: https://cassandra.apache.org/doc/latest/cassandra/architecture/storage-engine.html

Get StartedCassandra BasicsQuickstartEcosystemDocumentationCommunityWelcomeDiscussionsGovernanceContributeMeet the CommunityCatalyst ProgramEventsLearnCassandra 5.0Case StudiesResourcesBlogDownload NowCassandra DocumentationVersion:5.0mastertrunk5.04.14.03.11MainGlossaryHow to report bugsContact usDevelopmentGetting startedBuilding and IDE integrationTestingContributing code changesCode styleReview checklistHow to commitWorking on documentationJenkins CI environmentDependency managementRelease processCassandraFAQGetting StartedCassandra QuickstartSAI QuickstartVector Search QuickstartInstalling CassandraConfiguring CassandraInserting and queryingClient driversProduction recommendationsWhat’s newSupport for JavaArchitectureOverviewDynamoStorage EngineGuaranteesImproved Internode MessagingImproved StreamingData ModelingIntroductionConceptual data modelingRDBMS designDefining application queriesLogical data modelingPhysical data modelingEvaluating and refining data modelsDefining database schemaCassandra data modeling toolsCassandra Query Language (CQL)DefinitionsData typesData definition (DDL)Data manipulation (DML)Dynamic Data Masking (DDM)OperatorsIndexing conceptsSAI OverviewConceptsSAI QuickstartSAI FAQWorking with SAISAI operationsSecondary indexes (2i) overviewConceptsWorking with 2iRebuild 2iMaterialized viewsFunctionsJSONSecurityTriggersAppendicesChangesSASISingle file of CQL informationVector Search overviewConceptsData ModelingVector Search QuickstartWorking with Vector SearchManagingConfiguringcassandra.yamlcassandra-rackdc.propertiescassandra-env.shcassandra-topologies.propertiescommitlog-archiving.propertieslogback.xmljvm-* filesLiberating cassandra.yaml Parameters' Names from Their UnitsOperatingBackupsBloom filtersBulk loadingChange Data Capture (CDC)CompactionCompressionHardwareHintsLoggingAudit loggingAudit logging 2Full query loggingMonitoring metricsRepairRead repairSecuritySnitchesTopology changesTransient replicationVirtual tablesToolscqlsh: the CQL shellnodetoolSSTable toolscassandra-stressTroubleshootingFinding misbehaving nodesReading Cassandra logsUsing nodetoolUsing external tools to deep-diveReferenceALTER TABLECREATE INDEXCREATE CUSTOM INDEXCREATE TABLEDROP INDEXDROP TABLEPlug-insYou are viewing the documentation for a prerelease version.CassandraArchitectureStorage EngineEditStorage EngineCassandra processes data at several stages on the write path, starting with the immediate logging of a write and ending in with a write of data to disk:Logging data in the commit logWriting data to the memtableFlushing data from the memtableStoring data on disk in SSTablesLogging writes to commit logsWhen a write occurs, Cassandra writes the data to a local append-only (cassandra.apache.org//glossary.html#commit-log)[commit log] on disk.
This action providesconfigurable durabilityby logging every write made to a Cassandra node.
If an unexpected shutdown occurs, the commit log provides permanent durable writes of the data.
On startup, any mutations in the commit log will be applied to (cassandra.apache.org//glossary.html#memtable)[memtables].
The commit log is shared among tables.All mutations are write-optimized on storage in commit log segments, reducing the number of seeks needed to write to disk.
Commit log segments are limited by thecommitlog_segment_sizeoption.
Once the defined size is reached, a new commit log segment is created.
Commit log segments can be archived, deleted, or recycled once all the data is flushed to
(SSTables.
Commit log segments are truncated when Cassandra has written data older than a certain point to the SSTables.
Runningnodetool drainbefore stopping Cassandra will write everything in the memtables
to SSTables and remove the need to sync with the commit logs on startup.commitlog_segment_size: The default size is 32MiB, which is almost always fine, but if you are archiving commitlog segments (see commitlog_archiving.properties), then you probably want a finer granularity of archiving; 8 or 16 MiB is reasonable.commitlog_segment_sizealso determines the default value ofmax_mutation_sizeincassandra.yaml. By default,max_mutation_sizeis a half the size ofcommitlog_segment_size.Ifmax_mutation_sizeis set explicitly thencommitlog_segment_sizemust be set to at least twice the size ofmax_mutation_size.commitlog_sync: may be eitherperiodicorbatch.batch: In batch mode, Cassandra won’t acknowledge writes until the commit log has been fsynced to disk.periodic: In periodic mode, writes are immediately acknowledged, and the commit log is simply synced every "commitlog_sync_period" milliseconds.commitlog_sync_period: Time to wait between "periodic" fsyncsDefault Value:10000msDefault Value:batchIn the event of an unexpected shutdown, Cassandra can lose up to the sync period or more if the sync is delayed.
If usingbatchmode, it is recommended to store commit logs in a separate, dedicated device.commitlog_directory: This option is commented out by default.
When running on magnetic HDD, this should be a separate spindle than the data directories.
If not set, the default directory is$CASSANDRA_HOME/data/commitlog.Default Value:/var/lib/cassandra/commitlogcommitlog_compression: Compression to apply to the commitlog.
If omitted, the commit log will be written uncompressed.
LZ4, Snappy,Deflate and Zstd compressors are supported.Default Value:(complex option):#   - class_name: LZ4Compressor
#     parameters:commitlog_total_space: Total space to use for commit logs on disk.
This option is commented out by default.
If space gets above this value, Cassandra will flush every dirty table in the oldest segment and remove it.
So a small total commit log space will tend to cause more flush activity on less-active tables.
The default value is the smallest between 8192 and 1/4 of the total space of the commitlog volume.Default Value:8192MiBMemtablesWhen a write occurs, Cassandra also writes the data to a memtable.
Memtables are in-memory structures where Cassandra buffers writes.
In general, there is one active memtable per table.
The memtable is a write-back cache of data partitions that Cassandra looks up by key.
Memtables may be stored entirely on-heap or partially off-heap, depending onmemtable_allocation_type.The memtable stores writes in sorted order until reaching a configurable limit.
When the limit is reached, memtables are flushed onto disk and become immutableSSTables.
Flushing can be triggered in several ways:The memory usage of the memtables exceeds the configured threshold (seememtable_cleanup_threshold)Thecommit logapproaches its maximum size, and forces memtable flushes in order to allow commit log segments to be freed.When a triggering event occurs, the memtable is put in a queue that is flushed to disk.
Flushing writes the data to disk, in the memtable-sorted order.
A partition index is also created on the disk that maps the tokens to a location on disk.The queue can be configured with either thememtable_heap_spaceormemtable_offheap_spacesetting in thecassandra.yamlfile.
If the data to be flushed exceeds thememtable_cleanup_threshold, Cassandra blocks writes until the next flush succeeds.
You can manually flush a table usingnodetool flushornodetool drain(flushes memtables without listening for connections to other nodes).
To reduce the commit log replay time, the recommended best practice is to flush the memtable before you restart the nodes.
If a node stops working, replaying the commit log restores writes to the memtable that were there before it stopped.Data in the commit log is purged after its corresponding data in the memtable is flushed to an SSTable on disk.SSTablesSSTablesare the immutable data files that Cassandra uses for persisting data on disk.
SSTables are maintained per table.
SSTables are immutable, and never written to again after the memtable is flushed.
Thus, a partition is typically stored across multiple SSTable files, as data is added or modified.Each SSTable is comprised of multiple components stored in separate files:Data.dbThe actual data, i.e. the contents of rows.Partitions.dbThe partition index file maps unique prefixes of decorated partition keys to data file locations, or, in the case of wide partitions indexed in the row index file, to locations in the row index file.Rows.dbThe row index file only contains entries for partitions that contain more than one row and are bigger than one index block.
For all such partitions, it stores a copy of the partition key, a partition header, and an index of row block separators, which map each row key into the first block where any content with equal or higher row key can be found.Index.dbAn index from partition keys to positions in theData.dbfile.
For wide partitions, this may also include an index to rows within a partition.Summary.dbA sampling of (by default) every 128th entry in theIndex.dbfile.Filter.dbA Bloom Filter of the partition keys in the SSTable.CompressionInfo.dbMetadata about the offsets and lengths of compression chunks in theData.dbfile.Statistics.dbStores metadata about the SSTable, including information about timestamps, tombstones, clustering keys, compaction, repair, compression, TTLs, and more.Digest.crc32A CRC-32 digest of theData.dbfile.TOC.txtA plain text list of the component files for the SSTable.SAI*.dbIndex information for Storage-Attached indexes.
Only present if SAI is enabled for the table.Note that theIndex.dbfile type is replaced byPartitions.dbandRows.db.
This change is a consequence of the inclusion of Big Trie indexes in Cassandra (CEP-25).Within theData.dbfile, rows are organized by partition.
These partitions are sorted in token order (i.e. by a hash of the partition key when the default partitioner,Murmur3Partition, is used).
Within a partition, rows are stored in the order of their clustering keys.SSTables can be optionally compressed using block-based compression.As SSTables are flushed to disk frommemtablesor are streamed from other nodes, Cassandra triggers compactions which combine multiple SSTables into one.
Once the new SSTable has been written, the old SSTables can be removed.SSTable VersionsFrom (BigFormat#BigVersion.The version numbers, to date are:Version 0b (0.7.0): added version to sstable filenamesc (0.7.0): bloom filter component computes hashes over raw key bytes
instead of stringsd (0.7.0): row size in data component becomes a long instead of inte (0.7.0): stores undecorated keys in data and index componentsf (0.7.0): switched bloom filter implementations in data componentg (0.8): tracks flushed-at context in metadata componentVersion 1h (1.0): tracks max client timestamp in metadata componenthb (1.0.3): records compression ration in metadata componenthc (1.0.4): records partitioner in metadata componenthd (1.0.10): includes row tombstones in maxtimestamphe (1.1.3): includes ancestors generation in metadata componenthf (1.1.6): marker that replay position corresponds to 1.1.5+
millis-based id (see CASSANDRA-4782)ia (1.2.0):column indexes are promoted to the index filerecords estimated histogram of deletion times in tombstonesbloom filter (keys and columns) upgraded to Murmur3ib (1.2.1): tracks min client timestamp in metadata componentic (1.2.5): omits per-row bloom filter of column namesVersion 2ja (2.0.0):super columns are serialized as composites (note that there is no
real format change, this is mostly a marker to know if we should expect
super columns or not. We do need a major version bump however, because
we should not allow streaming of super columns into this new format)tracks max local deletiontime in sstable metadatarecords bloom_filter_fp_chance in metadata componentremove data size and column count from data file (CASSANDRA-4180)tracks max/min column values (according to comparator)jb (2.0.1):switch from crc32 to adler32 for compression checksumschecksum the compressed dataka (2.1.0):new Statistics.db file formatindex summaries can be downsampled and the sampling level is
persistedswitch uncompressed checksums to adler32tracks presence of legacy (local and remote) counter shardsla (2.2.0): new file name formatlb (2.2.7): commit log lower bound includedVersion 3ma (3.0.0):swap bf hash orderstore rows nativelymb (3.0.7, 3.7): commit log lower bound includedmc (3.0.8, 3.9): commit log intervals includedmd (3.0.18, 3.11.4): corrected sstable min/max clusteringme (3.0.25, 3.11.11): added hostId of the node from which the sstable originatedVersion 4na (4.0-rc1): uncompressed chunks, pending repair session, isTransient, checksummed sstable metadata file, new Bloomfilter formatnb (4.0.0): originating host idVersion 5oa (5.0): improved min/max, partition level deletion presence marker, key range (CASSANDRA-18134)Long deletionTime to prevent TTL overflowtoken space coverageTrie-indexed Based SSTable Versions (BTI)Cassandra 5.0 introduced new SSTable formats BTI for Trie-indexed SSTables.
To use the BTI formats configure itcassandra.yamllikesstable:
  selected_format: btiVersions come from (BtiFormat#BtiVersion.For implementation docs see (BtiFormat.md.Version 5da (5.0): initial version of the BIT formatExample CodeThe following example is useful for finding all sstables that do not
match the "ib" SSTable versionfind /var/lib/cassandra/data/ -type f | grep -v -- -ib- | grep -v "/snapshots"Get started with Cassandra, fast.Quickstart GuideApache Cassandrapowers mission-critical deployments with improved performance and unparalleled levels of scale in the cloud.HomeCassandra BasicsQuickstartEcosystemDocumentationCommunityCase StudiesResourcesBlogFoundationEventsLicenseThanksSecurityPrivacySponsorshipÂ© 2009-The Apache Software Foundationunder the terms of the Apache License 2.0.  Apache, the Apache feather logo, Apache Cassandra, Cassandra, and the Cassandra logo, are either registered trademarks or trademarks of The Apache Software Foundation.