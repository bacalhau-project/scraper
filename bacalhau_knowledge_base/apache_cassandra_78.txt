URL: https://cassandra.apache.org/doc/latest/cassandra/developing/cql/definitions.html

Get StartedCassandra BasicsQuickstartEcosystemDocumentationCommunityWelcomeDiscussionsGovernanceContributeMeet the CommunityCatalyst ProgramEventsLearnCassandra 5.0Case StudiesResourcesBlogDownload NowCassandra DocumentationVersion:5.0mastertrunk5.04.14.03.11MainGlossaryHow to report bugsContact usDevelopmentGetting startedBuilding and IDE integrationTestingContributing code changesCode styleReview checklistHow to commitWorking on documentationJenkins CI environmentDependency managementRelease processCassandraFAQGetting StartedCassandra QuickstartSAI QuickstartVector Search QuickstartInstalling CassandraConfiguring CassandraInserting and queryingClient driversProduction recommendationsWhat’s newSupport for JavaArchitectureOverviewDynamoStorage EngineGuaranteesImproved Internode MessagingImproved StreamingData ModelingIntroductionConceptual data modelingRDBMS designDefining application queriesLogical data modelingPhysical data modelingEvaluating and refining data modelsDefining database schemaCassandra data modeling toolsCassandra Query Language (CQL)DefinitionsData typesData definition (DDL)Data manipulation (DML)Dynamic Data Masking (DDM)OperatorsIndexing conceptsSAI OverviewConceptsSAI QuickstartSAI FAQWorking with SAISAI operationsSecondary indexes (2i) overviewConceptsWorking with 2iRebuild 2iMaterialized viewsFunctionsJSONSecurityTriggersAppendicesChangesSASISingle file of CQL informationVector Search overviewConceptsData ModelingVector Search QuickstartWorking with Vector SearchManagingConfiguringcassandra.yamlcassandra-rackdc.propertiescassandra-env.shcassandra-topologies.propertiescommitlog-archiving.propertieslogback.xmljvm-* filesLiberating cassandra.yaml Parameters' Names from Their UnitsOperatingBackupsBloom filtersBulk loadingChange Data Capture (CDC)CompactionCompressionHardwareHintsLoggingAudit loggingAudit logging 2Full query loggingMonitoring metricsRepairRead repairSecuritySnitchesTopology changesTransient replicationVirtual tablesToolscqlsh: the CQL shellnodetoolSSTable toolscassandra-stressTroubleshootingFinding misbehaving nodesReading Cassandra logsUsing nodetoolUsing external tools to deep-diveReferenceALTER TABLECREATE INDEXCREATE CUSTOM INDEXCREATE TABLEDROP INDEXDROP TABLEPlug-insYou are viewing the documentation for a prerelease version.CassandraCassandra Query Language (CQL)DefinitionsEditDefinitionsConventionsTo aid in specifying the CQL syntax, we will use the following
conventions in this document:Language rules will be given in an informalBNF
variantnotation. In particular, we’ll use square brakets ([ item ])
for optional items,*and+for repeated items (where+imply at
least one).The grammar will also use the following convention for convenience:
non-terminal term will be lowercase (and link to their definition) while
terminal keywords will be provided "all caps". Note however that
keywords areidentifiersand are thus case insensitive in practice. We
will also define some early construction using regexp, which we’ll
indicate withre(<some regular expression>).The grammar is provided for documentation purposes and leave some
minor details out. For instance, the comma on the last column definition
in aCREATE TABLEstatement is optional but supported if present even
though the grammar in this document suggests otherwise. Also, not
everything accepted by the grammar is necessarily valid CQL.References to keywords or pieces of CQL code in running text will be
shown in afixed-width font.Identifiers and keywordsThe CQL language usesidentifiers(ornames) to identify tables,
columns and other objects. An identifier is a token matching the regular
expression[a-zA-Z][a-zA-Z0-9_]*.A number of such identifiers, likeSELECTorWITH, arekeywords.
They have a fixed meaning for the language and most are reserved. The
list of those keywords can be found inAppendix A.Identifiers and (unquoted) keywords are case insensitive. ThusSELECTis the same thanselectorsElEcT, andmyIdis the same thanmyidorMYID. A convention often used (in particular by the samples
of this documentation) is to use uppercase for keywords and lowercase
for other identifiers.There is a second kind of identifier called aquoted identifierdefined by enclosing an arbitrary sequence of characters (non-empty) in
double-quotes("). Quoted identifiers are never keywords. Thus"select"is not a reserved keyword and can be used to refer to a
column (note that using this is particularly ill-advised), whileselectwould raise a parsing error. Also, unlike unquoted identifiers
and keywords, quoted identifiers are case sensitive ("My Quoted Id"isdifferentfrom"my quoted id"). A fully lowercase quoted identifier
that matches[a-zA-Z][a-zA-Z0-9_]*is howeverequivalentto the
unquoted identifier obtained by removing the double-quote (so"myid"is equivalent tomyidand tomyIdbut different from"myId").
Inside a quoted identifier, the double-quote character can be repeated
to escape it, so"foo "" bar"is a valid identifier.Thequoted identifiercan declare columns with arbitrary names, and
these can sometime clash with specific names used by the server. For
instance, when using conditional update, the server will respond with a
result set containing a special result named"[applied]". If youâve
declared a column with such a name, this could potentially confuse some
tools and should be avoided. In general, unquoted identifiers should be
preferred but if you use quoted identifiers, it is strongly advised that you
avoid any name enclosed by squared brackets (like"[applied]") and any
name that looks like a function call (like"f(x)").More formally, we have:identifier::= unquoted_identifier | quoted_identifier
unquoted_identifier::= re('[a-zA-Z][link:[a-zA-Z0-9]]*')
quoted_identifier::= '"' (any character where " can appear if doubled)+ '"'ConstantsCQL defines the followingconstants:constant::= string | integer | float | boolean | uuid | blob | NULL
string::= ''' (any character where ' can appear if doubled)+ ''' : '$$' (any character other than '$$') '$$'
integer::= re('-?[0-9]+')
float::= re('-?[0-9]+(.[0-9]*)?([eE][+-]?[0-9+])?') | NAN | INFINITY
boolean::= TRUE | FALSE
uuid::= hex\{8}-hex\{4}-hex\{4}-hex\{4}-hex\{12}
hex::= re("[0-9a-fA-F]")
blob::= '0' ('x' | 'X') hex+In other words:A string constant is an arbitrary sequence of characters enclosed by
single-quote('). A single-quote can be included by repeating it, e.g.'It''s raining today'. Those are not to be confused with quotedidentifiersthat use double-quotes. Alternatively, a string can be
defined by enclosing the arbitrary sequence of characters by two dollar
characters, in which case single-quote can be used without escaping
(It's raining today). That latter form is often used when defininguser-defined functionsto avoid having to escape single-quote
characters in function body (as they are more likely to occur than$$).Integer, float and boolean constant are defined as expected. Note
however than float allows the specialNaNandInfinityconstants.CQL supportsUUIDconstants.The content for blobs is provided in hexadecimal and prefixed by0x.The specialNULLconstant denotes the absence of value.For how these constants are typed, see theData typessection.TermsCQL has the notion of aterm, which denotes the kind of values that
CQL support. Terms are defined by:term::= constant | literal | function_call | arithmetic_operation | type_hint | bind_marker
literal::= collection_literal | vector_literal | udt_literal | tuple_literal
function_call::= identifier '(' [ term (',' term)* ] ')'
arithmetic_operation::= '-' term | term ('+' | '-' | '*' | '/' | '%') term
type_hint::= '(' cql_type ')' term
bind_marker::= '?' | ':' identifierA term is thus one of:AconstantA literal for either acollection, avector,
auser-defined typeor atupleAfunctioncall, either anative functionor auser-defined functionAnarithmetic operationbetween termsA type hintA bind marker, which denotes a variable to be bound at execution time.
See the section onprepared-statementsfor details. A bind marker can
be either anonymous (?) or named (:some_name). The latter form
provides a more convenient way to refer to the variable for binding it
and should generally be preferred.CommentsA comment in CQL is a line beginning by either double dashes (--) or
double slash (//).Multi-line comments are also supported through enclosure within/and/(but nesting is not supported).-- This is a comment
// This is a comment too
/* This is
   a multi-line comment */StatementsCQL consists of statements that can be divided in the following
categories:data-definitionstatements, to define and change how the data is
stored (keyspaces and tables).data-manipulationstatements, for selecting, inserting and deleting
data.secondary-indexesstatements.materialized-viewsstatements.cql-rolesstatements.cql-permissionsstatements.User-Defined Functions (UDFs)statements.udtsstatements.cql-triggersstatements.All the statements are listed below and are described in the rest of
this documentation (see links above):cql_statement::= statement [ ';' ]
statement:=: ddl_statement :
        | dml_statement
        | secondary_index_statement
        | materialized_view_statement
        | role_or_permission_statement
        | udf_statement
        | udt_statement
        | trigger_statement
ddl_statement::= use_statement
        | create_keyspace_statement
        | alter_keyspace_statement
        | drop_keyspace_statement
        | create_table_statement
        | alter_table_statement
        | drop_table_statement
        | truncate_statement
dml_statement::= select_statement
        | insert_statement
        | update_statement
        | delete_statement
        | batch_statement
secondary_index_statement::= create_index_statement
        | drop_index_statement
materialized_view_statement::= create_materialized_view_statement
        | drop_materialized_view_statement
role_or_permission_statement::= create_role_statement
        | alter_role_statement
        | drop_role_statement
        | grant_role_statement
        | revoke_role_statement
        | list_roles_statement
        | grant_permission_statement
        | revoke_permission_statement
        | list_permissions_statement
        | create_user_statement
        | alter_user_statement
        | drop_user_statement
        | list_users_statement
udf_statement::= create_function_statement
        | drop_function_statement
        | create_aggregate_statement
        | drop_aggregate_statement
udt_statement::= create_type_statement
        | alter_type_statement
        | drop_type_statement
trigger_statement::= create_trigger_statement
        | drop_trigger_statementPrepared StatementsCQL supportsprepared statements. Prepared statements are an
optimization that allows to parse a query only once but execute it
multiple times with different concrete values.Any statement that uses at least one bind marker (seebind_marker)
will need to beprepared. After which the statement can beexecutedby provided concrete values for each of its marker. The exact details of
how a statement is prepared and then executed depends on the CQL driver
used and you should refer to your driver documentation.Get started with Cassandra, fast.Quickstart GuideApache Cassandrapowers mission-critical deployments with improved performance and unparalleled levels of scale in the cloud.HomeCassandra BasicsQuickstartEcosystemDocumentationCommunityCase StudiesResourcesBlogFoundationEventsLicenseThanksSecurityPrivacySponsorshipÂ© 2009-The Apache Software Foundationunder the terms of the Apache License 2.0.  Apache, the Apache feather logo, Apache Cassandra, Cassandra, and the Cassandra logo, are either registered trademarks or trademarks of The Apache Software Foundation.