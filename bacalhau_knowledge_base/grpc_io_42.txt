URL: https://grpc.io/docs/languages/go/basics/

gRPCAboutMeetDocsGuidesShowcaseBlogCommunitygRPConf 2024 is happening NEXT WEEK onAug. 27th!-Register nowand get 25% off with the code GOOGLE25.DocsWhat is gRPC?IntroductionCore conceptsFAQLanguagesC# / .NETAPI (legacy)Daily builds (legacy)C++Quick startBasics tutorialAsync-API tutorialAsynchronous Callback API TutorialBest Practices for gRPC C++ API and FAQALTSAPIDartQuick startBasics tutorialAPIGoQuick startBasics tutorialALTSAPIGenerated codeJavaQuick startBasics tutorialALTSAPIGenerated codeKotlinQuick startBasics tutorialAPINodeQuick startBasics tutorialAPIObjective-CQuick startBasics tutorialOAuth2APIPHPQuick startBasics tutorialAPIDaily buildsPythonQuick startBasics tutorialALTSGenerated codeAPIDaily buildsRubyQuick startBasics tutorialAPIDaily buildsPlatformsAndroidJavaQuick startBasics tutorialAPIKotlinQuick startAPIWebQuick startBasics tutorialGuidesAuthenticationBenchmarkingCancellationCompressionCustom Backend MetricsCustom Load Balancing PoliciesCustom Name ResolutionDeadlinesDebuggingError handlingFlow ControlHealth CheckingInterceptorsKeepaliveMetadataOpenTelemetry MetricsPerformance Best PracticesReflectionRequest HedgingRetryService ConfigStatus CodesWait-for-ReadyView page sourceEdit this pageCreate child pageCreate documentation issueCreate project issueWhy use gRPC?SetupGet the example codeDefining the serviceGenerating client and server codeCreating the serverImplementing RouteGuideSimple RPCServer-side streaming RPCClient-side streaming RPCBidirectional streaming RPCStarting the serverCreating the clientCreating a stubCalling service methodsSimple RPCServer-side streaming RPCClient-side streaming RPCBidirectional streaming RPCTry it out!DocsLanguagesGoBasics tutorialBasics tutorialA basic tutorial introduction to gRPC in Go.ContentsWhy use gRPC?SetupGet the example codeDefining the serviceGenerating client and server codeCreating the serverImplementing RouteGuideSimple RPCServer-side streaming RPCClient-side streaming RPCBidirectional streaming RPCStarting the serverCreating the clientCreating a stubCalling service methodsSimple RPCServer-side streaming RPCClient-side streaming RPCBidirectional streaming RPCTry it out!Basics tutorialA basic tutorial introduction to gRPC in Go.This tutorial provides a basic Go programmer’s introduction to
working with gRPC.By walking through this example you’ll learn how to:Define a service in a.protofile.Generate server and client code using the protocol buffer compiler.Use the Go gRPC API to write a simple client and server for your service.It assumes that you have read theIntroduction to gRPCand are familiar withprotocol buffers.
Note that the example in this tutorial uses the proto3 version of the protocol
buffers language: you can find out more in theproto3 language
guideand theGo generated code
guide.Why use gRPC?Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.With gRPC we can define our service once in a.protofile and generate clients
and servers in any of gRPC’s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.SetupYou should have already installed the tools needed to generate client and server
interface code – if you haven’t, see thePrerequisitessection ofQuick
startfor setup instructions.Get the example codeThe example code is part of thegrpc-gorepo.Download the repo as a zip fileand unzip it, or clone
the repo:$ git clone -b v1.66.0 --depth1https://github.com/grpc/grpc-goChange to the example directory:$cdgrpc-go/examples/route_guideDefining the serviceOur first step (as you’ll know from theIntroduction to gRPC) is to
define the gRPCserviceand the methodrequestandresponsetypes usingprotocol buffers.
For the complete.protofile, seerouteguide/route_guide.proto.To define a service, you specify a namedservicein your.protofile:serviceRouteGuide {...}Then you definerpcmethods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in theRouteGuideservice:Asimple RPCwhere the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.// Obtains the feature at a given position.rpcGetFeature(Point)returns(Feature) {}Aserver-side streaming RPCwhere the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing thestreamkeyword before theresponsetype.// Obtains the Features available within the given Rectangle.  Results are// streamed rather than returned at once (e.g. in a response message with a// repeated field), as the rectangle may cover a large area and contain a// huge number of features.rpcListFeatures(Rectangle)returns(stream Feature) {}Aclient-side streaming RPCwhere the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
thestreamkeyword before therequesttype.// Accepts a stream of Points on a route being traversed, returning a// RouteSummary when traversal is completed.rpcRecordRoute(stream Point)returns(RouteSummary) {}Abidirectional streaming RPCwhere both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing thestreamkeyword before both the request and the response.// Accepts a stream of RouteNotes sent while a route is being traversed,// while receiving other RouteNotes (e.g. from other users).rpcRouteChat(stream RouteNote)returns(stream RouteNote) {}Our.protofile also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here’s
thePointmessage type:// Points are represented as latitude-longitude pairs in the E7 representation// (degrees multiplied by 10**7 and rounded to the nearest integer).// Latitudes should be in the range +/- 90 degrees and longitude should be in// the range +/- 180 degrees (inclusive).messagePoint{int32latitude=1;int32longitude=2;}Generating client and server codeNext we need to generate the gRPC client and server interfaces from our.protoservice definition. We do this using the protocol buffer compilerprotocwith
a special gRPC Go plugin. This is similar to what we did in theQuick start.From theexamples/route_guidedirectory, run the following command:$ protoc --go_out=. --go_opt=paths=source_relative\--go-grpc_out=. --go-grpc_opt=paths=source_relative\routeguide/route_guide.protoRunning this command generates the following files in therouteguidedirectory:route_guide.pb.go, which contains all the protocol buffer code to
populate, serialize, and retrieve request and response message types.route_guide_grpc.pb.go, which contains the following:An interface type (orstub) for clients to call with the methods defined in
theRouteGuideservice.An interface type for servers to implement, also with the methods defined in
theRouteGuideservice.Creating the serverFirst let’s look at how we create aRouteGuideserver. If you’re only
interested in creating gRPC clients, you can skip this section and go straight
toCreating the client(though you might find it interesting
anyway!).There are two parts to making ourRouteGuideservice do its job:Implementing the service interface generated from our service definition:
doing the actual “work” of our service.Running a gRPC server to listen for requests from clients and dispatch them to
the right service implementation.You can find our exampleRouteGuideserver inserver/server.go.
Let’s take a closer look at how it works.Implementing RouteGuideAs you can see, our server has arouteGuideServerstruct type that implements
the generatedRouteGuideServerinterface:typerouteGuideServerstruct{...}...func(s*routeGuideServer)GetFeature(ctx context.Context, point*pb.Point) (*pb.Feature,error) {...}...func(s*routeGuideServer)ListFeatures(rect*pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer)error{...}...func(s*routeGuideServer)RecordRoute(stream pb.RouteGuide_RecordRouteServer)error{...}...func(s*routeGuideServer)RouteChat(stream pb.RouteGuide_RouteChatServer)error{...}...Simple RPCTherouteGuideServerimplements all our service methods. Let’s look at the
simplest type first,GetFeature, which just gets aPointfrom the client and
returns the corresponding feature information from its database in aFeature.func(s*routeGuideServer)GetFeature(ctx context.Context, point*pb.Point) (*pb.Feature,error) {for_, feature:=ranges.savedFeatures {ifproto.Equal(feature.Location, point) {returnfeature,nil}}// No feature was found, return an unnamed featurereturn&pb.Feature{Location: point},nil}The method is passed a context object for the RPC and the client’sPointprotocol buffer request. It returns aFeatureprotocol buffer object with the
response information and anerror. In the method we populate theFeaturewith the appropriate information, and thenreturnit along with anilerror
to tell gRPC that we’ve finished dealing with the RPC and that theFeaturecan
be returned to the client.Server-side streaming RPCNow let’s look at one of our streaming RPCs.ListFeaturesis a server-side
streaming RPC, so we need to send back multipleFeatures to our client.func(s*routeGuideServer)ListFeatures(rect*pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer)error{for_, feature:=ranges.savedFeatures {ifinRange(feature.Location, rect) {iferr:=stream.Send(feature); err!=nil{returnerr}}}returnnil}As you can see, instead of getting simple request and response objects in our
method parameters, this time we get a request object (theRectanglein which
our client wants to findFeatures) and a specialRouteGuide_ListFeaturesServerobject to write our responses.In the method, we populate as manyFeatureobjects as we need to return,
writing them to theRouteGuide_ListFeaturesServerusing itsSend()method.
Finally, as in our simple RPC, we return anilerror to tell gRPC that we’ve
finished writing responses. Should any error happen in this call, we return a
non-nilerror; the gRPC layer will translate it into an appropriate RPC status
to be sent on the wire.Client-side streaming RPCNow let’s look at something a little more complicated: the client-side streaming
methodRecordRoute, where we get a stream ofPoints from the client and
return a singleRouteSummarywith information about their trip. As you can
see, this time the method doesn’t have a request parameter at all. Instead, it
gets aRouteGuide_RecordRouteServerstream, which the server can use to both
readandwrite messages - it can receive client messages using itsRecv()method and return its single response using itsSendAndClose()method.func(s*routeGuideServer)RecordRoute(stream pb.RouteGuide_RecordRouteServer)error{varpointCount, featureCount, distanceint32varlastPoint*pb.PointstartTime:=time.Now()for{point, err:=stream.Recv()iferr==io.EOF {endTime:=time.Now()returnstream.SendAndClose(&pb.RouteSummary{PointCount:   pointCount,FeatureCount: featureCount,Distance:     distance,ElapsedTime:int32(endTime.Sub(startTime).Seconds()),})}iferr!=nil{returnerr}pointCount++for_, feature:=ranges.savedFeatures {ifproto.Equal(feature.Location, point) {featureCount++}}iflastPoint!=nil{distance+=calcDistance(lastPoint, point)}lastPoint = point}}In the method body we use theRouteGuide_RecordRouteServer’sRecv()method
to repeatedly read in our client’s requests to a request object (in this case aPoint) until there are no more messages: the server needs to check the error
returned fromRecv()after each call. If this isnil, the stream is still
good and it can continue reading; if it’sio.EOFthe message stream has ended
and the server can return itsRouteSummary. If it has any other value, we
return the error “as is” so that it’ll be translated to an RPC status by the
gRPC layer.Bidirectional streaming RPCFinally, let’s look at our bidirectional streaming RPCRouteChat().func(s*routeGuideServer)RouteChat(stream pb.RouteGuide_RouteChatServer)error{for{in, err:=stream.Recv()iferr==io.EOF {returnnil}iferr!=nil{returnerr}key:=serialize(in.Location)...// look for notes to be sent to clientfor_, note:=ranges.routeNotes[key] {iferr:=stream.Send(note); err!=nil{returnerr}}}}This time we get aRouteGuide_RouteChatServerstream that, as in our
client-side streaming example, can be used to read and write messages. However,
this time we return values via our method’s stream while the client is still
writing messages totheirmessage stream.The syntax for reading and writing here is very similar to our client-streaming
method, except the server uses the stream’sSend()method rather thanSendAndClose()because it’s writing multiple responses. Although each side
will always get the other’s messages in the order they were written, both the
client and server can read and write in any order — the streams operate
completely independently.Starting the serverOnce we’ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for ourRouteGuideservice:lis, err:=net.Listen("tcp", fmt.Sprintf("localhost:%d", port))iferr!=nil{log.Fatalf("failed to listen: %v", err)}varopts []grpc.ServerOption...grpcServer:=grpc.NewServer(opts...)pb.RegisterRouteGuideServer(grpcServer,newServer())grpcServer.Serve(lis)To build and start a server, we:Specify the port we want to use to listen for client requests using:lis, err := net.Listen(...).Create an instance of the gRPC server usinggrpc.NewServer(...).Register our service implementation with the gRPC server.CallServe()on the server with our port details to do a blocking wait
until the process is killed orStop()is called.Creating the clientIn this section, we’ll look at creating a Go client for ourRouteGuideservice. You can see our complete example client code ingrpc-go/examples/route_guide/client/client.go.Creating a stubTo call service methods, we first need to create a gRPCchannelto communicate
with the server. We create this by passing the server address and port number togrpc.NewClient()as follows:varopts []grpc.DialOption...conn, err:=grpc.NewClient(*serverAddr, opts...)iferr!=nil{...}deferconn.Close()You can useDialOptionsto set the auth credentials (for example, TLS, GCE
credentials, or JWT credentials) ingrpc.NewClientwhen a service requires
them. TheRouteGuideservice doesn’t require any credentials.Once the gRPCchannelis setup, we need a clientstubto perform RPCs. We
get it using theNewRouteGuideClientmethod provided by thepbpackage
generated from the example.protofile.client:=pb.NewRouteGuideClient(conn)Calling service methodsNow let’s look at how we call our service methods. Note that in gRPC-Go, RPCs
operate in a blocking/synchronous mode, which means that the RPC call waits for
the server to respond, and will either return a response or an error.Simple RPCCalling the simple RPCGetFeatureis nearly as straightforward as calling a
local method.feature, err:=client.GetFeature(context.Background(),&pb.Point{409146138,-746188906})iferr!=nil{...}As you can see, we call the method on the stub we got earlier. In our method
parameters we create and populate a request protocol buffer object (in our casePoint). We also pass acontext.Contextobject which lets us change our RPC’s
behavior if necessary, such as time-out/cancel an RPC in flight. If the call
doesn’t return an error, then we can read the response information from the
server from the first return value.log.Println(feature)Server-side streaming RPCHere’s where we call the server-side streaming methodListFeatures, which
returns a stream of geographicalFeatures. If you’ve already readCreating
the serversome of this may look very familiar - streaming RPCs are
implemented in a similar way on both sides.rect:=&pb.Rectangle{...}// initialize a pb.Rectanglestream, err:=client.ListFeatures(context.Background(), rect)iferr!=nil{...}for{feature, err:=stream.Recv()iferr==io.EOF {break}iferr!=nil{log.Fatalf("%v.ListFeatures(_) = _, %v", client, err)}log.Println(feature)}As in the simple RPC, we pass the method a context and a request. However,
instead of getting a response object back, we get back an instance ofRouteGuide_ListFeaturesClient. The client can use theRouteGuide_ListFeaturesClientstream to read the server’s responses.We use theRouteGuide_ListFeaturesClient’sRecv()method to repeatedly read
in the server’s responses to a response protocol buffer object (in this case aFeature) until there are no more messages: the client needs to check the errorerrreturned fromRecv()after each call. Ifnil, the stream is still good
and it can continue reading; if it’sio.EOFthen the message stream has ended;
otherwise there must be an RPC error, which is passed over througherr.Client-side streaming RPCThe client-side streaming methodRecordRouteis similar to the server-side
method, except that we only pass the method a context and get aRouteGuide_RecordRouteClientstream back, which we can use to both writeandread messages.// Create a random number of random pointsr:=rand.New(rand.NewSource(time.Now().UnixNano()))pointCount:=int(r.Int31n(100))+2// Traverse at least two pointsvarpoints []*pb.Pointfori:=0; i < pointCount; i++{points =append(points,randomPoint(r))}log.Printf("Traversing %d points.",len(points))stream, err:=client.RecordRoute(context.Background())iferr!=nil{log.Fatalf("%v.RecordRoute(_) = _, %v", client, err)}for_, point:=rangepoints {iferr:=stream.Send(point); err!=nil{log.Fatalf("%v.Send(%v) = %v", stream, point, err)}}reply, err:=stream.CloseAndRecv()iferr!=nil{log.Fatalf("%v.CloseAndRecv() got error %v, want %v", stream, err,nil)}log.Printf("Route summary: %v", reply)TheRouteGuide_RecordRouteClienthas aSend()method that we can use to send
requests to the server. Once we’ve finished writing our client’s requests to the
stream usingSend(), we need to callCloseAndRecv()on the stream to let
gRPC know that we’ve finished writing and are expecting to receive a response.
We get our RPC status from theerrreturned fromCloseAndRecv(). If the
status isnil, then the first return value fromCloseAndRecv()will be a
valid server response.Bidirectional streaming RPCFinally, let’s look at our bidirectional streaming RPCRouteChat(). As in the
case ofRecordRoute, we only pass the method a context object and get back a
stream that we can use to both write and read messages. However, this time we
return values via our method’s stream while the server is still writing messages
totheirmessage stream.stream, err:=client.RouteChat(context.Background())waitc:=make(chanstruct{})gofunc() {for{in, err:=stream.Recv()iferr==io.EOF {// read done.close(waitc)return}iferr!=nil{log.Fatalf("Failed to receive a note : %v", err)}log.Printf("Got message %s at point(%d, %d)", in.Message, in.Location.Latitude, in.Location.Longitude)}}()for_, note:=rangenotes {iferr:=stream.Send(note); err!=nil{log.Fatalf("Failed to send a note: %v", err)}}stream.CloseSend()<-waitcThe syntax for reading and writing here is very similar to our client-side
streaming method, except we use the stream’sCloseSend()method once we’ve
finished our call. Although each side will always get the other’s messages in
the order they were written, both the client and server can read and write in
any order — the streams operate completely independently.Try it out!Execute the following commands from theexamples/route_guidedirectory:Run the server:$ go run server/server.goFrom another terminal, run the client:$ go run client/client.goYou’ll see output like this:Getting feature for point (409146138, -746188906)
name:"Berkshire Valley Management Area Trail, Jefferson, NJ, USA" location:<latitude:409146138 longitude:-746188906 >
Getting feature for point (0, 0)
location:<>
Looking for features within lo:<latitude:400000000 longitude:-750000000 > hi:<latitude:420000000 longitude:-730000000 >
name:"Patriots Path, Mendham, NJ 07945, USA" location:<latitude:407838351 longitude:-746143763 >
...
name:"3 Hasta Way, Newton, NJ 07860, USA" location:<latitude:410248224 longitude:-747127767 >
Traversing 56 points.
Route summary: point_count:56 distance:497013163
Got message First message at point(0, 1)
Got message Second message at point(0, 2)
Got message Third message at point(0, 3)
Got message First message at point(0, 1)
Got message Fourth message at point(0, 1)
Got message Second message at point(0, 2)
Got message Fifth message at point(0, 2)
Got message Third message at point(0, 3)
Got message Sixth message at point(0, 3)NoteWe’ve omitted timestamps from the client and server trace output shown in this
page.Last modified May 21, 2024:Update Go documentation to use NewClient instead of Dial (#1295) (708f7a1)View page sourceEdit this pageCreate child pageCreate documentation issueCreate project issue© 2024 gRPC AuthorsTerms|Privacy|Trademarks|License|About