URL: https://etcd.io/docs/v3.6/op-guide/security/

etcdDocsBlogCommunityInstallPlayVersionsv3.6v3.5v3.4v3.3v3.2v3.1v2.3Versionsv3.6-DRAFTQuickstartDemoTutorialsHow to Set Up a Demo etcd ClusterReading from etcdWriting to etcdHow to get keys by prefixHow to delete keysHow to make multiple writes in a transactionHow to watch keysHow to create leaseHow to create locksHow to conduct leader election in etcd clusterHow to check Cluster statusHow to save the databaseHow to migrate etcd from v2 to v3How to Add and Remove MembersInstallFAQLibraries and toolsMetricsReporting bugsTuningDiscovery service protocolLogging conventionsGolang modulesLearningData modeletcd client designetcd learner designetcd v3 authentication designetcd APIetcd persistent storage filesetcd API guaranteesetcd versus other key-value storesGlossaryDeveloper guideDiscovery service protocolSet up a local clusterInteracting with etcdWhy gRPC gatewaygRPC naming and discoverySystem limitsetcd featuresAPI referenceAPI reference: concurrencyOperations guideAuthentication GuidesRole-based access controlAuthenticationConfiguration optionsTransport security modelClustering GuideRun etcd clusters as a Kubernetes StatefulSetRun etcd clusters inside containersFailure modesDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMonitoring etcdPerformanceDesign of runtime reconfigurationRuntime reconfigurationSupported platformsVersioningData CorruptionBenchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkBenchmarking etcd v3Benchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0Benchmarking etcd v2.1.0UpgradingUpgrading etcd clusters and applicationsUpgrade etcd from 3.4 to 3.5Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.0 to 3.1Upgrade etcd from 2.3 to 3.0TriageIssue triage guidelinesPR managementv3.5QuickstartDemoTutorialsHow to Set Up a Demo etcd ClusterReading from etcdWriting to etcdHow to get keys by prefixHow to delete keysHow to make multiple writes in a transactionHow to watch keysHow to create leaseHow to create locksHow to conduct leader election in etcd clusterHow to check Cluster statusHow to save the databaseHow to migrate etcd from v2 to v3How to Add and Remove MembersInstallFAQLibraries and toolsMetricsReporting bugsTuningDiscovery service protocolLogging conventionsGolang modulesLearningData modeletcd client designetcd learner designetcd v3 authentication designetcd APIetcd persistent storage filesetcd API guaranteesetcd versus other key-value storesGlossaryDeveloper guideDiscovery service protocolSet up a local clusterInteracting with etcdWhy gRPC gatewaygRPC naming and discoverySystem limitsetcd featuresAPI referenceAPI reference: concurrencyOperations guideAuthentication GuidesRole-based access controlAuthenticationConfiguration optionsTransport security modelClustering GuideRun etcd clusters as a Kubernetes StatefulSetRun etcd clusters inside containersFailure modesDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMonitoring etcdPerformanceDesign of runtime reconfigurationRuntime reconfigurationSupported platformsVersioningData CorruptionBenchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkBenchmarking etcd v3Benchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0Benchmarking etcd v2.1.0DowngradingDowngrading etcd clusters and applicationsDowngrade etcd from 3.5 to 3.4UpgradingUpgrading etcd clusters and applicationsUpgrade etcd from 3.4 to 3.5Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.0 to 3.1Upgrade etcd from 2.3 to 3.0TriageIssue triage guidelinesPR managementv3.4QuickstartOverviewDemoInstallFAQLibraries and toolsMetricsReporting bugsTuningDiscovery service protocolLogging conventionsLearningData modeletcd client designetcd learner designetcd v3 authentication designetcd3 APIetcd API guaranteesetcd versus other key-value storesGlossaryDeveloper guideDiscovery service protocolSet up a local clusterInteracting with etcdWhy gRPC gatewaygRPC naming and discoverySystem limitsetcd featuresAPI referenceAPI reference: concurrencyOperations guideConfiguration optionsRole-based access controlTransport security modelClustering GuideRun etcd clusters inside containersFailure modesDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenancePerformanceDesign of runtime reconfigurationRuntime reconfigurationSupported platformsMigrate applications from using API v2 to API v3VersioningData CorruptionMonitoring etcdBenchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkBenchmarking etcd v3Benchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0Benchmarking etcd v2.1.0UpgradingUpgrading etcd clusters and applicationsUpgrade etcd from 3.4 to 3.5Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.0 to 3.1Upgrade etcd from 2.3 to 3.0PlatformsAmazon Web ServicesContainer Linux with systemdFreeBSDTriageIssue Triage Guidelinesv3.3InstallLibraries and toolsMetricsBenchmarksBenchmarking etcd v2.1.0Benchmarking etcd v2.2.0Benchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v3Storage Memory Usage BenchmarkWatch Memory Usage BenchmarkDemoDeveloper guideDiscovery service protocoletcd API Referenceetcd concurrency API ReferenceExperimental APIs and featuresgRPC naming and discoveryInteracting with etcdSet up a local clusterSystem limitsWhy gRPC gatewayDiscovery service protocoletcd v3 APIFrequently Asked Questions (FAQ)Learningetcd client architectureClient feature matrixData modeletcd v3 authentication designetcd versus other key-value storesetcd3 APIGlossaryKV API guaranteesLearnerLogging conventionsOperations guideMonitoring etcdVersioningClustering GuideConfiguration flagsDesign of runtime reconfigurationDisaster recoveryetcd gatewayFailure modesgRPC proxyHardware recommendationsMaintenanceMigrate applications from using API v2 to API v3PerformanceRole-based access controlRun etcd clusters inside containersRuntime reconfigurationSupported systemsTransport security modelPlatformsAmazon Web ServicesContainer Linux with systemdFreeBSDProduction usersReporting bugsTuningUpgradingUpgrade etcd from 2.3 to 3.0Upgrade etcd from 3.0 to 3.1Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.4 to 3.5Upgrading etcd clusters and applicationsv3.2BenchmarksBenchmarking etcd v2.1.0Benchmarking etcd v2.2.0Benchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v3-demoStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkData modelDemoDeveloper guideDiscovery service protocoletcd API referenceetcd concurrency API ReferenceExperimental APIs and featuresgRPC gatewaygRPC naming and discoveryInteracting with etcdSet up a local clusterSystem limitsetcd dev internalDiscovery service protocolLogging conventionsetcd operations guideAuthentication GuideClustering GuideConfiguration flagsDesign of runtime reconfigurationDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMigrate applications from using API v2 to API v3Monitoring etcdPerformanceRun etcd clusters inside containersRuntime reconfigurationSecurity modelSupported platformsUnderstand failuresVersioningetcd upgradesUpgrade etcd from 2.3 to 3.0Upgrade etcd from 3.0 to 3.1Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.3 to 3.4Upgrading etcd clusters and applicationsetcd v3 authentication designetcd versus other key-value storesetcd3 APIFrequently Asked Questions (FAQ)GlossaryInstallKV API guaranteesLibraries and toolsMetricsPlatformsAmazon Web ServicesFreeBSDRun etcd on Container Linux with systemdProduction usersReporting bugsRFCetcd v3 APITuningv3.1Data modelDemoetcd benchmarksetcd v2.1.0-alpha benchmarksetcd v2.2.0 benchmarksetcd v2.2.0-rc benchmarksetcd v2.2.0-rc-memory benchmarksetcd v3-demo benchmarksStorage Memory Usage BenchmarkWatch Memory Usage Benchmarketcd developer guideDiscovery service protocoletcd API ReferenceExperimental APIs and featuresgRPC GatewaygRPC naming and discoveryInteracting with etcdSetup a local clusterSystem limitsetcd internal devDiscovery service protocolLogging conventionsetcd operations guideClustering GuideConfiguration flagsDesign of runtime reconfigurationDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMigrate applications from using API v2 to API v3Monitoring etcdPerformanceRun etcd clusters inside containersRuntime reconfigurationSecurity modelSupported platformsUnderstand failuresVersioningetcd3 APIFrequently Asked Questions (FAQ)GlossaryInstallKV API guaranteesLibraries and toolsMetricsPlatformsFreeBSDProduction usersReporting bugsRFCetcd v3 APITuningUpgrading etcd clusters and applicationsUpgrade etcd from 2.3 to 3.0Upgrade etcd from 3.0 to 3.1Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.3 to 3.4Why etcdv2.3AdministrationAuthentication GuideBackward CompatibilityBenchmarksBenchmarking etcd v2.2.0etcd 2.1.0-alpha benchmarksetcd 2.2.0-rc benchmarksetcd 2.2.0-rc memory benchmarksetcd 3 demo benchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkClustering GuideConfiguration FlagsDesign of Runtime ReconfigurationDevelopmentDiscovery Service ProtocolError Codeetcd APIetcd v3 APIFAQGlossaryLibraries and ToolsMembers APIMetricsMiscellaneous APIsPlatformsFreeBSProduction UsersProxyReporting BugsRunning etcd under DockerRuntime ReconfigurationSecurity ModelSnapshot MigrationTuningUpgrade etcd from 2.1 to 2.2Upgrade etcd from 2.1 to 2.2Upgrade etcd from 2.2 to 2.3v2 Auth and SecurityVersioningView page sourceEdit this pageCreate child pageCreate documentation issueCreate project issueBasic setupExample 1: Client-to-server transport security with HTTPSExample 2: Client-to-server authentication with HTTPS client certificatesExample 3: Transport security & client certificates in a clusterExample 4: Automatic self-signed transport securityNotes for DNS SRVNotes for etcd proxyNotes for TLS authenticationNotes for Host WhitelistFrequently asked questionsI’m seeing a SSLv3 alert handshake failure when using TLS client authentication?With peer certificate authentication I receive “certificate is valid for 127.0.0.1, not $MY_IP”Does etcd encrypt data stored on disk drives?I’m seeing a log warning that “directory X exist without recommended permission -rwx——”Versionsv3.6-DRAFTOperations guideTransport security modelTransport security modelSecuring data in transitetcd supports automatic TLS as well as authentication through client certificates for both clients to server as well as peer (server to server / cluster) communication.Note that etcd doesn’t enableRBAC based authenticationor the authentication feature in the transport layer by default to reduce friction for users getting started with the database. Further, changing this default would be a breaking change for the project which was established since 2013. An etcd cluster which doesn’t enable security features can expose its data to any clients.To get up and running, first have a CA certificate and a signed key pair for one member. It is recommended to create and sign a new key pair for every member in a cluster.For convenience, thecfssltool provides an easy interface to certificate generation, and we provide an example using the toolhere. Alternatively, try thisguide to generating self-signed key pairs.The list of flags provided below may not be up-to-date due to ongoing development changes. For the latest available flags, runetcd --helpor refer to theetcd help.Basic setupetcd takes several certificate related configuration options, either through command-line flags or environment variables:Client-to-server communication:--cert-file=<path>: Certificate used for SSL/TLS connectionstoetcd. When this option is set, advertise-client-urls can use the HTTPS schema.--key-file=<path>: Key for the certificate. Must be unencrypted.--client-cert-auth: When this is set etcd will check all incoming HTTPS requests for a client certificate signed by the trusted CA, requests that don’t supply a valid client certificate will fail. Ifauthenticationis enabled, the certificate provides credentials for the user name given by the Common Name field.--trusted-ca-file=<path>: Trusted certificate authority.--auto-tls: Use automatically generated self-signed certificates for TLS connections with clients.Peer (server-to-server / cluster) communication:The peer options work the same way as the client-to-server options:--peer-cert-file=<path>: Certificate used for SSL/TLS connections between peers. This will be used both for listening on the peer address as well as sending requests to other peers.--peer-key-file=<path>: Key for the certificate. Must be unencrypted.--peer-client-cert-auth: When set, etcd will check all incoming peer requests from the cluster for valid client certificates signed by the supplied CA.--peer-trusted-ca-file=<path>: Trusted certificate authority.--peer-auto-tls: Use automatically generated self-signed certificates for TLS connections between peers.If either a client-to-server or peer certificate is supplied the key must also be set. All of these configuration options are also available through the environment variables,ETCD_CA_FILE,ETCD_PEER_CA_FILEand so on.Common options:--cipher-suites: Comma-separated list of supported TLS cipher suites between server/client and peers (empty will be auto-populated by Go).--tls-min-version=<version>Sets the minimum TLS version supported by etcd.--tls-max-version=<version>Sets the maximum TLS version supported by etcd. If not set the maximum version supported by Go will be used.Example 1: Client-to-server transport security with HTTPSFor this, have a CA certificate (ca.crt) and signed key pair (server.crt,server.key) ready.Let us configure etcd to provide simple HTTPS transport security step by step:$ etcd --name infra0 --data-dir infra0\--cert-file=/path/to/server.crt --key-file=/path/to/server.key\--advertise-client-urls=https://127.0.0.1:2379 --listen-client-urls=https://127.0.0.1:2379This should start up fine and it will be possible to test the configuration by speaking HTTPS to etcd:$ curl --cacert /path/to/ca.crt https://127.0.0.1:2379/v2/keys/foo -XPUT -dvalue=bar -vThe command should show that the handshake succeed. Since we use self-signed certificates with our own certificate authority, the CA must be passed to curl using the--cacertoption. Another possibility would be to add the CA certificate to the system’s trusted certificates directory (usually in/etc/pki/tls/certsor/etc/ssl/certs).OSX 10.9+ Users: curl 7.30.0 on OSX 10.9+ doesn’t understand certificates passed in on the command line.
Instead, import the dummy ca.crt directly into the keychain or add the-kflag to curl to ignore errors.
To test without the-kflag, runopen ./tests/fixtures/ca/ca.crtand follow the prompts.
Please remove this certificate after testing!
If there is a workaround, let us know.Example 2: Client-to-server authentication with HTTPS client certificatesFor now we’ve given the etcd client the ability to verify the server identity and provide transport security. We can however also use client certificates to prevent unauthorized access to etcd.The clients will provide their certificates to the server and the server will check whether the cert is signed by the supplied CA and decide whether to serve the request.The same files mentioned in the first example are needed for this, as well as a key pair for the client (client.crt,client.key) signed by the same certificate authority.$ etcd --name infra0 --data-dir infra0\--client-cert-auth --trusted-ca-file=/path/to/ca.crt --cert-file=/path/to/server.crt --key-file=/path/to/server.key\--advertise-client-urls https://127.0.0.1:2379 --listen-client-urls https://127.0.0.1:2379Now try the same request as above to this server:$ curl --cacert /path/to/ca.crt https://127.0.0.1:2379/v2/keys/foo -XPUT -dvalue=bar -vThe request should be rejected by the server:...
routines:SSL3_READ_BYTES:sslv3 alert bad certificate
...To make it succeed, we need to give the CA signed client certificate to the server:$ curl --cacert /path/to/ca.crt --cert /path/to/client.crt --key /path/to/client.key\-L https://127.0.0.1:2379/v2/keys/foo -XPUT -dvalue=bar -vThe output should include:...
SSLv3, TLS handshake, CERT verify (15):
...
TLS handshake, Finished (20)And also the response from the server:{"action":"set","node":{"createdIndex":12,"key":"/foo","modifiedIndex":12,"value":"bar"}}Specify cipher suites to blockweak TLS cipher suites.TLS handshake would fail when client hello is requested with invalid cipher suites.For instance:$ etcd\--cert-file ./server.crt\--key-file ./server.key\--trusted-ca-file ./ca.crt\--cipher-suites TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384Then, client requests must specify one of the cipher suites specified in the server:# valid cipher suite$ curl\--cacert /path/to/ca.crt\--cert /path/to/client.crt\--key /path/to/client.key\-L[CLIENT-URL]/metrics\--ciphers ECDHE-RSA-AES128-GCM-SHA256# request succeedsetcd_server_version{server_version="3.2.22"}1...# invalid cipher suite$ curl\--cacert /path/to/ca.crt\--cert /path/to/client.crt\--key /path/to/client.key\-L[CLIENT-URL]/metrics\--ciphers ECDHE-RSA-DES-CBC3-SHA# request fails with(35)error:14094410:SSL routines:ssl3_read_bytes:sslv3 alert handshake failureExample 3: Transport security & client certificates in a clusteretcd supports the same model as above forpeer communication, that means the communication between etcd members in a cluster.Assuming we have ourca.crtand two members with their own key pairs (member1.crt&member1.key,member2.crt&member2.key) signed by this CA, we launch etcd as follows:DISCOVERY_URL=...# from https://discovery.etcd.io/new# member1$ etcd --name infra1 --data-dir infra1\--peer-client-cert-auth --peer-trusted-ca-file=/path/to/ca.crt --peer-cert-file=/path/to/member1.crt --peer-key-file=/path/to/member1.key\--initial-advertise-peer-urls=https://10.0.1.10:2380 --listen-peer-urls=https://10.0.1.10:2380\--discovery${DISCOVERY_URL}# member2$ etcd --name infra2 --data-dir infra2\--peer-client-cert-auth --peer-trusted-ca-file=/path/to/ca.crt --peer-cert-file=/path/to/member2.crt --peer-key-file=/path/to/member2.key\--initial-advertise-peer-urls=https://10.0.1.11:2380 --listen-peer-urls=https://10.0.1.11:2380\--discovery${DISCOVERY_URL}The etcd members will form a cluster and all communication between members in the cluster will be encrypted and authenticated using the client certificates. The output of etcd will show that the addresses it connects to use HTTPS.Example 4: Automatic self-signed transport securityNOTE:When you specify ClientAutoTLS and PeerAutoTLS, the validity period of the client certificate and peer certificate automatically generated by etcd is only 1 year. You can specify the --self-signed-cert-validity flag to set the validity period of the certificate in years.For cases where communication encryption, but not authentication, is needed, etcd supports encrypting its messages with automatically generated self-signed certificates. This simplifies deployment because there is no need for managing certificates and keys outside of etcd.
Configure etcd to use self-signed certificates for client and peer connections with the flags--auto-tlsand--peer-auto-tls:DISCOVERY_URL=...# from https://discovery.etcd.io/new# member1$ etcd --name infra1 --data-dir infra1\--auto-tls --peer-auto-tls\--initial-advertise-peer-urls=https://10.0.1.10:2380 --listen-peer-urls=https://10.0.1.10:2380\--discovery${DISCOVERY_URL}# member2$ etcd --name infra2 --data-dir infra2\--auto-tls --peer-auto-tls\--initial-advertise-peer-urls=https://10.0.1.11:2380 --listen-peer-urls=https://10.0.1.11:2380\--discovery${DISCOVERY_URL}Self-signed certificates do not authenticate identity so curl will return an error:curl:(60)SSL certificate problem: Invalid certificate chainTo disable certificate chain checking, invoke curl with the-kflag:$ curl -k https://127.0.0.1:2379/v2/keys/foo -Xput -dvalue=bar -vNotes for DNS SRVSince v3.1.0 (except v3.2.9), discovery SRV bootstrapping authenticatesServerNamewith a root domain name from--discovery-srvflag. This is to avoid man-in-the-middle cert attacks, by requiring a certificate to have matching root domain name in its Subject Alternative Name (SAN) field. For instance,etcd --discovery-srv=etcd.localwill only authenticate peers/clients when the provided certs have root domainetcd.localas an entry in Subject Alternative Name (SAN) fieldNotes for etcd proxyetcd proxy terminates the TLS from its client if the connection is secure, and uses proxy’s own key/cert specified in--peer-key-fileand--peer-cert-fileto communicate with etcd members.The proxy communicates with etcd members through both the--advertise-client-urlsand--advertise-peer-urlsof a given member. It forwards client requests to etcd members’ advertised client urls, and it syncs the initial cluster configuration through etcd members’ advertised peer urls.When client authentication is enabled for an etcd member, the administrator must ensure that the peer certificate specified in the proxy’s--peer-cert-fileoption is valid for that authentication. The proxy’s peer certificate must also be valid for peer authentication if peer authentication is enabled.Notes for TLS authenticationSincev3.2.0,TLS certificates get reloaded on every client connection. This is useful when replacing expiry certs without stopping etcd servers; it can be done by overwriting old certs with new ones. Refreshing certs for every connection should not have too much overhead, but can be improved in the future, with caching layer. Example tests can be foundhere.Sincev3.2.0,server denies incoming peer certs with wrong IPSAN. For instance, if peer cert contains any IP addresses in Subject Alternative Name (SAN) field, server authenticates a peer only when the remote IP address matches one of those IP addresses. This is to prevent unauthorized endpoints from joining the cluster. For example, peer B’s CSR (withcfssl) is:{"CN":"etcd peer","hosts":["*.example.default.svc","*.example.default.svc.cluster.local","10.138.0.27"],"key":{"algo":"rsa","size":2048},"names":[{"C":"US","L":"CA","ST":"San Francisco"}]}when peer B’s actual IP address is10.138.0.2, not10.138.0.27. When peer B tries to join the cluster, peer A will reject B with the errorx509: certificate is valid for 10.138.0.27, not 10.138.0.2, because B’s remote IP address does not match the one in Subject Alternative Name (SAN) field.Sincev3.2.0,server resolves TLSDNSNameswhen checkingSAN. For instance, if peer cert contains only DNS names (no IP addresses) in Subject Alternative Name (SAN) field, server authenticates a peer only when forward-lookups (dig b.com) on those DNS names have matching IP with the remote IP address. For example, peer B’s CSR (withcfssl) is:{"CN":"etcd peer","hosts":["b.com"],when peer B’s remote IP address is10.138.0.2. When peer B tries to join the cluster, peer A looks up the incoming hostb.comto get the list of IP addresses (e.g.dig b.com). And rejects B if the list does not contain the IP10.138.0.2, with the errortls: 10.138.0.2 does not match any of DNSNames ["b.com"].Sincev3.2.2,server accepts connections if IP matches, without checking DNS entries. For instance, if peer cert contains IP addresses and DNS names in Subject Alternative Name (SAN) field, and the remote IP address matches one of those IP addresses, server just accepts connection without further checking the DNS names. For example, peer B’s CSR (withcfssl) is:{"CN":"etcd peer","hosts":["invalid.domain","10.138.0.2"],when peer B’s remote IP address is10.138.0.2andinvalid.domainis a invalid host. When peer B tries to join the cluster, peer A successfully authenticates B, since Subject Alternative Name (SAN) field has a valid matching IP address. Seeissue#8206for more detail.Sincev3.2.5,server supports reverse-lookup on wildcard DNSSAN. For instance, if peer cert contains only DNS names (no IP addresses) in Subject Alternative Name (SAN) field, server first reverse-lookups the remote IP address to get a list of names mapping to that address (e.g.nslookup IPADDR). Then accepts the connection if those names have a matching name with peer cert’s DNS names (either by exact or wildcard match). If none is matched, server forward-lookups each DNS entry in peer cert (e.g. look upexample.default.svcwhen the entry is*.example.default.svc), and accepts connection only when the host’s resolved addresses have the matching IP address with the peer’s remote IP address. For example, peer B’s CSR (withcfssl) is:{"CN":"etcd peer","hosts":["*.example.default.svc","*.example.default.svc.cluster.local"],when peer B’s remote IP address is10.138.0.2. When peer B tries to join the cluster, peer A reverse-lookup the IP10.138.0.2to get the list of host names. And either exact or wildcard match the host names with peer B’s cert DNS names in Subject Alternative Name (SAN) field. If none of reverse/forward lookups worked, it returns an error"tls: "10.138.0.2" does not match any of DNSNames ["*.example.default.svc","*.example.default.svc.cluster.local"]. Seeissue#8268for more detail.v3.3.0addsetcd --peer-cert-allowed-cnflag to supportCN(Common Name)-based auth for inter-peer connections. Kubernetes TLS bootstrapping involves generating dynamic certificates for etcd members and other system components (e.g. API server, kubelet, etc.). Maintaining different CAs for each component provides tighter access control to etcd cluster but often tedious. When--peer-cert-allowed-cnflag is specified, node can only join with matching common name even with shared CAs. For example, each member in 3-node cluster is set up with CSRs (withcfssl) as below:{"CN":"etcd.local","hosts":["m1.etcd.local","127.0.0.1","localhost"],{"CN":"etcd.local","hosts":["m2.etcd.local","127.0.0.1","localhost"],{"CN":"etcd.local","hosts":["m3.etcd.local","127.0.0.1","localhost"],Then only peers with matching common names will be authenticated if--peer-cert-allowed-cn etcd.localis given. And nodes with different CNs in CSRs or different--peer-cert-allowed-cnwill be rejected:$ etcd --peer-cert-allowed-cn m1.etcd.localI|embed: rejected connection from"127.0.0.1:48044"(error"CommonName authentication failed", ServerName"m1.etcd.local")I|embed: rejected connection from"127.0.0.1:55702"(error"remote error: tls: bad certificate", ServerName"m3.etcd.local")Each process should be started with:etcd --peer-cert-allowed-cn etcd.localI|pkg/netutil: resolving m3.etcd.local:32380 to 127.0.0.1:32380I|pkg/netutil: resolving m2.etcd.local:22380 to 127.0.0.1:22380I|pkg/netutil: resolving m1.etcd.local:2380 to 127.0.0.1:2380I|etcdserver: published{Name:m3 ClientURLs:[https://m3.etcd.local:32379]}to cluster 9db03f09b20de32bI|embed: ready to serve client requestsI|etcdserver: published{Name:m1 ClientURLs:[https://m1.etcd.local:2379]}to cluster 9db03f09b20de32bI|embed: ready to serve client requestsI|etcdserver: published{Name:m2 ClientURLs:[https://m2.etcd.local:22379]}to cluster 9db03f09b20de32bI|embed: ready to serve client requestsI|embed: serving client requests on 127.0.0.1:32379I|embed: serving client requests on 127.0.0.1:22379I|embed: serving client requests on 127.0.0.1:2379v3.2.19andv3.3.4fixes TLS reload whencertificate SAN field only includes IP addresses but no domain names. For example, a member is set up with CSRs (withcfssl) as below:{"CN":"etcd.local","hosts":["127.0.0.1"],In Go, server calls(*tls.Config).GetCertificatefor TLS reload if and only if server’s(*tls.Config).Certificatesfield is not empty, or(*tls.ClientHelloInfo).ServerNameis not empty with a valid SNI from the client. Previously, etcd always populates(*tls.Config).Certificateson the initial client TLS handshake, as non-empty. Thus, client was always expected to supply a matching SNI in order to pass the TLS verification and to trigger(*tls.Config).GetCertificateto reload TLS assets.However, a certificate whose SAN field doesnot include any domain names but only IP addresseswould request*tls.ClientHelloInfowith an emptyServerNamefield, thus failing to trigger the TLS reload on initial TLS handshake; this becomes a problem when expired certificates need to be replaced online.Now,(*tls.Config).Certificatesis created empty on initial TLS client handshake, first to trigger(*tls.Config).GetCertificate, and then to populate rest of the certificates on every new TLS connection, even when client SNI is empty (e.g. cert only includes IPs).Notes for Host Whitelistetcd --host-whitelistflag specifies acceptable hostnames from HTTP client requests. Client origin policy protects against“DNS Rebinding”attacks to insecure etcd servers. That is, any website can simply create an authorized DNS name, and direct DNS to"localhost"(or any other address). Then, all HTTP endpoints of etcd server listening on"localhost"becomes accessible, thus vulnerable to DNS rebinding attacks. SeeCVE-2018-5702for more detail.Client origin policy works as follows:If client connection is secure via HTTPS, allow any hostnames.If client connection is not secure and"HostWhitelist"is not empty, only allow HTTP requests whose Host field is listed in whitelist.Note that the client origin policy is enforced whether authentication is enabled or not, for tighter controls.By default,etcd --host-whitelistandembed.Config.HostWhitelistare setemptyto allow all hostnames. Note that when specifying hostnames, loopback addresses are not added automatically. To allow loopback interfaces, add them to whitelist manually (e.g."localhost","127.0.0.1", etc.).Frequently asked questionsI’m seeing a SSLv3 alert handshake failure when using TLS client authentication?Thecrypto/tlspackage ofgolangchecks the key usage of the certificate public key before using it.
To use the certificate public key to do client auth, we need to addclientAuthtoExtended Key Usagewhen creating the certificate public key.Here is how to do it:Add the following section to openssl.cnf:[ ssl_client ]
...
  extendedKeyUsage = clientAuth
...When creating the cert be sure to reference it in the-extensionsflag:$ openssl ca -config openssl.cnf -policy policy_anything -extensions ssl_client -out certs/machine.crt -infiles machine.csrWith peer certificate authentication I receive “certificate is valid for 127.0.0.1, not $MY_IP”Make sure to sign the certificates with a Subject Name the member’s public IP address. Theetcd-catool for example provides an--ip=option for itsnew-certcommand.The certificate needs to be signed for the member’s FQDN in its Subject Name, use Subject Alternative Names (short IP SANs) to add the IP address. Theetcd-catool provides--domain=option for itsnew-certcommand, and openssl can makeittoo.Does etcd encrypt data stored on disk drives?No. etcd doesn’t encrypt key/value data stored on disk drives. If a user need to encrypt data stored on etcd, there are some options:Let client applications encrypt and decrypt the dataUse a feature of underlying storage systems for encrypting stored data likedm-cryptI’m seeing a log warning that “directory X exist without recommended permission -rwx——”When etcd create certain new directories it sets file permission to 700 to prevent unprivileged access as possible. However, if user has already created a directory with own preference, etcd uses the existing directory and logs a warning message if the permission is different than 700.FeedbackWas this page helpful?YesNoGlad to hear it! Pleasetell us how we can improve.Sorry to hear that. Pleasetell us how we can improve.Last modified September 12, 2023:Fix paths to client certificates in curl examples (596412f)©
2013–2024etcd AuthorsTerms|Privacy|Trademarks|LicenseAll Rights Reserved