URL: https://nats.io/blog/jetstream-java-client-04-push-subscribe/

AboutDownloadDocumentationBlogCommunitySupportPrivacyJetStream Push Consumers with the NATS.io Java LibraryScott Fauerbach— June 3, 2021Back to BlogJetStream Push Consumers with the NATS.io Java LibraryThe last entry in this series talked about theconsumer optionsthat are available when subscribing to messages.
This entry will demonstrate the basics of a push subscription.PushA push subscription is where the server is in control and sends messages to the client.
It can be made durable or ephemeral based on your use case. Here are the API method calls used for creating a push subscription:JetStreamSubscription subscribe(String subject) throws IOException, JetStreamApiException;
JetStreamSubscription subscribe(String subject, PushSubscribeOptions options) throws IOException, JetStreamApiException;
JetStreamSubscription subscribe(String subject, String queue, PushSubscribeOptions options) throws IOException, JetStreamApiException;
JetStreamSubscription subscribe(String subject, Dispatcher dispatcher, MessageHandler handler, boolean autoAck) throws IOException, JetStreamApiException;
JetStreamSubscription subscribe(String subject, Dispatcher dispatcher, MessageHandler handler, boolean autoAck, PushSubscribeOptions options) throws IOException, JetStreamApiException;
JetStreamSubscription subscribe(String subject, String queue, Dispatcher dispatcher, MessageHandler handler, boolean autoAck, PushSubscribeOptions options) throws IOException, JetStreamApiException;subject - every subscription needs a subjectoptions - configure PushSubscribeOptions or use the default configurationqueue - multiple consumers using the same queue name will each get a unique portion of the messages in the stream.dispatcher - necessary if you want to handle messages asynchronouslyhandler - the asynchronous handlerautoAck - for asynchronous handling, the message can be acknowledged for you before your own handler is called.PushSubscribeOptionsThePushSubscribeOptionsallows you to identify thestream nameand
is a helper for the most common pushConsumerConfigurationoptions,durable nameand thedeliver subject.
Setting those in thePushSubscribeOptionsbuilder will
create aConsumerConfigurationwith those values unless you have provided your ownConsumerConfiguration,
in which case the values set in thePushSubscribeOptionsbuilder will take precedence.Builder// set the stream name
public Builder stream(String stream)

// set the deliver subject
public Builder deliverSubject(String deliverSubject)

// set the durable name
public Builder durable(String durable)

// set the configuration object
public Builder configuration(ConsumerConfiguration configuration)SynchronousYou can handle a push subscription message synchronously…Connection nc = Nats.connect("nats://demo.nats.io")
JetStream js = nc.jetStream();

...
        
JetStreamSubscription sub = js.subscribe("my-subject");
nc.flush(Duration.ofSeconds(1)); // flush outgoing communication with/to the server

while (keepGoing)
    // get the next message waiting a maximum of 1 second for it to arrive
    handleMessage(sub.nextMessage(Duration.ofSeconds(1)));
}

...
        
void handleMessage(Message msg) {
    if (msg == null) {
        // the server had no message for us. 
        // Maybe sleep here or do some housekeeping
    }
    else {
        if (msg.isJetStream()) {
            // do something with the message
            // don't forget to ack based on your consumer AckPolicy configuration
            // or async auto ack setting
            msg.ack();
        }
        else if (msg.isStatusMessage()) {
            // status messages include heartbeat and flow control depending on
            // your consumer configuration
            System.out.println("Status " + msg.getStatus());
        }
    }
}AsynchronousOr asynchronously in the thread that the dispatcher will be run in…MessageHandler handler = (Message msg) -> {
    // see handleMessage in above example
    handleMessage(msg)
};

// create a dispatcher without a default handler.
Dispatcher dispatcher = nc.createDispatcher();

// create a subscription
// dispatcher is the object that routes messages asynchronously 
// handler is the function that processes the message
JetStreamSubscription sub = js.subscribe("my-subject", dispatcher, handler, false);
nc.flush(Duration.ofSeconds(1)); // flush outgoing communication with/to the server

// do other stuff and make sure you keep the program running since the handler is running in a separate threadAbout the AuthorScott Fauerbach is a member of the engineering team atSynadia Communications.Back to BlogCopyright © NATS Authors 2024NATS is aCloud Native Computing Foundationincubating projectThe Linux Foundation has registered trademarks and uses trademarks.For a list of trademarks of The Linux Foundation, please seeTrademark Usage page.