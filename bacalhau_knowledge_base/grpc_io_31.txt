URL: https://grpc.io/docs/languages/cpp/basics/

gRPCAboutMeetDocsGuidesShowcaseBlogCommunitygRPConf 2024 is happening NEXT WEEK onAug. 27th!-Register nowand get 25% off with the code GOOGLE25.DocsWhat is gRPC?IntroductionCore conceptsFAQLanguagesC# / .NETAPI (legacy)Daily builds (legacy)C++Quick startBasics tutorialAsync-API tutorialAsynchronous Callback API TutorialBest Practices for gRPC C++ API and FAQALTSAPIDartQuick startBasics tutorialAPIGoQuick startBasics tutorialALTSAPIGenerated codeJavaQuick startBasics tutorialALTSAPIGenerated codeKotlinQuick startBasics tutorialAPINodeQuick startBasics tutorialAPIObjective-CQuick startBasics tutorialOAuth2APIPHPQuick startBasics tutorialAPIDaily buildsPythonQuick startBasics tutorialALTSGenerated codeAPIDaily buildsRubyQuick startBasics tutorialAPIDaily buildsPlatformsAndroidJavaQuick startBasics tutorialAPIKotlinQuick startAPIWebQuick startBasics tutorialGuidesAuthenticationBenchmarkingCancellationCompressionCustom Backend MetricsCustom Load Balancing PoliciesCustom Name ResolutionDeadlinesDebuggingError handlingFlow ControlHealth CheckingInterceptorsKeepaliveMetadataOpenTelemetry MetricsPerformance Best PracticesReflectionRequest HedgingRetryService ConfigStatus CodesWait-for-ReadyView page sourceEdit this pageCreate child pageCreate documentation issueCreate project issueWhy use gRPC?Example code and setupDefining the serviceGenerating client and server codeCreating the serverImplementing RouteGuideStarting the serverCreating the clientCreating a stubCalling service methodsSimple RPCStreaming RPCsTry it out!DocsLanguagesC++Basics tutorialBasics tutorialA basic tutorial introduction to gRPC in C++.ContentsWhy use gRPC?Example code and setupDefining the serviceGenerating client and server codeCreating the serverImplementing RouteGuideStarting the serverCreating the clientCreating a stubCalling service methodsSimple RPCStreaming RPCsTry it out!Basics tutorialA basic tutorial introduction to gRPC in C++.This tutorial provides a basic C++ programmer’s introduction to working with gRPC.By walking through this example you’ll learn how to:Define a service in a.protofile.Generate server and client code using the protocol buffer compiler.Use the C++ gRPC API to write a simple client and server for your service.It assumes that you have read theIntroduction to gRPCand are familiar
withprotocol
buffers. Note
that the example in this tutorial uses the proto3 version of the protocol
buffers language: you can find out more in
theproto3 language
guideandC++
generated code
guide.Why use gRPC?Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.With gRPC we can define our service once in a.protofile and generate clients
and servers in any of gRPC’s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.Example code and setupThe example code is part of thegrpcrepo underexamples/cpp/route_guide.
Get the example code and build gRPC:Follow the Quick start instructions tobuild and locally install gRPC from
source.From the repo folder, change to the route guide example directory:$cdexamples/cpp/route_guideRuncmake$ mkdir -p cmake/build$cdcmake/build$ cmake -DCMAKE_PREFIX_PATH=$MY_INSTALL_DIR../..Defining the serviceOur first step (as you’ll know from theIntroduction to gRPC) is to
define the gRPCserviceand the methodrequestandresponsetypes usingprotocol buffers.
You can see the complete.protofile inexamples/protos/route_guide.proto.To define a service, you specify a namedservicein your.protofile:serviceRouteGuide {...}Then you definerpcmethods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in theRouteGuideservice:Asimple RPCwhere the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.// Obtains the feature at a given position.rpcGetFeature(Point)returns(Feature) {}Aserver-side streaming RPCwhere the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing thestreamkeyword before theresponsetype.// Obtains the Features available within the given Rectangle.  Results are// streamed rather than returned at once (e.g. in a response message with a// repeated field), as the rectangle may cover a large area and contain a// huge number of features.rpcListFeatures(Rectangle)returns(stream Feature) {}Aclient-side streaming RPCwhere the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
thestreamkeyword before therequesttype.// Accepts a stream of Points on a route being traversed, returning a// RouteSummary when traversal is completed.rpcRecordRoute(stream Point)returns(RouteSummary) {}Abidirectional streaming RPCwhere both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing thestreamkeyword before both the request and the response.// Accepts a stream of RouteNotes sent while a route is being traversed,// while receiving other RouteNotes (e.g. from other users).rpcRouteChat(stream RouteNote)returns(stream RouteNote) {}Our.protofile also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here’s
thePointmessage type:// Points are represented as latitude-longitude pairs in the E7 representation// (degrees multiplied by 10**7 and rounded to the nearest integer).// Latitudes should be in the range +/- 90 degrees and longitude should be in// the range +/- 180 degrees (inclusive).messagePoint{int32latitude=1;int32longitude=2;}Generating client and server codeNext we need to generate the gRPC client and server interfaces from our.protoservice definition. We do this using the protocol buffer compilerprotocwith
a special gRPC C++ plugin.For simplicity, we’ve provided aCMakeLists.txtthat runsprotocfor you with the appropriate plugin, input, and output (if
you want to run this yourself, make sure you’ve installed protoc and followed
the gRPC codeinstallation instructionsfirst):$ make route_guide.grpc.pb.owhich actually runs:$ protoc -I ../../protos --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_cpp_plugin`../../protos/route_guide.proto$ protoc -I ../../protos --cpp_out=. ../../protos/route_guide.protoRunning this command generates the following files in your current directory:route_guide.pb.h, the header which declares your generated message classesroute_guide.pb.cc, which contains the implementation of your message classesroute_guide.grpc.pb.h, the header which declares your generated service
classesroute_guide.grpc.pb.cc, which contains the implementation of your service
classesThese contain:All the protocol buffer code to populate, serialize, and retrieve our request
and response message typesA class calledRouteGuidethat containsa remote interface type (orstub) for clients to call with the methods
defined in theRouteGuideservice.two abstract interfaces for servers to implement, also with the methods
defined in theRouteGuideservice.Creating the serverFirst let’s look at how we create aRouteGuideserver. If you’re only
interested in creating gRPC clients, you can skip this section and go straight
toCreating the client(though you might find it interesting
anyway!).There are two parts to making ourRouteGuideservice do its job:Implementing the service interface generated from our service definition:
doing the actual “work” of our service.Running a gRPC server to listen for requests from clients and return the
service responses.You can find our exampleRouteGuideserver inexamples/cpp/route_guide/route_guide_server.cc.
Let’s take a closer look at how it works.Implementing RouteGuideAs you can see, our server has aRouteGuideImplclass that implements the
generatedRouteGuide::Serviceinterface:classRouteGuideImplfinal:publicRouteGuide::Service {...}In this case we’re implementing thesynchronousversion ofRouteGuide, which
provides our default gRPC server behaviour. It’s also possible to implement an
asynchronous interface,RouteGuide::AsyncService, which allows you to further
customize your server’s threading behaviour, though we won’t look at this in
this tutorial.RouteGuideImplimplements all our service methods. Let’s look at the simplest
type first,GetFeature, which just gets aPointfrom the client and returns
the corresponding feature information from its database in aFeature.StatusGetFeature(ServerContext*context,constPoint*point,Feature*feature)override{feature->set_name(GetFeatureName(*point, feature_list_));feature->mutable_location()->CopyFrom(*point);returnStatus::OK;}The method is passed a context object for the RPC, the client’sPointprotocol
buffer request, and aFeatureprotocol buffer to fill in with the response
information. In the method we populate theFeaturewith the appropriate
information, and thenreturnwith anOKstatus to tell gRPC that we’ve
finished dealing with the RPC and that theFeaturecan be returned to the
client.Note that all service methods can (and will!) be called from multiple threads at
the same time. You have to make sure that your method implementations are
thread safe. In our example,feature_list_is never changed after
construction, so it is safe by design. But iffeature_list_would change during
the lifetime of the service, we would need to synchronize access to this member.Now let’s look at something a bit more complicated - a streaming RPC.ListFeaturesis a server-side streaming RPC, so we need to send back multipleFeatures to our client.StatusListFeatures(ServerContext*context,constRectangle*rectangle,ServerWriter<Feature>*writer)override{autolo=rectangle->lo();autohi=rectangle->hi();longleft=std::min(lo.longitude(), hi.longitude());longright=std::max(lo.longitude(), hi.longitude());longtop=std::max(lo.latitude(), hi.latitude());longbottom=std::min(lo.latitude(), hi.latitude());for(constFeature&f: feature_list_) {if(f.location().longitude()>=left&&f.location().longitude()<=right&&f.location().latitude()>=bottom&&f.location().latitude()<=top) {writer->Write(f);}}returnStatus::OK;}As you can see, instead of getting simple request and response objects in our
method parameters, this time we get a request object (theRectanglein which
our client wants to findFeatures) and a specialServerWriterobject. In the
method, we populate as manyFeatureobjects as we need to return, writing them
to theServerWriterusing itsWrite()method. Finally, as in our simple RPC,
wereturn Status::OKto tell gRPC that we’ve finished writing responses.If you look at the client-side streaming methodRecordRouteyou’ll see it’s
quite similar, except this time we get aServerReaderinstead of a request
object and a single response. We use theServerReadersRead()method to
repeatedly read in our client’s requests to a request object (in this case aPoint) until there are no more messages: the server needs to check the return
value ofRead()after each call. Iftrue, the stream is still good and it
can continue reading; iffalsethe message stream has ended.while(stream->Read(&point)) {...//process client input}Finally, let’s look at our bidirectional streaming RPCRouteChat().StatusRouteChat(ServerContext*context,ServerReaderWriter<RouteNote, RouteNote>*stream)override{RouteNote note;while(stream->Read(&note)) {std::unique_lock<std::mutex>lock(mu_);for(constRouteNote&n: received_notes_) {if(n.location().latitude()==note.location().latitude()&&n.location().longitude()==note.location().longitude()) {stream->Write(n);}}received_notes_.push_back(note);}returnStatus::OK;}This time we get aServerReaderWriterthat can be used to readandwrite
messages. The syntax for reading and writing here is exactly the same as for our
client-streaming and server-streaming methods. Although each side will always
get the other’s messages in the order they were written, both the client and
server can read and write in any order — the streams operate completely
independently.Note that sincereceived_notes_is an instance variable and can be accessed by
multiple threads, we use a mutex lock here to guarantee exclusive access.Starting the serverOnce we’ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for ourRouteGuideservice:voidRunServer(conststd::string&db_path) {std::string server_address("0.0.0.0:50051");RouteGuideImpl service(db_path);ServerBuilder builder;builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());builder.RegisterService(&service);std::unique_ptr<Server>server(builder.BuildAndStart());std::cout<<"Server listening on "<<server_address<<std::endl;server->Wait();}As you can see, we build and start our server using aServerBuilder. To do this, we:Create an instance of our service implementation classRouteGuideImpl.Create an instance of the factoryServerBuilderclass.Specify the address and port we want to use to listen for client requests
using the builder’sAddListeningPort()method.Register our service implementation with the builder.CallBuildAndStart()on the builder to create and start an RPC server for
our service.CallWait()on the server to do a blocking wait until process is killed orShutdown()is called.Creating the clientIn this section, we’ll look at creating a C++ client for ourRouteGuideservice. You can see our complete example client code inexamples/cpp/route_guide/route_guide_client.cc.Creating a stubTo call service methods, we first need to create astub.First we need to create a gRPCchannelfor our stub, specifying the server
address and port we want to connect to - in our case we’ll use no SSL:grpc::CreateChannel("localhost:50051", grpc::InsecureChannelCredentials());NoteIn order to set additional options for thechannel, use thegrpc::CreateCustomChannel()api with any special channel arguments -grpc::ChannelArguments.Now we can use the channel to create our stub using theNewStubmethod provided in theRouteGuideclass we generated from our.proto.public:RouteGuideClient(std::shared_ptr<ChannelInterface>channel,conststd::string&db):stub_(RouteGuide::NewStub(channel)) {...}Calling service methodsNow let’s look at how we call our service methods. Note that in this tutorial
we’re calling theblocking/synchronousversions of each method: this means
that the RPC call waits for the server to respond, and will either return a
response or raise an exception.Simple RPCCalling the simple RPCGetFeatureis nearly as straightforward as calling a
local method.Point point;Feature feature;point=MakePoint(409146138,-746188906);GetOneFeature(point,&feature);...boolGetOneFeature(constPoint&point, Feature*feature) {ClientContext context;Status status=stub_->GetFeature(&context, point, feature);...}As you can see, we create and populate a request protocol buffer object (in our
casePoint), and create a response protocol buffer object for the server to
fill in. We also create aClientContextobject for our call - you can
optionally set RPC configuration values on this object, such as deadlines,
though for now we’ll use the default settings. Note that you cannot reuse this
object between calls. Finally, we call the method on the stub, passing it the
context, request, and response. If the method returnsOK, then we can read the
response information from the server from our response object.std::cout<<"Found feature called "<<feature->name()<<" at "<<feature->location().latitude()/kCoordFactor_<<", "<<feature->location().longitude()/kCoordFactor_<<std::endl;Streaming RPCsNow let’s look at our streaming methods. If you’ve already readCreating the
serversome of this may look very familiar - streaming RPCs are
implemented in a similar way on both sides. Here’s where we call the server-side
streaming methodListFeatures, which returns a stream of geographicalFeatures:std::unique_ptr<ClientReader<Feature>>reader(stub_->ListFeatures(&context, rect));while(reader->Read(&feature)) {std::cout<<"Found feature called "<<feature.name()<<" at "<<feature.location().latitude()/kCoordFactor_<<", "<<feature.location().longitude()/kCoordFactor_<<std::endl;}Status status=reader->Finish();Instead of passing the method a context, request, and response, we pass it a
context and request and get aClientReaderobject back. The client can use theClientReaderto read the server’s responses. We use theClientReadersRead()method to repeatedly read in the server’s responses to a response
protocol buffer object (in this case aFeature) until there are no more
messages: the client needs to check the return value ofRead()after each
call. Iftrue, the stream is still good and it can continue reading; iffalsethe message stream has ended. Finally, we callFinish()on the stream
to complete the call and get our RPC status.The client-side streaming methodRecordRouteis similar, except there we pass
the method a context and response object and get back aClientWriter.std::unique_ptr<ClientWriter<Point>>writer(stub_->RecordRoute(&context,&stats));for(inti=0; i<kPoints; i++) {constFeature&f=feature_list_[feature_distribution(generator)];std::cout<<"Visiting point "<<f.location().latitude()/kCoordFactor_<<", "<<f.location().longitude()/kCoordFactor_<<std::endl;if(!writer->Write(f.location())) {// Broken stream.break;}std::this_thread::sleep_for(std::chrono::milliseconds(delay_distribution(generator)));}writer->WritesDone();Status status=writer->Finish();if(status.IsOk()) {std::cout<<"Finished trip with "<<stats.point_count()<<" points\n"<<"Passed "<<stats.feature_count()<<" features\n"<<"Travelled "<<stats.distance()<<" meters\n"<<"It took "<<stats.elapsed_time()<<" seconds"<<std::endl;}else{std::cout<<"RecordRoute rpc failed."<<std::endl;}Once we’ve finished writing our client’s requests to the stream usingWrite(),
we need to callWritesDone()on the stream to let gRPC know that we’ve
finished writing, thenFinish()to complete the call and get our RPC status.
If the status isOK, our response object that we initially passed toRecordRoute()will be populated with the server’s response.Finally, let’s look at our bidirectional streaming RPCRouteChat(). In this
case, we just pass a context to the method and get back aClientReaderWriter,
which we can use to both write and read messages.std::shared_ptr<ClientReaderWriter<RouteNote, RouteNote>>stream(stub_->RouteChat(&context));The syntax for reading and writing here is exactly the same as for our
client-streaming and server-streaming methods. Although each side will always
get the other’s messages in the order they were written, both the client and
server can read and write in any order — the streams operate completely
independently.Try it out!Build the client and server:$ makeRun the server:$ ./route_guide_server --db_path=path/to/route_guide_db.jsonFrom a different terminal, run the client:$ ./route_guide_client --db_path=path/to/route_guide_db.jsonLast modified July 14, 2023:cpp: Update basics.md - Format file extensions in code font (#1165) (7841685)View page sourceEdit this pageCreate child pageCreate documentation issueCreate project issue© 2024 gRPC AuthorsTerms|Privacy|Trademarks|License|About