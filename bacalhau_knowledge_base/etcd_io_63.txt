URL: https://etcd.io/docs/v3.6/dev-guide/interacting_v3/

etcdDocsBlogCommunityInstallPlayVersionsv3.6v3.5v3.4v3.3v3.2v3.1v2.3Versionsv3.6-DRAFTQuickstartDemoTutorialsHow to Set Up a Demo etcd ClusterReading from etcdWriting to etcdHow to get keys by prefixHow to delete keysHow to make multiple writes in a transactionHow to watch keysHow to create leaseHow to create locksHow to conduct leader election in etcd clusterHow to check Cluster statusHow to save the databaseHow to migrate etcd from v2 to v3How to Add and Remove MembersInstallFAQLibraries and toolsMetricsReporting bugsTuningDiscovery service protocolLogging conventionsGolang modulesLearningData modeletcd client designetcd learner designetcd v3 authentication designetcd APIetcd persistent storage filesetcd API guaranteesetcd versus other key-value storesGlossaryDeveloper guideDiscovery service protocolSet up a local clusterInteracting with etcdWhy gRPC gatewaygRPC naming and discoverySystem limitsetcd featuresAPI referenceAPI reference: concurrencyOperations guideAuthentication GuidesRole-based access controlAuthenticationConfiguration optionsTransport security modelClustering GuideRun etcd clusters as a Kubernetes StatefulSetRun etcd clusters inside containersFailure modesDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMonitoring etcdPerformanceDesign of runtime reconfigurationRuntime reconfigurationSupported platformsVersioningData CorruptionBenchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkBenchmarking etcd v3Benchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0Benchmarking etcd v2.1.0UpgradingUpgrading etcd clusters and applicationsUpgrade etcd from 3.4 to 3.5Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.0 to 3.1Upgrade etcd from 2.3 to 3.0TriageIssue triage guidelinesPR managementv3.5QuickstartDemoTutorialsHow to Set Up a Demo etcd ClusterReading from etcdWriting to etcdHow to get keys by prefixHow to delete keysHow to make multiple writes in a transactionHow to watch keysHow to create leaseHow to create locksHow to conduct leader election in etcd clusterHow to check Cluster statusHow to save the databaseHow to migrate etcd from v2 to v3How to Add and Remove MembersInstallFAQLibraries and toolsMetricsReporting bugsTuningDiscovery service protocolLogging conventionsGolang modulesLearningData modeletcd client designetcd learner designetcd v3 authentication designetcd APIetcd persistent storage filesetcd API guaranteesetcd versus other key-value storesGlossaryDeveloper guideDiscovery service protocolSet up a local clusterInteracting with etcdWhy gRPC gatewaygRPC naming and discoverySystem limitsetcd featuresAPI referenceAPI reference: concurrencyOperations guideAuthentication GuidesRole-based access controlAuthenticationConfiguration optionsTransport security modelClustering GuideRun etcd clusters as a Kubernetes StatefulSetRun etcd clusters inside containersFailure modesDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMonitoring etcdPerformanceDesign of runtime reconfigurationRuntime reconfigurationSupported platformsVersioningData CorruptionBenchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkBenchmarking etcd v3Benchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0Benchmarking etcd v2.1.0DowngradingDowngrading etcd clusters and applicationsDowngrade etcd from 3.5 to 3.4UpgradingUpgrading etcd clusters and applicationsUpgrade etcd from 3.4 to 3.5Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.0 to 3.1Upgrade etcd from 2.3 to 3.0TriageIssue triage guidelinesPR managementv3.4QuickstartOverviewDemoInstallFAQLibraries and toolsMetricsReporting bugsTuningDiscovery service protocolLogging conventionsLearningData modeletcd client designetcd learner designetcd v3 authentication designetcd3 APIetcd API guaranteesetcd versus other key-value storesGlossaryDeveloper guideDiscovery service protocolSet up a local clusterInteracting with etcdWhy gRPC gatewaygRPC naming and discoverySystem limitsetcd featuresAPI referenceAPI reference: concurrencyOperations guideConfiguration optionsRole-based access controlTransport security modelClustering GuideRun etcd clusters inside containersFailure modesDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenancePerformanceDesign of runtime reconfigurationRuntime reconfigurationSupported platformsMigrate applications from using API v2 to API v3VersioningData CorruptionMonitoring etcdBenchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkBenchmarking etcd v3Benchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0Benchmarking etcd v2.1.0UpgradingUpgrading etcd clusters and applicationsUpgrade etcd from 3.4 to 3.5Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.0 to 3.1Upgrade etcd from 2.3 to 3.0PlatformsAmazon Web ServicesContainer Linux with systemdFreeBSDTriageIssue Triage Guidelinesv3.3InstallLibraries and toolsMetricsBenchmarksBenchmarking etcd v2.1.0Benchmarking etcd v2.2.0Benchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v3Storage Memory Usage BenchmarkWatch Memory Usage BenchmarkDemoDeveloper guideDiscovery service protocoletcd API Referenceetcd concurrency API ReferenceExperimental APIs and featuresgRPC naming and discoveryInteracting with etcdSet up a local clusterSystem limitsWhy gRPC gatewayDiscovery service protocoletcd v3 APIFrequently Asked Questions (FAQ)Learningetcd client architectureClient feature matrixData modeletcd v3 authentication designetcd versus other key-value storesetcd3 APIGlossaryKV API guaranteesLearnerLogging conventionsOperations guideMonitoring etcdVersioningClustering GuideConfiguration flagsDesign of runtime reconfigurationDisaster recoveryetcd gatewayFailure modesgRPC proxyHardware recommendationsMaintenanceMigrate applications from using API v2 to API v3PerformanceRole-based access controlRun etcd clusters inside containersRuntime reconfigurationSupported systemsTransport security modelPlatformsAmazon Web ServicesContainer Linux with systemdFreeBSDProduction usersReporting bugsTuningUpgradingUpgrade etcd from 2.3 to 3.0Upgrade etcd from 3.0 to 3.1Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.4 to 3.5Upgrading etcd clusters and applicationsv3.2BenchmarksBenchmarking etcd v2.1.0Benchmarking etcd v2.2.0Benchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v3-demoStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkData modelDemoDeveloper guideDiscovery service protocoletcd API referenceetcd concurrency API ReferenceExperimental APIs and featuresgRPC gatewaygRPC naming and discoveryInteracting with etcdSet up a local clusterSystem limitsetcd dev internalDiscovery service protocolLogging conventionsetcd operations guideAuthentication GuideClustering GuideConfiguration flagsDesign of runtime reconfigurationDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMigrate applications from using API v2 to API v3Monitoring etcdPerformanceRun etcd clusters inside containersRuntime reconfigurationSecurity modelSupported platformsUnderstand failuresVersioningetcd upgradesUpgrade etcd from 2.3 to 3.0Upgrade etcd from 3.0 to 3.1Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.3 to 3.4Upgrading etcd clusters and applicationsetcd v3 authentication designetcd versus other key-value storesetcd3 APIFrequently Asked Questions (FAQ)GlossaryInstallKV API guaranteesLibraries and toolsMetricsPlatformsAmazon Web ServicesFreeBSDRun etcd on Container Linux with systemdProduction usersReporting bugsRFCetcd v3 APITuningv3.1Data modelDemoetcd benchmarksetcd v2.1.0-alpha benchmarksetcd v2.2.0 benchmarksetcd v2.2.0-rc benchmarksetcd v2.2.0-rc-memory benchmarksetcd v3-demo benchmarksStorage Memory Usage BenchmarkWatch Memory Usage Benchmarketcd developer guideDiscovery service protocoletcd API ReferenceExperimental APIs and featuresgRPC GatewaygRPC naming and discoveryInteracting with etcdSetup a local clusterSystem limitsetcd internal devDiscovery service protocolLogging conventionsetcd operations guideClustering GuideConfiguration flagsDesign of runtime reconfigurationDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMigrate applications from using API v2 to API v3Monitoring etcdPerformanceRun etcd clusters inside containersRuntime reconfigurationSecurity modelSupported platformsUnderstand failuresVersioningetcd3 APIFrequently Asked Questions (FAQ)GlossaryInstallKV API guaranteesLibraries and toolsMetricsPlatformsFreeBSDProduction usersReporting bugsRFCetcd v3 APITuningUpgrading etcd clusters and applicationsUpgrade etcd from 2.3 to 3.0Upgrade etcd from 3.0 to 3.1Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.3 to 3.4Why etcdv2.3AdministrationAuthentication GuideBackward CompatibilityBenchmarksBenchmarking etcd v2.2.0etcd 2.1.0-alpha benchmarksetcd 2.2.0-rc benchmarksetcd 2.2.0-rc memory benchmarksetcd 3 demo benchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkClustering GuideConfiguration FlagsDesign of Runtime ReconfigurationDevelopmentDiscovery Service ProtocolError Codeetcd APIetcd v3 APIFAQGlossaryLibraries and ToolsMembers APIMetricsMiscellaneous APIsPlatformsFreeBSProduction UsersProxyReporting BugsRunning etcd under DockerRuntime ReconfigurationSecurity ModelSnapshot MigrationTuningUpgrade etcd from 2.1 to 2.2Upgrade etcd from 2.1 to 2.2Upgrade etcd from 2.2 to 2.3v2 Auth and SecurityVersioningView page sourceEdit this pageCreate child pageCreate documentation issueCreate project issueFind versionsWrite a keyRead keysRead past version of keysRead keys which are greater than or equal to the byte value of the specified keyDelete keysWatch key changesWatch historical changes of keysWatch progressCompacted revisionsGrant leasesRevoke leasesKeep leases aliveGet lease informationVersionsv3.6-DRAFTDeveloper guideInteracting with etcdInteracting with etcdetcdctl: a command line tool for interacting with the etcd serverUsers mostly interact with etcd by putting or getting the value of a key. This section describes how to do that by using etcdctl, a command line tool for interacting with etcd server. The concepts described here should apply to the gRPC APIs or client library APIs.The API version used by etcdctl to speak to etcd may be set to version2or3via theETCDCTL_APIenvironment variable. By default, etcdctl on master (3.4) uses the v3 API and earlier versions (3.3 and earlier) default to the v2 API.Note that any key that was created using the v2 API will not be able to be queried via the v3 API. A v3 APIetcdctl getof a v2 key will exit with 0 and no key data, this is the expected behaviour.exportETCDCTL_API=3Find versionsetcdctl version and Server API version can be useful in finding the appropriate commands to be used for performing various operations on etcd.Here is the command to find the versions:$ etcdctl versionetcdctl version: 3.1.0-alpha.0+gitAPI version: 3.1Write a keyApplications store keys into the etcd cluster by writing to keys. Every stored key is replicated to all etcd cluster members through the Raft protocol to achieve consistency and reliability.Here is the command to set the value of keyfootobar:$ etcdctl put foo barOKAlso a key can be set for a specified interval of time by attaching lease to it.Here is the command to set the value of keyfoo1tobar1for 10s.$ etcdctl put foo1 bar1 --lease=1234abcdOKNote: The lease id1234abcdin the above command refers to id returned on creating the lease of 10s. This id can then be attached to the key.Read keysApplications can read values of keys from an etcd cluster. Queries may read a single key, or a range of keys.Suppose the etcd cluster has stored the following keys:foo=barfoo1=bar1foo2=bar2foo3=bar3Here is the command to read the value of keyfoo:$ etcdctl get foofoobarHere is the command to read the value of keyfooin hex format:$ etcdctl get foo --hex\x66\x6f\x6f# Key\x62\x61\x72# ValueHere is the command to read only the value of keyfoo:$ etcdctl get foo --print-value-onlybarHere is the command to range over the keys fromfootofoo3:$ etcdctl get foo foo3foobarfoo1bar1foo2bar2Note thatfoo3is excluded since the range is over the half-open interval[foo, foo3), excludingfoo3.Here is the command to range over all keys prefixed withfoo:$ etcdctl get --prefix foofoobarfoo1bar1foo2bar2foo3bar3Here is the command to range over all keys prefixed withfoo, limiting the number of results to 2:$ etcdctl get --prefix --limit=2foofoobarfoo1bar1Read past version of keysApplications may want to read superseded versions of a key. For example, an application may wish to roll back to an old configuration by accessing an earlier version of a key. Alternatively, an application may want a consistent view over multiple keys through multiple requests by accessing key history.
Since every modification to the etcd cluster key-value store increments the global revision of an etcd cluster, an application can read superseded keys by providing an older etcd revision.Suppose an etcd cluster already has the following keys:foo=bar# revision = 2foo1=bar1# revision = 3foo=bar_new# revision = 4foo1=bar1_new# revision = 5Here are an example to access the past versions of keys:$ etcdctl get --prefix foo# access the most recent versions of keysfoobar_newfoo1bar1_new$ etcdctl get --prefix --rev=4foo# access the versions of keys at revision 4foobar_newfoo1bar1$ etcdctl get --prefix --rev=3foo# access the versions of keys at revision 3foobarfoo1bar1$ etcdctl get --prefix --rev=2foo# access the versions of keys at revision 2foobar$ etcdctl get --prefix --rev=1foo# access the versions of keys at revision 1Read keys which are greater than or equal to the byte value of the specified keyApplications may want to read keys which are greater than or equal to the byte value of the specified key.Suppose an etcd cluster already has the following keys:a=123b=456z=789Here is the command to read keys which are greater than or equal to the byte value of keyb:$ etcdctl get --from-key bb456z789Delete keysApplications can delete a key or a range of keys from an etcd cluster.Suppose an etcd cluster already has the following keys:foo=barfoo1=bar1foo3=bar3zoo=valzoo1=val1zoo2=val2a=123b=456z=789Here is the command to delete keyfoo:$ etcdctl del foo1# one key is deletedHere is the command to delete keys ranging fromfootofoo9:$ etcdctl del foo foo92# two keys are deletedHere is the command to delete keyzoowith the deleted key value pair returned:$ etcdctl del --prev-kv zoo1# one key is deletedzoo# deleted keyval# the value of the deleted keyHere is the command to delete keys having prefix aszoo:$ etcdctl del --prefix zoo2# two keys are deletedHere is the command to delete keys which are greater than or equal to the byte value of keyb:$ etcdctl del --from-key b2# two keys are deletedWatch key changesApplications can watch on a key or a range of keys to monitor for any updates.Here is the command to watch on keyfoo:$ etcdctl watch foo# in another terminal: etcdctl put foo barPUTfoobarHere is the command to watch on keyfooin hex format:$ etcdctl watch foo --hex# in another terminal: etcdctl put foo barPUT\x66\x6f\x6f# Key\x62\x61\x72# ValueHere is the command to watch on a range key fromfootofoo9:$ etcdctl watch foo foo9# in another terminal: etcdctl put foo barPUTfoobar# in another terminal: etcdctl put foo1 bar1PUTfoo1bar1Here is the command to watch on keys having prefixfoo:$ etcdctl watch --prefix foo# in another terminal: etcdctl put foo barPUTfoobar# in another terminal: etcdctl put fooz1 barz1PUTfooz1barz1Here is the command to watch on multiple keysfooandzoo:$ etcdctl watch -i$ watch foo$ watch zoo# in another terminal: etcdctl put foo barPUTfoobar# in another terminal: etcdctl put zoo valPUTzoovalWatch historical changes of keysApplications may want to watch for historical changes of keys in etcd. For example, an application may wish to receive all the modifications of a key; if the application stays connected to etcd, thenwatchis good enough. However, if the application or etcd fails, a change may happen during the failure, and the application will not receive the update in real time. To guarantee the update is delivered, the application must be able to watch for historical changes to keys. To do this, an application can specify a historical revision on a watch, just like reading past version of keys.Suppose we finished the following sequence of operations:$ etcdctl put foo bar# revision = 2OK$ etcdctl put foo1 bar1# revision = 3OK$ etcdctl put foo bar_new# revision = 4OK$ etcdctl put foo1 bar1_new# revision = 5OKHere is an example to watch the historical changes:# watch for changes on key `foo` since revision 2$ etcdctl watch --rev=2fooPUTfoobarPUTfoobar_new# watch for changes on key `foo` since revision 3$ etcdctl watch --rev=3fooPUTfoobar_newHere is an example to watch only from the last historical change:# watch for changes on key `foo` and return last revision value along with modified value$ etcdctl watch --prev-kv foo# in another terminal: etcdctl put foo bar_latestPUTfoo# keybar_new# last value of foo key before modificationfoo# keybar_latest# value of foo key after modificationWatch progressApplications may want to check the progress of a watch to determine how up-to-date the watch stream is. For example, if a watch is used to update a cache, it can be useful to know if the cache is stale compared to the revision from a quorum read.Progress requests can be issued using the “progress” command in interactive watch session to ask the etcd server to send a progress notify update in the watch stream:$ etcdctl watch -i$ watch a$ progressprogress notify:1# in another terminal: etcdctl put x 0# in another terminal: etcdctl put y 1$ progressprogress notify:3Note: The revision number in the progress notify response is the revision from the local etcd server node that the watch stream is connected to. If this node is partitioned and not part of quorum, this progress notify revision might be lower than
than the revision returned by a quorum read against a non-partitioned etcd server node.Compacted revisionsAs we mentioned, etcd keeps revisions so that applications can read past versions of keys. However, to avoid accumulating an unbounded amount of history, it is important to compact past revisions. After compacting, etcd removes historical revisions, releasing resources for future use. All superseded data with revisions before the compacted revision will be unavailable.Here is the command to compact the revisions:$ etcdctl compact5compacted revision5# any revisions before the compacted one are not accessible$ etcdctl get --rev=4fooError:  rpc error:code=11desc=etcdserver: mvcc: required revision has been compactedNote: The current revision of etcd server can be found using get command on any key (existent or non-existent) in json format. Example is shown below for mykey which does not exist in etcd server:$ etcdctl get mykey -w=json{"header":{"cluster_id":14841639068965178418,"member_id":10276657743932975437,"revision":15,"raft_term":4}}Grant leasesApplications can grant leases for keys from an etcd cluster. When a key is attached to a lease, its lifetime is bound to the lease’s lifetime which in turn is governed by a time-to-live (TTL). Each lease has a minimum time-to-live (TTL) value specified by the application at grant time. The lease’s actual TTL value is at least the minimum TTL and is chosen by the etcd cluster. Once a lease’s TTL elapses, the lease expires and all attached keys are deleted.Here is the command to grant a lease:# grant a lease with 60 second TTL$ etcdctl lease grant60lease 32695410dcc0ca06 granted with TTL(60s)# attach key foo to lease 32695410dcc0ca06$ etcdctl put --lease=32695410dcc0ca06 foo barOKRevoke leasesApplications revoke leases by lease ID. Revoking a lease deletes all of its attached keys.Suppose we finished the following sequence of operations:$ etcdctl lease grant60lease 32695410dcc0ca06 granted with TTL(60s)$ etcdctl put --lease=32695410dcc0ca06 foo barOKHere is the command to revoke the same lease:$ etcdctl lease revoke 32695410dcc0ca06lease 32695410dcc0ca06 revoked$ etcdctl get foo# empty response since foo is deleted due to lease revocationKeep leases aliveApplications can keep a lease alive by refreshing its TTL so it does not expire.Suppose we finished the following sequence of operations:$ etcdctl lease grant60lease 32695410dcc0ca06 granted with TTL(60s)Here is the command to keep the same lease alive:$ etcdctl lease keep-alive 32695410dcc0ca06lease 32695410dcc0ca06 keepalived with TTL(60)lease 32695410dcc0ca06 keepalived with TTL(60)lease 32695410dcc0ca06 keepalived with TTL(60)...Get lease informationApplications may want to know about lease information, so that they can be renewed or to check if the lease still exists or it has expired. Applications may also want to know the keys to which a particular lease is attached.Suppose we finished the following sequence of operations:# grant a lease with 500 second TTL$ etcdctl lease grant500lease 694d5765fc71500b granted with TTL(500s)# attach key zoo1 to lease 694d5765fc71500b$ etcdctl put zoo1 val1 --lease=694d5765fc71500bOK# attach key zoo2 to lease 694d5765fc71500b$ etcdctl put zoo2 val2 --lease=694d5765fc71500bOKHere is the command to get information about the lease:$ etcdctl lease timetolive 694d5765fc71500blease 694d5765fc71500b granted with TTL(500s), remaining(258s)Here is the command to get information about the lease along with the keys attached with the lease:$ etcdctl lease timetolive --keys 694d5765fc71500blease 694d5765fc71500b granted with TTL(500s), remaining(132s), attached keys([zoo2 zoo1])# if the lease has expired or does not exist it will give the below response:Error:  etcdserver: requested lease not foundFeedbackWas this page helpful?YesNoGlad to hear it! Pleasetell us how we can improve.Sorry to hear that. Pleasetell us how we can improve.Last modified February 28, 2022:Create doc branch for v3.6 (9ed5c74)©
2013–2024etcd AuthorsTerms|Privacy|Trademarks|LicenseAll Rights Reserved