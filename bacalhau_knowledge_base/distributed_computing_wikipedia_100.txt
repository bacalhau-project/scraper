URL: https://en.wikipedia.org/wiki/Parallel_computing

Jump to contentMain menuMain menumove to sidebarhideNavigationMain pageContentsCurrent eventsRandom articleAbout WikipediaContact usDonateContributeHelpLearn to editCommunity portalRecent changesUpload fileSearchSearchAppearanceCreate accountLog inPersonal toolsCreate accountLog inPages for logged out editorslearn moreContributionsTalkContentsmove to sidebarhide(Top)1BackgroundToggle Background subsection1.1Amdahl's law and Gustafson's law1.2Dependencies1.3Race conditions, mutual exclusion, synchronization, and parallel slowdown1.4Fine-grained, coarse-grained, and embarrassing parallelism1.5Flynn's taxonomy2GranularityToggle Granularity subsection2.1Bit-level parallelism2.2Instruction-level parallelism2.3Task parallelism2.4Superword level parallelism3HardwareToggle Hardware subsection3.1Memory and communication3.2Classes of parallel computers3.2.1Multi-core computing3.2.2Symmetric multiprocessing3.2.3Distributed computing3.2.3.1Cluster computing3.2.3.2Massively parallel computing3.2.3.3Grid computing3.2.3.4Cloud computing3.2.4Specialized parallel computers3.2.4.1Reconfigurable computing with field-programmable gate arrays3.2.4.2General-purpose computing on graphics processing units (GPGPU)3.2.4.3Application-specific integrated circuits3.2.4.4Vector processors4SoftwareToggle Software subsection4.1Parallel programming languages4.2Automatic parallelization4.3Application checkpointing5Algorithmic methods6Fault tolerance7History8Biological brain as massively parallel computer9See also10References11Further reading12External linksToggle the table of contentsParallel computing53 languagesالعربيةAzərbaycancaবাংলাБългарскиBosanskiCatalàČeštinaDeutschEestiΕλληνικάEspañolEsperantoEuskaraفارسیFrançaisGalegoગુજરાતી한국어हिन्दीHrvatskiBahasa IndonesiaItalianoעבריתJawaಕನ್ನಡLatinaLatviešuMagyarമലയാളംमराठीМонголNederlands日本語Norsk bokmålPolskiPortuguêsRomânăРусскийShqipසිංහලSimple EnglishSlovenščinaСрпски / srpskiSuomiSvenskaதமிழ்TürkçeУкраїнськаاردوTiếng Việt吴语粵語中文Edit linksArticleTalkEnglishReadEditView historyToolsToolsmove to sidebarhideActionsReadEditView historyGeneralWhat links hereRelated changesUpload fileSpecial pagesPermanent linkPage informationCite this pageGet shortened URLDownload QR codeWikidata itemPrint/exportDownload as PDFPrintable versionIn other projectsWikimedia CommonsAppearancemove to sidebarhideFrom Wikipedia, the free encyclopedia"Parallelization" redirects here. For parallelization of manifolds, seeParallelization (mathematics).Programming paradigm in which many processes are executed simultaneouslyLargesupercomputerssuch as IBM'sBlue Gene/Pare designed to heavily exploit parallelism.Parallel computingis a type ofcomputationin which many calculations orprocessesare carried out simultaneously.[1]Large problems can often be divided into smaller ones, which can then be solved at the same time. There are several different forms of parallel computing:bit-level,instruction-level,data, andtask parallelism. Parallelism has long been employed inhigh-performance computing, but has gained broader interest due to the physical constraints preventingfrequency scaling.[2]As power consumption (and consequently heat generation) by computers has become a concern in recent years,[3]parallel computing has become the dominant paradigm incomputer architecture, mainly in the form ofmulti-core processors.[4]Parallelism vs concurrencyIncomputer science,parallelismand concurrency are two different things: a parallel program usesmultiple CPU cores, each core performing a task independently. On the other hand, concurrency enables a program to deal with multiple tasks even on a single CPU core; the core switches between tasks (i.e.threads) without necessarily completing each one. A program can have both, neither or a combination of parallelism and concurrency characteristics.[5]Parallel computers can be roughly classified according to the level at which the hardware supports parallelism, with multi-core andmulti-processorcomputers having multipleprocessing elementswithin a single machine, whileclusters,MPPs, andgridsuse multiple computers to work on the same task. Specialized parallel computer architectures are sometimes used alongside traditional processors, for accelerating specific tasks.In some cases parallelism is transparent to the programmer, such as in bit-level or instruction-level parallelism, but explicitlyparallel algorithms, particularly those that use concurrency, are more difficult to write thansequentialones,[6]because concurrency introduces several new classes of potentialsoftware bugs, of whichrace conditionsare the most common.Communicationandsynchronizationbetween the different subtasks are typically some of the greatest obstacles to getting optimal parallel program performance.A theoreticalupper boundon thespeed-upof a single program as a result of parallelization is given byAmdahl's law, which states that it is limited by the fraction of time for which the parallelization can be utilised.Background[edit]Traditionally,computer softwarehas been written forserial computation. To solve a problem, analgorithmis constructed and implemented as a serial stream of instructions. These instructions are executed on acentral processing uniton one computer. Only one instruction may execute at a time—after that instruction is finished, the next one is executed.[7]Parallel computing, on the other hand, uses multiple processing elements simultaneously to solve a problem. This is accomplished by breaking the problem into independent parts so that each processing element can execute its part of the algorithm simultaneously with the others. The processing elements can be diverse and include resources such as a single computer with multiple processors, several networked computers, specialized hardware, or any combination of the above.[7]Historically parallel computing was used for scientific computing and the simulation of scientific problems, particularly in the natural andengineering sciences, such asmeteorology. This led to the design of parallel hardware and software, as well ashigh performance computing.[8]Frequency scalingwas the dominant reason for improvements incomputer performancefrom the mid-1980s until 2004. Theruntimeof a program is equal to the number of instructions multiplied by the average time per instruction. Maintaining everything else constant, increasing the clock frequency decreases the average time it takes to execute an instruction. An increase in frequency thus decreases runtime for allcompute-boundprograms.[9]However, power consumptionPby a chip is given by the equationP=C×V2×F, whereCis thecapacitancebeing switched per clock cycle (proportional to the number of transistors whose inputs change),Visvoltage, andFis the processor frequency (cycles per second).[10]Increases in frequency increase the amount of power used in a processor. Increasing processor power consumption led ultimately toIntel's May 8, 2004 cancellation of itsTejas and Jayhawkprocessors, which is generally cited as the end of frequency scaling as the dominant computer architecture paradigm.[11]To deal with the problem of power consumption and overheating the majorcentral processing unit(CPU or processor) manufacturers started to produce power efficient processors with multiple cores. The core is the computing unit of the processor and in multi-core processors each core is independent and can access the same memory concurrently.Multi-core processorshave brought parallel computing todesktop computers. Thus parallelization of serial programs has become a mainstream programming task. In 2012 quad-core processors became standard fordesktop computers, whileservershave 10+ core processors. FromMoore's lawit can be predicted that the number of cores per processor will double every 18–24 months. This could mean that after 2020 a typical processor will have dozens or hundreds of cores, however in reality the standard is somewhere in the region of 4 to 16 cores, with some designs having a mix of performance and efficiency cores (such asARM's big.LITTLEdesign) due to thermal and design constraints.[12][citation needed]Anoperating systemcan ensure that different tasks and user programs are run in parallel on the available cores. However, for a serial software program to take full advantage of the multi-core architecture the programmer needs to restructure and parallelize the code. A speed-up of application software runtime will no longer be achieved through frequency scaling, instead programmers will need to parallelize their software code to take advantage of the increasing computing power of multicore architectures.[13]Amdahl's law and Gustafson's law[edit]A graphical representation ofAmdahl's law. The speedup of a program from parallelization is limited by how much of the program can be parallelized. For example, if 90% of the program can be parallelized, the theoretical maximum speedup using parallel computing would be 10 times no matter how many processors are used.Assume that a task has two independent parts,AandB. PartBtakes roughly 25% of the time of the whole computation. By working very hard, one may be able to make this part 5 times faster, but this only reduces the time for the whole computation by a little. In contrast, one may need to perform less work to make partAtwice as fast. This will make the computation much faster than by optimizing partB, even though partB's speedup is greater by ratio, (5 times versus 2 times).Optimally, thespeedupfrom parallelization would be linear—doubling the number of processing elements should halve the runtime, and doubling it a second time should again halve the runtime. However, very few parallel algorithms achieve optimal speedup. Most of them have a near-linear speedup for small numbers of processing elements, which flattens out into a constant value for large numbers of processing elements.The potential speedup of an algorithm on a parallel computing platform is given byAmdahl's law[14]Slatency(s)=11−p+ps=ss+p(1−s){\displaystyle S_{\text{latency}}(s)={\frac {1}{1-p+{\frac {p}{s}}}}={\frac {s}{s+p(1-s)}}}whereSlatencyis the potentialspeedupinlatencyof the execution of the whole task;sis the speedup in latency of the execution of the parallelizable part of the task;pis the percentage of the execution time of the whole task concerning the parallelizable part of the taskbefore parallelization.SinceSlatency< 1/(1 -p), it shows that a small part of the program which cannot be parallelized will limit the overall speedup available from parallelization. A program solving a large mathematical or engineering problem will typically consist of several parallelizable parts and several non-parallelizable (serial) parts. If the non-parallelizable part of a program accounts for 10% of the runtime (p= 0.9), we can get no more than a 10 times speedup, regardless of how many processors are added. This puts an upper limit on the usefulness of adding more parallel execution units. "When a task cannot be partitioned because of sequential constraints, the application of more effort has no effect on the schedule. The bearing of a child takes nine months, no matter how many women are assigned."[15]A graphical representation ofGustafson's lawAmdahl's law only applies to cases where the problem size is fixed. In practice, as more computing resources become available, they tend to get used on larger problems (larger datasets), and the time spent in the parallelizable part often grows much faster than the inherently serial work.[16]In this case,Gustafson's lawgives a less pessimistic and more realistic assessment of parallel performance:[17]Slatency(s)=1−p+sp.{\displaystyle S_{\text{latency}}(s)=1-p+sp.}Both Amdahl's law and Gustafson's law assume that the running time of the serial part of the program is independent of the number of processors. Amdahl's law assumes that the entire problem is of fixed size so that the total amount of work to be done in parallel is alsoindependent of the number of processors, whereas Gustafson's law assumes that the total amount of work to be done in parallelvaries linearly with the number of processors.Dependencies[edit]Understandingdata dependenciesis fundamental in implementingparallel algorithms. No program can run more quickly than the longest chain of dependent calculations (known as thecritical path), since calculations that depend upon prior calculations in the chain must be executed in order. However, most algorithms do not consist of just a long chain of dependent calculations; there are usually opportunities to execute independent calculations in parallel.LetPiandPjbe two program segments. Bernstein's conditions[18]describe when the two are independent and can be executed in parallel. ForPi, letIibe all of the input variables andOithe output variables, and likewise forPj.PiandPjare independent if they satisfyIj∩Oi=∅,{\displaystyle I_{j}\cap O_{i}=\varnothing ,}Ii∩Oj=∅,{\displaystyle I_{i}\cap O_{j}=\varnothing ,}Oi∩Oj=∅.{\displaystyle O_{i}\cap O_{j}=\varnothing .}Violation of the first condition introduces a flow dependency, corresponding to the first segment producing a result used by the second segment. The second condition represents an anti-dependency, when the second segment produces a variable needed by the first segment. The third and final condition represents an output dependency: when two segments write to the same location, the result comes from the logically last executed segment.[19]Consider the following functions, which demonstrate several kinds of dependencies:1: function Dep(a, b)
2: c := a * b
3: d := 3 * c
4: end functionIn this example, instruction 3 cannot be executed before (or even in parallel with) instruction 2, because instruction 3 uses a result from instruction 2. It violates condition 1, and thus introduces a flow dependency.1: function NoDep(a, b)
2: c := a * b
3: d := 3 * b
4: e := a + b
5: end functionIn this example, there are no dependencies between the instructions, so they can all be run in parallel.Bernstein's conditions do not allow memory to be shared between different processes. For that, some means of enforcing an ordering between accesses is necessary, such assemaphores,barriersor some othersynchronization method.Race conditions, mutual exclusion, synchronization, and parallel slowdown[edit]Subtasks in a parallel program are often calledthreads. Some parallel computer architectures use smaller, lightweight versions of threads known asfibers, while others use bigger versions known asprocesses. However, "threads" is generally accepted as a generic term for subtasks.[20]Threads will often needsynchronizedaccess to anobjector otherresource, for example when they must update avariablethat is shared between them. Without synchronization, the instructions between the two threads may be interleaved in any order. For example, consider the following program:Thread AThread B1A: Read variable V1B: Read variable V2A: Add 1 to variable V2B: Add 1 to variable V3A: Write back to variable V3B: Write back to variable VIf instruction 1B is executed between 1A and 3A, or if instruction 1A is executed between 1B and 3B, the program will produce incorrect data. This is known as arace condition. The programmer must use alockto providemutual exclusion. A lock is a programming language construct that allows one thread to take control of a variable and prevent other threads from reading or writing it, until that variable is unlocked. The thread holding the lock is free to execute itscritical section(the section of a program that requires exclusive access to some variable), and to unlock the data when it is finished. Therefore, to guarantee correct program execution, the above program can be rewritten to use locks:Thread AThread B1A: Lock variable V1B: Lock variable V2A: Read variable V2B: Read variable V3A: Add 1 to variable V3B: Add 1 to variable V4A: Write back to variable V4B: Write back to variable V5A: Unlock variable V5B: Unlock variable VOne thread will successfully lock variable V, while the other thread will belocked out—unable to proceed until V is unlocked again. This guarantees correct execution of the program. Locks may be necessary to ensure correct program execution when threads must serialize access to resources, but their use can greatly slow a program and may affect itsreliability.[21]Locking multiple variables usingnon-atomiclocks introduces the possibility of programdeadlock. Anatomic locklocks multiple variables all at once. If it cannot lock all of them, it does not lock any of them. If two threads each need to lock the same two variables using non-atomic locks, it is possible that one thread will lock one of them and the second thread will lock the second variable. In such a case, neither thread can complete, and deadlock results.[22]Many parallel programs require that their subtasksact in synchrony. This requires the use of abarrier. Barriers are typically implemented using a lock or asemaphore.[23]One class of algorithms, known aslock-free and wait-free algorithms, altogether avoids the use of locks and barriers. However, this approach is generally difficult to implement and requires correctly designed data structures.[24]Not all parallelization results in speed-up. Generally, as a task is split up into more and more threads, those threads spend an ever-increasing portion of their time communicating with each other or waiting on each other for access to resources.[25][26]Once the overhead from resource contention or communication dominates the time spent on other computation, further parallelization (that is, splitting the workload over even more threads) increases rather than decreases the amount of time required to finish. This problem, known asparallel slowdown,[27]can be improved in some cases by software analysis and redesign.[28]Fine-grained, coarse-grained, and embarrassing parallelism[edit]Applications are often classified according to how often their subtasks need to synchronize or communicate with each other. An application exhibits fine-grained parallelism if its subtasks must communicate many times per second; it exhibits coarse-grained parallelism if they do not communicate many times per second, and it exhibitsembarrassing parallelismif they rarely or never have to communicate. Embarrassingly parallel applications are considered the easiest to parallelize.Flynn's taxonomy[edit]Main article:Flynn's taxonomyMichael J. Flynncreated one of the earliest classification systems for parallel (and sequential) computers and programs, now known asFlynn's taxonomy. Flynn classified programs and computers by whether they were operating using a single set or multiple sets of instructions, and whether or not those instructions were using a single set or multiple sets of data.Flynn's taxonomySingle data streamSISDMISDMultiple data streamsSIMDMIMDSIMD subcategories[29]Array processing (SIMT)Pipelined processing (packed SIMD)Associative processing (predicated/masked SIMD)See alsoSPMDMPMDThe single-instruction-single-data (SISD) classification is equivalent to an entirely sequential program. The single-instruction-multiple-data (SIMD) classification is analogous to doing the same operation repeatedly over a large data set. This is commonly done insignal processingapplications. Multiple-instruction-single-data (MISD) is a rarely used classification. While computer architectures to deal with this were devised (such assystolic arrays), few applications that fit this class materialized. Multiple-instruction-multiple-data (MIMD) programs are by far the most common type of parallel programs.According toDavid A. PattersonandJohn L. Hennessy, "Some machines are hybrids of these categories, of course, but this classic model has survived because it is simple, easy to understand, and gives a good first approximation. It is also—perhaps because of its understandability—the most widely used scheme."[30]Granularity[edit]Bit-level parallelism[edit]Main article:Bit-level parallelismTaiwania 3 ofTaiwan, a parallel supercomputing device that joinedCOVID-19researchFrom the advent ofvery-large-scale integration(VLSI) computer-chip fabrication technology in the 1970s until about 1986, speed-up in computer architecture was driven by doublingcomputer word size—the amount of information the processor can manipulate per cycle.[31]Increasing the word size reduces the number of instructions the processor must execute to perform an operation on variables whose sizes are greater than the length of the word. For example, where an8-bitprocessor must add two16-bitintegers, the processor must first add the 8 lower-order bits from each integer using the standard addition instruction, then add the 8 higher-order bits using an add-with-carry instruction and thecarry bitfrom the lower order addition; thus, an 8-bit processor requires two instructions to complete a single operation, where a 16-bit processor would be able to complete the operation with a single instruction.Historically,4-bitmicroprocessors were replaced with 8-bit, then 16-bit, then 32-bit microprocessors. This trend generally came to an end with the introduction of 32-bit processors, which has been a standard in general-purpose computing for two decades. Not until the early 2000s, with the advent ofx86-64architectures, did64-bitprocessors become commonplace.Instruction-level parallelism[edit]Main article:Instruction-level parallelismA canonical processor withoutpipeline. It takes five clock cycles to complete one instruction and thus the processor can issue subscalar performance (IPC = 0.2 < 1).A computer program is, in essence, a stream of instructions executed by a processor. Without instruction-level parallelism, a processor can only issue less than oneinstruction per clock cycle(IPC < 1). These processors are known assubscalarprocessors. These instructions can bere-orderedand combined into groups which are then executed in parallel without changing the result of the program. This is known as instruction-level parallelism. Advances in instruction-level parallelism dominated computer architecture from the mid-1980s until the mid-1990s.[32]A canonical five-stagepipelinedprocessor. In the best case scenario, it takes one clock cycle to complete one instruction and thus the processor can issue scalar performance (IPC = 1).All modern processors have multi-stageinstruction pipelines. Each stage in the pipeline corresponds to a different action the processor performs on that instruction in that stage; a processor with anN-stage pipeline can have up toNdifferent instructions at different stages of completion and thus can issue one instruction per clock cycle (IPC = 1). These processors are known asscalarprocessors. The canonical example of a pipelined processor is aRISCprocessor, with five stages: instruction fetch (IF), instruction decode (ID), execute (EX), memory access (MEM), and register write back (WB). ThePentium 4processor had a 35-stage pipeline.[33]A canonical five-stagepipelinedprocessor with two execution units. In the best case scenario, it takes one clock cycle to complete two instructions and thus the processor can issue superscalar performance (IPC = 2 > 1).Most modern processors also have multipleexecution units. They usually combine this feature with pipelining and thus can issue more than one instruction per clock cycle (IPC > 1). These processors are known assuperscalarprocessors. Superscalar processors differ frommulti-core processorsin that the several execution units are not entire processors (i.e. processing units). Instructions can be grouped together only if there is nodata dependencybetween them.Scoreboardingand theTomasulo algorithm(which is similar to scoreboarding but makes use ofregister renaming) are two of the most common techniques for implementing out-of-order execution and instruction-level parallelism.Task parallelism[edit]Main article:Task parallelismTask parallelisms is the characteristic of a parallel program that "entirely different calculations can be performed on either the same or different sets of data".[34]This contrasts with data parallelism, where the same calculation is performed on the same or different sets of data. Task parallelism involves the decomposition of a task into sub-tasks and then allocating each sub-task to a processor for execution. The processors would then execute these sub-tasks concurrently and often cooperatively. Task parallelism does not usually scale with the size of a problem.[35]Superword level parallelism[edit]Superword level parallelism is avectorizationtechnique based onloop unrollingand basic block vectorization. It is distinct from loop vectorization algorithms in that it can exploitparallelismofinline code, such as manipulating coordinates, color channels or in loops unrolled by hand.[36]Hardware[edit]Memory and communication[edit]Main memory in a parallel computer is eithershared memory(shared between all processing elements in a singleaddress space), ordistributed memory(in which each processing element has its own local address space).[37]Distributed memory refers to the fact that the memory is logically distributed, but often implies that it is physically distributed as well.Distributed shared memoryandmemory virtualizationcombine the two approaches, where the processing element has its own local memory and access to the memory on non-local processors. Accesses to local memory are typically faster than accesses to non-local memory. On thesupercomputers, distributed shared memory space can be implemented using the programming model such asPGAS.  This model allows processes on one compute node to transparently access the remote memory of another compute node. All compute nodes are also connected to an external shared memory system via high-speed interconnect, such asInfiniband, this external shared memory system is known asburst buffer, which is typically built from arrays ofnon-volatile memoryphysically distributed across multiple I/O nodes.A logical view of anon-uniform memory access(NUMA) architecture. Processors in one directory can access that directory's memory with less latency than they can access memory in the other directory's memory.Computer architectures in which each element of main memory can be accessed with equallatencyandbandwidthare known asuniform memory access(UMA) systems. Typically, that can be achieved only by ashared memorysystem, in which the memory is not physically distributed. A system that does not have this property is known as anon-uniform memory access(NUMA) architecture. Distributed memory systems have non-uniform memory access.Computer systems make use ofcaches—small and fast memories located close to the processor which store temporary copies of memory values (nearby in both the physical and logical sense). Parallel computer systems have difficulties with caches that may store the same value in more than one location, with the possibility of incorrect program execution. These computers require acache coherencysystem, which keeps track of cached values and strategically purges them, thus ensuring correct program execution.Bus snoopingis one of the most common methods for keeping track of which values are being accessed (and thus should be purged). Designing large, high-performance cache coherence systems is a very difficult problem in computer architecture. As a result, shared memory computer architectures do not scale as well as distributed memory systems do.[37]Processor–processor and processor–memory communication can be implemented in hardware in several ways, including via shared (either multiported ormultiplexed) memory, acrossbar switch, a sharedbusor an interconnect network of a myriad oftopologiesincludingstar,ring,tree,hypercube, fat hypercube (a hypercube with more than one processor at a node), orn-dimensional mesh.Parallel computers based on interconnected networks need to have some kind ofroutingto enable the passing of messages between nodes that are not directly connected. The medium used for communication between the processors is likely to be hierarchical in large multiprocessor machines.Classes of parallel computers[edit]Parallel computers can be roughly classified according to the level at which the hardware supports parallelism. This classification is broadly analogous to the distance between basic computing nodes. These are not mutually exclusive; for example, clusters of symmetric multiprocessors are relatively common.Multi-core computing[edit]Main article:Multi-core processorA multi-core processor is a processor that includes multipleprocessing units(called "cores") on the same chip. This processor differs from asuperscalarprocessor, which includes multipleexecution unitsand can issue multiple instructions per clock cycle from one instruction stream (thread); in contrast, a multi-core processor can issue multiple instructions per clock cycle from multiple instruction streams.IBM'sCell microprocessor, designed for use in theSonyPlayStation 3, is a prominent multi-core processor. Each core in a multi-core processor can potentially be superscalar as well—that is, on every clock cycle, each core can issue multiple instructions from one thread.Simultaneous multithreading(of which Intel'sHyper-Threadingis the best known) was an early form of pseudo-multi-coreism. A processor capable of concurrent multithreading includes multiple execution units in the same processing unit—that is it has a superscalar architecture—and can issue multiple instructions per clock cycle frommultiplethreads.Temporal multithreadingon the other hand includes a single execution unit in the same processing unit and can issue one instruction at a time frommultiplethreads.Symmetric multiprocessing[edit]Main article:Symmetric multiprocessingA symmetric multiprocessor (SMP) is a computer system with multiple identical processors that share memory and connect via abus.[38]Bus contentionprevents bus architectures from scaling. As a result, SMPs generally do not comprise more than 32 processors.[39]Because of the small size of the processors and the significant reduction in the requirements for bus bandwidth achieved by large caches, such symmetric multiprocessors are extremely cost-effective, provided that a sufficient amount of memory bandwidth exists.[38]Distributed computing[edit]Main article:Distributed computingA distributed computer (also known as a distributed memory multiprocessor) is a distributed memory computer system in which the processing elements are connected by a network. Distributed computers are highly scalable. The terms "concurrent computing", "parallel computing", and "distributed computing" have a lot of overlap, and no clear distinction exists between them.[40]The same system may be characterized both as "parallel" and "distributed"; the processors in a typical distributed system run concurrently in parallel.[41]Cluster computing[edit]Main article:Computer clusterABeowulf clusterA cluster is a group of loosely coupled computers that work together closely, so that in some respects they can be regarded as a single computer.[42]Clusters are composed of multiple standalone machines connected by a network. While machines in a cluster do not have to be symmetric,load balancingis more difficult if they are not. The most common type of cluster is theBeowulf cluster, which is a cluster implemented on multiple identicalcommercial off-the-shelfcomputers connected with aTCP/IPEthernetlocal area network.[43]Beowulf technology was originally developed byThomas SterlingandDonald Becker. 87% of allTop500supercomputers are clusters.[44]The remaining are Massively Parallel Processors, explained below.Because grid computing systems (described below) can easily handle embarrassingly parallel problems, modern clusters are typically designed to handle more difficult problems—problems that require nodes to share intermediate results with each other more often. This requires a high bandwidth and, more importantly, a low-latencyinterconnection network. Many historic and current supercomputers use customized high-performance network hardware specifically designed for cluster computing, such as the Cray Gemini network.[45]As of 2014, most current supercomputers use some off-the-shelf standard network hardware, oftenMyrinet,InfiniBand, orGigabit Ethernet.Massively parallel computing[edit]Main article:Massively parallel (computing)A cabinet fromIBM'sBlue Gene/Lmassively parallelsupercomputerA massively parallel processor (MPP) is a single computer with many networked processors. MPPs have many of the same characteristics as clusters, but MPPs have specialized interconnect networks (whereas clusters use commodity hardware for networking). MPPs also tend to be larger than clusters, typically having "far more" than 100 processors.[46]In an MPP, "each CPU contains its own memory and copy of the operating system and application. Each subsystem communicates with the others via a high-speed interconnect."[47]IBM'sBlue Gene/L, the fifth fastestsupercomputerin the world according to the June 2009TOP500ranking, is an MPP.Grid computing[edit]Main article:Grid computingGrid computing is the most distributed form of parallel computing. It makes use of computers communicating over theInternetto work on a given problem. Because of the low bandwidth and extremely high latency available on the Internet, distributed computing typically deals only withembarrassingly parallelproblems.Most grid computing applications usemiddleware(software that sits between the operating system and the application to manage network resources and standardize the software interface). The most common grid computing middleware is theBerkeley Open Infrastructure for Network Computing(BOINC). Oftenvolunteer computingsoftware makes use of "spare cycles", performing computations at times when a computer is idling.[48]Cloud computing[edit]Main article:Cloud computingThe ubiquity of Internet brought the possibility of large-scale cloud computing.Specialized parallel computers[edit]Within parallel computing, there are specialized parallel devices that remain niche areas of interest. While notdomain-specific, they tend to be applicable to only a few classes of parallel problems.Reconfigurable computing with field-programmable gate arrays[edit]Reconfigurable computingis the use of afield-programmable gate array(FPGA) as a co-processor to a general-purpose computer. An FPGA is, in essence, a computer chip that can rewire itself for a given task.FPGAs can be programmed withhardware description languagessuch asVHDL[49]orVerilog.[50]Several vendors have createdC to HDLlanguages that attempt to emulate the syntax and semantics of theC programming language, with which most programmers are familiar. The best known C to HDL languages areMitrion-C,Impulse C, andHandel-C. Specific subsets ofSystemCbased on C++ can also be used for this purpose.AMD's decision to open itsHyperTransporttechnology to third-party vendors has become the enabling technology for high-performance reconfigurable computing.[51]According to Michael R. D'Amour, Chief Operating Officer of DRC Computer Corporation, "when we first walked into AMD, they called us 'thesocketstealers.' Now they call us their partners."[51]General-purpose computing on graphics processing units (GPGPU)[edit]Main article:GPGPUNvidia'sTesla GPGPU cardGeneral-purpose computing ongraphics processing units(GPGPU) is a fairly recent trend in computer engineering research. GPUs are co-processors that have been heavily optimized forcomputer graphicsprocessing.[52]Computer graphics processing is a field dominated by data parallel operations—particularlylinear algebramatrixoperations.In the early days, GPGPU programs used the normal graphics APIs for executing programs. However, several new programming languages and platforms have been built to do general purpose computation on GPUs with bothNvidiaandAMDreleasing programming environments withCUDAandStream SDKrespectively. Other GPU programming languages includeBrookGPU,PeakStream, andRapidMind. Nvidia has also released specific products for computation in theirTesla series. The technology consortium Khronos Group has released theOpenCLspecification, which is a framework for writing programs that execute across platforms consisting of CPUs and GPUs.AMD,Apple,Intel,Nvidiaand others are supportingOpenCL.Application-specific integrated circuits[edit]Main article:Application-specific integrated circuitSeveralapplication-specific integrated circuit(ASIC) approaches have been devised for dealing with parallel applications.[53][54][55]Because an ASIC is (by definition) specific to a given application, it can be fully optimized for that application. As a result, for a given application, an ASIC tends to outperform a general-purpose computer. However, ASICs are created byUV photolithography. This process requires a mask set, which can be extremely expensive. A mask set can cost over a million US dollars.[56](The smaller the transistors required for the chip, the more expensive the mask will be.) Meanwhile, performance increases in general-purpose computing over time (as described byMoore's law) tend to wipe out these gains in only one or two chip generations.[51]High initial cost, and the tendency to be overtaken by Moore's-law-driven general-purpose computing, has rendered ASICs unfeasible for most parallel computing applications. However, some have been built. One example is the PFLOPSRIKEN MDGRAPE-3machine which uses custom ASICs formolecular dynamicssimulation.Vector processors[edit]Main article:Vector processorTheCray-1is a vector processor.A vector processor is a CPU or computer system that can execute the same instruction on large sets of data. Vector processors have high-level operations that work on linear arrays of numbers or vectors. An example vector operation isA=B×C, whereA,B, andCare each 64-element vectors of 64-bitfloating-pointnumbers.[57]They are closely related to Flynn's SIMD classification.[57]Craycomputers became famous for their vector-processing computers in the 1970s and 1980s. However, vector processors—both as CPUs and as full computer systems—have generally disappeared. Modernprocessor instruction setsdo include some vector processing instructions, such as withFreescale Semiconductor'sAltiVecandIntel'sStreaming SIMD Extensions(SSE).Software[edit]Parallel programming languages[edit]Main article:List of concurrent and parallel programming languagesConcurrent programming languages,libraries,APIs, andparallel programming models(such asalgorithmic skeletons) have been created for programming parallel computers. These can generally be divided into classes based on the assumptions they make about the underlying memory architecture—shared memory, distributed memory, or shared distributed memory. Shared memory programming languages communicate by manipulating shared memory variables. Distributed memory usesmessage passing.POSIX ThreadsandOpenMPare two of the most widely used shared memory APIs, whereasMessage Passing Interface(MPI) is the most widely used message-passing system API.[58]One concept used in programming parallel programs is thefuture concept, where one part of a program promises to deliver a required datum to another part of a program at some future time.Efforts to standardize parallel programming include an open standard calledOpenHMPPfor hybrid multi-core parallel programming. The OpenHMPP directive-based programming model offers a syntax to efficiently offload computations on hardware accelerators and to optimize data movement to/from the hardware memory usingremote procedure calls.The rise of consumer GPUs has led to support forcompute kernels, either in graphics  APIs (referred to ascompute shaders), in dedicated APIs (such asOpenCL), or in other language extensions.Automatic parallelization[edit]Main article:Automatic parallelizationAutomatic parallelizationof a sequential program by acompileris the "holy grail" of parallel computing, especially with the aforementioned limit of processor frequency. Despite decades of work by compiler researchers, automatic parallelization has had only limited success.[59]Mainstream parallel programming languages remain eitherexplicitly parallelor (at best)partially implicit, in which a programmer gives the compilerdirectivesfor parallelization. A few fully implicit parallel programming languages exist—SISAL, ParallelHaskell,SequenceL,System C(forFPGAs),Mitrion-C,VHDL, andVerilog.Application checkpointing[edit]Main article:Application checkpointingAs a computer system grows in complexity, themean time between failuresusually decreases.Application checkpointingis a technique whereby the computer system takes a "snapshot" of the application—a record of all current resource allocations and variable states, akin to acore dump—; this information can be used to restore the program if the computer should fail. Application checkpointing means that the program has to restart from only its last checkpoint rather than the beginning. While checkpointing provides benefits in a variety of situations, it is especially useful in highly parallel systems with a large number of processors used inhigh performance computing.[60]Algorithmic methods[edit]As parallel computers become larger and faster, we are now able to solve problems that had previously taken too long to run. Fields as varied asbioinformatics(forprotein foldingandsequence analysis) and economics have taken advantage of parallel computing. Common types of problems in parallel computing applications include:[61]Denselinear algebraSparse linear algebraSpectral methods (such asCooley–Tukey fast Fourier transform)N-body problems(such asBarnes–Hut simulation)Structured gridproblems (such asLattice Boltzmann methods)Unstructured gridproblems (such as found infinite element analysis)Monte Carlo methodCombinational logic(such asbrute-force cryptographic techniques)Graph traversal(such assorting algorithms)Dynamic programmingBranch and boundmethodsGraphical models(such as detectinghidden Markov modelsand constructingBayesian networks)HBJ model, a concise message-passing model[62]Finite-state machinesimulationFault tolerance[edit]Further information:Fault-tolerant computer systemParallel computing can also be applied to the design offault-tolerant computer systems, particularly vialockstepsystems performing the same operation in parallel. This providesredundancyin case one component fails, and also allows automaticerror detectionanderror correctionif the results differ. These methods can be used to help prevent single-event upsets caused by transient errors.[63]Although additional measures may be required in embedded or specialized systems, this method can provide a cost-effective approach to achieve n-modular redundancy in commercial off-the-shelf systems.History[edit]For broader coverage of this topic, seeHistory of computing.ILLIAC IV, "the most infamous of supercomputers"[64]The origins of true (MIMD) parallelism go back toLuigi Federico Menabreaand hisSketch of theAnalytic EngineInvented byCharles Babbage.[65][66][67]In 1957,Compagnie des Machines Bullannounced the first computer architecture specifically designed for parallelism, theGamma 60.[68]It utilized afork-join modeland a "Program Distributor" to dispatch and collect data to and from independent processing units connected to a central memory.[69][70]In April 1958, Stanley Gill (Ferranti) discussed parallel programming and the need for branching and waiting.[71]Also in 1958, IBM researchersJohn CockeandDaniel Slotnickdiscussed the use of parallelism in numerical calculations for the first time.[72]Burroughs Corporationintroduced the D825 in 1962, a four-processor computer that accessed up to 16 memory modules through acrossbar switch.[73]In 1967, Amdahl and Slotnick published a debate about the feasibility of parallel processing at American Federation of Information Processing Societies Conference.[72]It was during this debate thatAmdahl's lawwas coined to define the limit of speed-up due to parallelism.In 1969,Honeywellintroduced its firstMulticssystem, a symmetric multiprocessor system capable of running up to eight processors in parallel.[72]C.mmp, a multi-processor project atCarnegie Mellon Universityin the 1970s, was among the first multiprocessors with more than a few processors. The first bus-connected multiprocessor with snooping caches was the Synapse N+1 in 1984.[66]SIMD parallel computers can be traced back to the 1970s. The motivation behind early SIMD computers was to amortize thegate delayof the processor'scontrol unitover multiple instructions.[74]In 1964, Slotnick had proposed building a massively parallel computer for theLawrence Livermore National Laboratory.[72]His design was funded by theUS Air Force, which was the earliest SIMD parallel-computing effort,ILLIAC IV.[72]The key to its design was a fairly high parallelism, with up to 256 processors, which allowed the machine to work on large datasets in what would later be known asvector processing. However, ILLIAC IV was called "the most infamous of supercomputers", because the project was only one-fourth completed, but took 11 years and cost almost four times the original estimate.[64]When it was finally ready to run its first real application in 1976, it was outperformed by existing commercial supercomputers such as theCray-1.Biological brain as massively parallel computer[edit]In the early 1970s, at theMIT Computer Science and Artificial Intelligence Laboratory,Marvin MinskyandSeymour Papertstarted developing theSociety of Mindtheory, which views the biological brain asmassively parallel computer. In 1986, Minsky publishedThe Society of Mind, which claims that "mind is formed from many little agents, each mindless by itself".[75]The theory attempts to explain how what we call intelligence could be a product of the interaction of non-intelligent parts. Minsky says that the biggest source of ideas about the theory came from his work in trying to create a machine that uses a robotic arm, a video camera, and a computer to build with children's blocks.[76]Similar models (which also view the biological brain as a massively parallel computer, i.e., the brain is made up of a constellation of independent or semi-independent agents) were also described by:Thomas R. Blakeslee,[77]Michael S. Gazzaniga,[78][79]Robert E. Ornstein,[80]Ernest Hilgard,[81][82]Michio Kaku,[83]George Ivanovich Gurdjieff,[84]Neurocluster Brain Model.[85]See also[edit]Computer multitaskingConcurrency (computer science)Content Addressable Parallel ProcessorList of distributed computing conferencesLoop-level parallelismManchester dataflow machineManycoreParallel programming modelParallelization contractSerializabilitySynchronous programmingTransputerVector processingReferences[edit]^Gottlieb, Allan; Almasi, George S. (1989).Highly parallel computing. Redwood City, Calif.: Benjamin/Cummings.ISBN978-0-8053-0177-9.^S.V. Adveet al.(November 2008)."Parallel Computing Research at Illinois: The UPCRC Agenda"Archived2018-01-11 at theWayback Machine(PDF). Parallel@Illinois, University of Illinois at Urbana-Champaign. "The main techniques for these performance benefits—increased clock frequency and smarter but increasingly complex architectures—are now hitting the so-called power wall. Thecomputer industryhas accepted that future performance increases must largely come from increasing the number of processors (or cores) on a die, rather than making a single core go faster."^Asanovicet al.Old [conventional wisdom]: Power is free, buttransistorsare expensive. New [conventional wisdom] is [that] power is expensive, but transistors are "free".^Asanovic, Krsteet al.(December 18, 2006)."The Landscape of Parallel Computing Research: A View from Berkeley"(PDF). University of California, Berkeley. Technical Report No. UCB/EECS-2006-183. "Old [conventional wisdom]: Increasing clock frequency is the primary method of improving processor performance. New [conventional wisdom]: Increasing parallelism is the primary method of improving processor performance… Even representatives from Intel, a company generally associated with the 'higher clock-speed is better' position, warned that traditional approaches to maximizing performance through maximizing clock speed have been pushed to their limits."^Parallel and Concurrent Programming in Haskell. O'Reilly Media. 2013.ISBN9781449335922.^Hennessy, John L.;Patterson, David A.;Larus, James R.(1999).Computer organization and design: the hardware/software interface(2. ed., 3rd print. ed.). San Francisco: Kaufmann.ISBN978-1-55860-428-5.^abBarney, Blaise."Introduction to Parallel Computing". Lawrence Livermore National Laboratory. Retrieved2007-11-09.^Thomas Rauber; Gudula Rünger (2013).Parallel Programming: for Multicore and Cluster Systems. Springer Science & Business Media. p. 1.ISBN9783642378010.^Hennessy, John L.; Patterson, David A. (2002).Computer architecture / a quantitative approach(3rd ed.). San Francisco, Calif.: International Thomson. p. 43.ISBN978-1-55860-724-8.^Rabaey, Jan M. (1996).Digital integrated circuits : a design perspective. Upper Saddle River, N.J.: Prentice-Hall. p. 235.ISBN978-0-13-178609-7.^Flynn, Laurie J. (8 May 2004)."Intel Halts Development Of 2 New Microprocessors".New York Times. Retrieved5 June2012.^Thomas Rauber; Gudula Rünger (2013).Parallel Programming: for Multicore and Cluster Systems. Springer Science & Business Media. p. 2.ISBN9783642378010.^Thomas Rauber; Gudula Rünger (2013).Parallel Programming: for Multicore and Cluster Systems. Springer Science & Business Media. p. 3.ISBN9783642378010.^Amdahl, Gene M. (1967)."Validity of the single processor approach to achieving large scale computing capabilities".Proceedings of the April 18-20, 1967, spring joint computer conference on - AFIPS '67 (Spring). pp. 483–485.doi:10.1145/1465482.1465560.ISBN9780805301779.S2CID195607370.^Brooks, Frederick P. (1996).The mythical man month essays on software engineering(Anniversary ed., repr. with corr., 5. [Dr.] ed.). Reading, Mass. [u.a.]: Addison-Wesley.ISBN978-0-201-83595-3.^Michael McCool; James Reinders; Arch Robison (2013).Structured Parallel Programming: Patterns for Efficient Computation. Elsevier. p. 61.^Gustafson, John L. (May 1988)."Reevaluating Amdahl's law".Communications of the ACM.31(5): 532–533.CiteSeerX10.1.1.509.6892.doi:10.1145/42411.42415.S2CID33937392. Archived fromthe originalon 2007-09-27.^Bernstein, A. J. (1 October 1966). "Analysis of Programs for Parallel Processing".IEEE Transactions on Electronic Computers. EC-15 (5): 757–763.doi:10.1109/PGEC.1966.264565.^Roosta, Seyed H. (2000).Parallel processing and parallel algorithms : theory and computation. New York, NY [u.a.]: Springer. p. 114.ISBN978-0-387-98716-3.^"Processes and Threads".Microsoft Developer Network. Microsoft Corp. 2018. Retrieved2018-05-10.^Krauss, Kirk J (2018)."Thread Safety for Performance".Develop for Performance. Archived fromthe originalon 2018-05-13. Retrieved2018-05-10.^Tanenbaum, Andrew S. (2002-02-01).Introduction to Operating System Deadlocks. Pearson Education, Informit. Retrieved2018-05-10.{{cite book}}:|website=ignored (help)^Cecil, David (2015-11-03)."Synchronization internals – the semaphore".Embedded. AspenCore. Retrieved2018-05-10.^Preshing, Jeff (2012-06-08)."An Introduction to Lock-Free Programming".Preshing on Programming. Retrieved2018-05-10.^"What's the opposite of "embarrassingly parallel"?".StackOverflow. Retrieved2018-05-10.^Schwartz, David (2011-08-15)."What is thread contention?".StackOverflow. Retrieved2018-05-10.^Kukanov, Alexey (2008-03-04)."Why a simple test can get parallel slowdown". Retrieved2015-02-15.^Krauss, Kirk J (2018)."Threading for Performance".Develop for Performance. Archived fromthe originalon 2018-05-13. Retrieved2018-05-10.^Flynn, Michael J.(September 1972)."Some Computer Organizations and Their Effectiveness"(PDF).IEEE Transactions on Computers.C-21(9): 948–960.doi:10.1109/TC.1972.5009071.^Patterson and Hennessy, p. 748.^Singh, David Culler; J.P. (1997).Parallel computer architecture([Nachdr.] ed.). San Francisco: Morgan Kaufmann Publ. p. 15.ISBN978-1-55860-343-1.{{cite book}}:  CS1 maint: multiple names: authors list (link)^Culler et al. p. 15.^Patt, Yale(April 2004). "The Microprocessor Ten Years From Now: What Are The Challenges, How Do We Meet Them?Archived2008-04-14 at theWayback Machine(wmv). Distinguished Lecturer talk atCarnegie Mellon University. Retrieved on November 7, 2007.^Culler et al. p. 124.^Culler et al. p. 125.^Samuel Larsen; Saman Amarasinghe."Exploiting Superword Level Parallelism with Multimedia Instruction Sets"(PDF).^abPatterson and Hennessy, p. 713.^abHennessy and Patterson, p. 549.^Patterson and Hennessy, p. 714.^Ghosh (2007), p. 10.Keidar (2008).^Lynch (1996), p. xix, 1–2.Peleg (2000), p. 1.^What is clustering?Webopedia computer dictionary. Retrieved on November 7, 2007.^Beowulf definition.Archived2012-10-10 at theWayback MachinePC Magazine. Retrieved on November 7, 2007.^"List Statistics | TOP500 Supercomputer Sites".www.top500.org. Retrieved2018-08-05.^"Interconnect"Archived2015-01-28 at theWayback Machine.^Hennessy and Patterson, p. 537.^MPP Definition.Archived2013-05-11 at theWayback MachinePC Magazine. Retrieved on November 7, 2007.^Kirkpatrick, Scott (2003). "COMPUTER SCIENCE: Rough Times Ahead".Science.299(5607): 668–669.doi:10.1126/science.1081623.PMID12560537.S2CID60622095.^Valueva, Maria; Valuev, Georgii; Semyonova, Nataliya; Lyakhov, Pavel; Chervyakov, Nikolay; Kaplun, Dmitry; Bogaevskiy, Danil (2019-06-20)."Construction of Residue Number System Using Hardware Efficient Diagonal Function".Electronics.8(6): 694.doi:10.3390/electronics8060694.ISSN2079-9292.All simulated circuits were described in very high speed integrated circuit (VHSIC) hardware description language (VHDL). Hardware modeling was performed on Xilinx FPGA Artix 7 xc7a200tfbg484-2.^Gupta, Ankit; Suneja, Kriti (May 2020)."Hardware Design of Approximate Matrix Multiplier based on FPGA in Verilog".2020 4th International Conference on Intelligent Computing and Control Systems (ICICCS). Madurai, India: IEEE. pp. 496–498.doi:10.1109/ICICCS48265.2020.9121004.ISBN978-1-7281-4876-2.S2CID219990653.^abcD'Amour, Michael R., Chief Operating Officer, DRC Computer Corporation. "Standard Reconfigurable Computing". Invited speaker at the University of Delaware, February 28, 2007.^Boggan, Sha'Kia and Daniel M. Pressel (August 2007).GPUs: An Emerging Platform for General-Purpose ComputationArchived2016-12-25 at theWayback Machine(PDF). ARL-SR-154, U.S. Army Research Lab. Retrieved on November 7, 2007.^Maslennikov, Oleg (2002)."Systematic Generation of Executing Programs for Processor Elements in Parallel ASIC or FPGA-Based Systems and Their Transformation into VHDL-Descriptions of Processor Element Control Units".Lecture Notes in Computer Science,2328/2002:p. 272.^Shimokawa, Y.; Fuwa, Y.; Aramaki, N. (18–21 November 1991). "A parallel ASIC VLSI neurocomputer for a large number of neurons and billion connections per second speed".[Proceedings] 1991 IEEE International Joint Conference on Neural Networks. Vol. 3. pp. 2162–2167.doi:10.1109/IJCNN.1991.170708.ISBN978-0-7803-0227-3.S2CID61094111.^Acken, Kevin P.; Irwin, Mary Jane; Owens, Robert M. (July 1998). "A Parallel ASIC Architecture for Efficient Fractal Image Coding".The Journal of VLSI Signal Processing.19(2): 97–113.Bibcode:1998JSPSy..19...97A.doi:10.1023/A:1008005616596.S2CID2976028.^Kahng, Andrew B. (June 21, 2004) "Scoping the Problem of DFM in the Semiconductor IndustryArchived2008-01-31 at theWayback Machine." University of California, San Diego. "Future design for manufacturing (DFM) technology must reduce design [non-recoverable expenditure] cost and directly address manufacturing [non-recoverable expenditures]—the cost of a mask set and probe card—which is well over $1 million at the 90 nm technology node and creates a significant damper on semiconductor-based innovation."^abPatterson and Hennessy, p. 751.^TheSidney Fernbach Award given to MPI inventor Bill GroppArchived2011-07-25 at theWayback Machinerefers to MPI as "the dominant HPC communications interface"^Shen, John Paul; Mikko H. Lipasti (2004).Modern processor design : fundamentals of superscalar processors(1st ed.). Dubuque, Iowa: McGraw-Hill. p. 561.ISBN978-0-07-057064-1.However, the holy grail of such research—automated parallelization of serial programs—has yet to materialize. While automated parallelization of certain classes of algorithms has been demonstrated, such success has largely been limited to scientific and numeric applications with predictable flow control (e.g., nested loop structures with statically determined iteration counts) and statically analyzable memory access patterns. (e.g., walks over large multidimensional arrays of float-point data).^Encyclopedia of Parallel Computing, Volume 4by David Padua 2011ISBN0387097651page 265^Asanovic, Krste, et al. (December 18, 2006)."The Landscape of Parallel Computing Research: A View from Berkeley"(PDF). University of California, Berkeley. Technical Report No. UCB/EECS-2006-183. See table on pages 17–19.^David R., Helman; David A., Bader; JaJa, Joseph (1998)."A Randomized Parallel Sorting Algorithm with an Experimental Study"(PDF).Journal of Parallel and Distributed Computing.52: 1–23.doi:10.1006/jpdc.1998.1462.hdl:1903/835. Archived fromthe original(PDF)on 19 November 2012. Retrieved26 October2012.^Dobel, B., Hartig, H., & Engel, M. (2012) "Operating system support for redundant multithreading".Proceedings of the Tenth ACM International Conference on Embedded Software, 83–92.doi:10.1145/2380356.2380375^abPatterson and Hennessy, pp. 749–50: "Although successful in pushing several technologies useful in later projects, the ILLIAC IV failed as a computer. Costs escalated from the $8 million estimated in 1966 to $31 million by 1972, despite the construction of only a quarter of the planned machine . It was perhaps the most infamous of supercomputers. The project started in 1965 and ran its first real application in 1976."^Menabrea, L. F.(1842).Sketch of the Analytic Engine Invented by Charles Babbage. Bibliothèque Universelle de Genève. Retrieved on November 7, 2007.
quote: "when a long series of identical computations is to be performed, such as those required for the formation of numerical tables, the machine can be brought into play so as to give several results at the same time, which will greatly abridge the whole amount of the processes."^abPatterson and Hennessy, p. 753.^R.W. Hockney, C.R. Jesshope.Parallel Computers 2: Architecture, Programming and Algorithms, Volume 2. 1988. p. 8 quote: "The earliest reference to parallelism in computer design is thought to be in General L. F. Menabrea's publication in… 1842, entitledSketch of the Analytical Engine Invented by Charles Babbage".^Bataille, M. (1972-04-01)."Something old: the Gamma 60 the computer that was ahead of its time".ACM SIGARCH Computer Architecture News.1(2): 10–15.doi:10.1145/641276.641278.ISSN0163-5964.S2CID34642285.^"Architecture Sketch of Bull Gamma 60 -- Mark Smotherman".www.feb-patrimoine.com. Retrieved2023-08-14.^Tumlin, Smotherman (2023-08-14)."An Evaluation of the Design of the Gamma 60".ACONIT Computer History Museum. Department of Computer Science, Clemson University. Retrieved2023-08-14.^"Parallel Programming", S. Gill,The Computer JournalVol. 1 #1, pp2-10, British Computer Society, April 1958.^abcdeWilson, Gregory V. (1994)."The History of the Development of Parallel Computing". Virginia Tech/Norfolk State University, Interactive Learning with a Digital Library in Computer Science. Retrieved2008-01-08.^Anthes, Gry (November 19, 2001)."The Power of Parallelism".Computerworld. Archived fromthe originalon January 31, 2008. Retrieved2008-01-08.^Patterson and Hennessy, p. 749.^Minsky, Marvin (1986).The Society of Mind. New York: Simon & Schuster. pp.17.ISBN978-0-671-60740-1.^Minsky, Marvin (1986).The Society of Mind. New York: Simon & Schuster. pp.29.ISBN978-0-671-60740-1.^Blakeslee, Thomas (1996).Beyond the Conscious Mind. Unlocking the Secrets of the Self. Springer. pp.6–7.ISBN9780306452628.^Gazzaniga, Michael;LeDoux, Joseph(1978).The Integrated Mind. pp. 132–161.^Gazzaniga, Michael(1985).The Social Brain. Discovering the Networks of the Mind. Basic Books. pp.77–79.ISBN9780465078509.^Ornstein, Robert(1992).Evolution of Consciousness: The Origins of the Way We Think. pp.2.^Hilgard, Ernest(1977).Divided consciousness: multiple controls in human thought and action. New York: Wiley.ISBN978-0-471-39602-4.^Hilgard, Ernest(1986).Divided consciousness: multiple controls in human thought and action (expanded edition). New York: Wiley.ISBN978-0-471-80572-4.^Kaku, Michio(2014).The Future of the Mind.^Ouspenskii, Pyotr(1992). "Chapter 3".In Search of the Miraculous. Fragments of an Unknown Teaching. pp. 72–83.^"Official Neurocluster Brain Model site". RetrievedJuly 22,2017.Further reading[edit]Rodriguez, C.; Villagra, M.; Baran, B. (29 August 2008). "Asynchronous team algorithms for Boolean Satisfiability".Bio-Inspired Models of Network, Information and Computing Systems, 2007. Bionetics 2007. 2nd: 66–69.doi:10.1109/BIMNICS.2007.4610083.S2CID15185219.Sechin, A.; Parallel Computing in Photogrammetry. GIM International. #1, 2016, pp. 21–23.External links[edit]Listen to this article(54minutes)This audio filewas created from a revision of this article dated 21 August 2013(2013-08-21), and does not reflect subsequent edits.(Audio help·More spoken articles)Wikibooks has a book on the topic of:Distributed SystemsLawrence Livermore National Laboratory: Introduction to Parallel ComputingDesigning and Building Parallel Programs, by Ian FosterInternet Parallel Computing ArchivevteParallel computingGeneralDistributed computingParallel computingMassively parallelCloud computingHigh-performance computingMultiprocessingManycore processorGPGPUComputer networkSystolic arrayLevelsBitInstructionThreadTaskDataMemoryLoopPipelineMultithreadingTemporalSimultaneous(SMT)Simultaneous and heterogenousSpeculative(SpMT)PreemptiveCooperativeClustered multi-thread(CMT)Hardware scoutTheoryPRAM modelPEM modelAnalysis of parallel algorithmsAmdahl's lawGustafson's lawCost efficiencyKarp–Flatt metricSlowdownSpeedupElementsProcessThreadFiberInstruction windowArrayCoordinationMultiprocessingMemory coherenceCache coherenceCache invalidationBarrierSynchronizationApplication checkpointingProgrammingStream processingDataflow programmingModelsImplicit parallelismExplicit parallelismConcurrencyNon-blocking algorithmHardwareFlynn's taxonomySISDSIMDArray processing(SIMT)Pipelined processingAssociative processingMISDMIMDDataflow architecturePipelined processorSuperscalar processorVector processorMultiprocessorsymmetricasymmetricMemoryshareddistributeddistributed sharedUMANUMACOMAMassively parallelcomputerComputer clusterBeowulf clusterGrid computerHardware accelerationAPIsAteji PXBoostChapelHPXCharm++CilkCoarray FortranCUDADryadC++ AMPGlobal ArraysGPUOpenMPIOpenMPOpenCLOpenHMPPOpenACCParallel ExtensionsPVMpthreadsRaftLibROCmUPCTBBZPLProblemsAutomatic parallelizationDeadlockDeterministic algorithmEmbarrassingly parallelParallel slowdownRace conditionSoftware lockoutScalabilityStarvationCategory: Parallel computingvteProgramming paradigms(Comparison by language)ImperativeStructuredJackson structuresBlock-structuredModularNon-structuredProceduralProgramming in the large and in the smallDesign by contractInvariant-basedNested functionObject-oriented(comparison,list)Class-based,Prototype-based,Object-basedAgentImmutable objectPersistentUniform Function Call SyntaxDeclarativeFunctional(comparison)RecursiveAnonymous function(Partial application)Higher-orderPurely functionalTotalStrictGADTsDependent typesFunctional logicPoint-free styleExpression-orientedApplicative,ConcatenativeFunction-level,Value-levelDataflowFlow-basedReactive(Functional reactive)SignalsStreamsSynchronousLogicAbductive logicAnswer setConstraint(Constraint logic)Inductive logicNondeterministicOntologyProbabilistic logicQueryDSLAlgebraic modelingArrayAutomata-based(Action)Command(Spacecraft)DifferentiableEnd-userGrammar-orientedInterface descriptionLanguage-orientedList comprehensionLow-codeModelingNatural languageNon-English-basedPage descriptionPipesandfiltersProbabilisticQuantumScientificScriptingSet-theoreticSimulationStack-basedSystemTactileTemplatingTransformation(Graph rewriting,Production,Pattern)VisualConcurrent,distributed,parallelActor-basedAutomatic mutual exclusionChoreographic programmingConcurrent logic(Concurrent constraint logic)Concurrent OOMacroprogrammingMultitier programmingOrganic computingParallel programming modelsPartitioned global address spaceProcess-orientedRelativistic programmingService-orientedStructured concurrencyMetaprogrammingAttribute-orientedAutomatic(Inductive)DynamicExtensibleGenericHomoiconicityInteractiveMacro(Hygienic)Metalinguistic abstractionMulti-stageProgram synthesis(Bayesian,Inferential,by demonstration,by example)ReflectiveSelf-modifying codeSymbolicTemplateSeparationof concernsAspectsComponentsData-drivenData-orientedEvent-drivenFeaturesIntentionalLiterateRolesSubjectsAuthority control databases: NationalFranceBnF dataIsraelUnited StatesRetrieved from "https://en.wikipedia.org/w/index.php?title=Parallel_computing&oldid=1242625923"Categories:Parallel computingConcurrent computingDistributed computingHidden categories:Webarchive template wayback linksCS1: long volume valueCS1 errors: periodical ignoredCS1 maint: multiple names: authors listArticles with short descriptionShort description is different from WikidataAll articles with unsourced statementsArticles with unsourced statements from March 2023Articles with hAudio microformatsSpoken articlesFeatured articlesThis page was last edited on 27 August 2024, at 20:41(UTC).Text is available under theCreative Commons Attribution-ShareAlike License 4.0;
additional terms may apply. By using this site, you agree to theTerms of UseandPrivacy Policy. Wikipedia® is a registered trademark of theWikimedia Foundation, Inc., a non-profit organization.Privacy policyAbout WikipediaDisclaimersContact WikipediaCode of ConductDevelopersStatisticsCookie statementMobile view