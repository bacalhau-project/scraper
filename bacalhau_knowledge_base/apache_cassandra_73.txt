URL: https://cassandra.apache.org/doc/latest/cassandra/developing/data-modeling/data-modeling_physical.html

Get StartedCassandra BasicsQuickstartEcosystemDocumentationCommunityWelcomeDiscussionsGovernanceContributeMeet the CommunityCatalyst ProgramEventsLearnCassandra 5.0Case StudiesResourcesBlogDownload NowCassandra DocumentationVersion:5.0mastertrunk5.04.14.03.11MainGlossaryHow to report bugsContact usDevelopmentGetting startedBuilding and IDE integrationTestingContributing code changesCode styleReview checklistHow to commitWorking on documentationJenkins CI environmentDependency managementRelease processCassandraFAQGetting StartedCassandra QuickstartSAI QuickstartVector Search QuickstartInstalling CassandraConfiguring CassandraInserting and queryingClient driversProduction recommendationsWhat’s newSupport for JavaArchitectureOverviewDynamoStorage EngineGuaranteesImproved Internode MessagingImproved StreamingData ModelingIntroductionConceptual data modelingRDBMS designDefining application queriesLogical data modelingPhysical data modelingEvaluating and refining data modelsDefining database schemaCassandra data modeling toolsCassandra Query Language (CQL)DefinitionsData typesData definition (DDL)Data manipulation (DML)Dynamic Data Masking (DDM)OperatorsIndexing conceptsSAI OverviewConceptsSAI QuickstartSAI FAQWorking with SAISAI operationsSecondary indexes (2i) overviewConceptsWorking with 2iRebuild 2iMaterialized viewsFunctionsJSONSecurityTriggersAppendicesChangesSASISingle file of CQL informationVector Search overviewConceptsData ModelingVector Search QuickstartWorking with Vector SearchManagingConfiguringcassandra.yamlcassandra-rackdc.propertiescassandra-env.shcassandra-topologies.propertiescommitlog-archiving.propertieslogback.xmljvm-* filesLiberating cassandra.yaml Parameters' Names from Their UnitsOperatingBackupsBloom filtersBulk loadingChange Data Capture (CDC)CompactionCompressionHardwareHintsLoggingAudit loggingAudit logging 2Full query loggingMonitoring metricsRepairRead repairSecuritySnitchesTopology changesTransient replicationVirtual tablesToolscqlsh: the CQL shellnodetoolSSTable toolscassandra-stressTroubleshootingFinding misbehaving nodesReading Cassandra logsUsing nodetoolUsing external tools to deep-diveReferenceALTER TABLECREATE INDEXCREATE CUSTOM INDEXCREATE TABLEDROP INDEXDROP TABLEPlug-insYou are viewing the documentation for a prerelease version.CassandraData ModelingPhysical data modelingEditPhysical data modelingOnce you have a logical data model defined, creating the physical model
is a relatively simple process.You walk through each of the logical model tables, assigning types to
each item. You can use any validCQL data type <data-types>, including
the basic types, collections, and user-defined types. You may identify
additional user-defined types that can be created to simplify your
design.After you’ve assigned data types, you analyze the model by performing
size calculations and testing out how the model works. You may make some
adjustments based on your findings. Once again let’s cover the data
modeling process in more detail by working through an example.Before getting started, let’s look at a few additions to the Chebotko
notation for physical data models. To draw physical models, you need to
be able to add the typing information for each column. This figure shows
the addition of a type for each column in a sample table.The figure includes a designation of the keyspace containing each table
and visual cues for columns represented using collections and
user-defined types. Note the designation of static columns and secondary
index columns. There is no restriction on assigning these as part of a
logical model, but they are typically more of a physical data modeling
concern.Hotel Physical Data ModelNow let’s get to work on the physical model. First, you need keyspaces
to contain the tables. To keep the design relatively simple, create ahotelkeyspace to contain tables for hotel and availability data, and
areservationkeyspace to contain tables for reservation and guest
data. In a real system, you might divide the tables across even more
keyspaces in order to separate concerns.For thehotelstable, use Cassandra’stexttype to represent the
hotel’sid. For the address, create anaddressuser defined type.
Use thetexttype to represent the phone number, as there is
considerable variance in the formatting of numbers between countries.While it would make sense to use theuuidtype for attributes such as
thehotel_id, this document uses mostlytextattributes as
identifiers, to keep the samples simple and readable. For example, a
common convention in the hospitality industry is to reference properties
by short codes like "AZ123" or "NY229". This example uses these values
forhotel_ids, while acknowledging they are not necessarily globally
unique.You’ll find that it’s often helpful to use unique IDs to uniquely
reference elements, and to use theseuuidsas references in tables
representing other entities. This helps to minimize coupling between
different entity types. This may prove especially effective if you are
using a microservice architectural style for your application, in which
there are separate services responsible for each entity type.As you work to create physical representations of various tables in the
logical hotel data model, you use the same approach. The resulting
design is shown in this figure:Note that theaddresstype is also included in the design. It is
designated with an asterisk to denote that it is a user-defined type,
and has no primary key columns identified. This type is used in thehotelsandhotels_by_poitables.User-defined types are frequently used to help reduce duplication of
non-primary key columns, as was done with theaddressuser-defined
type. This can reduce complexity in the design.Remember that the scope of a UDT is the keyspace in which it is defined.
To useaddressin thereservationkeyspace defined below design,
you’ll have to declare it again. This is just one of the many trade-offs
you have to make in data model design.Reservation Physical Data ModelNow, let’s examine reservation tables in the design. Remember that the
logical model contained three denormalized tables to support queries for
reservations by confirmation number, guest, and hotel and date. For the
first iteration of your physical data model design, assume you’re going
to manage this denormalization manually. Note that this design could be
revised to use Cassandra’s (experimental) materialized view feature.Note that theaddresstype is reproduced in this keyspace andguest_idis modeled as auuidtype in all of the tables.Material adapted from Cassandra, The Definitive Guide. Published by
O’Reilly Media, Inc. Copyright Â© 2020 Jeff Carpenter, Eben Hewitt. All
rights reserved. Used with permission.Get started with Cassandra, fast.Quickstart GuideApache Cassandrapowers mission-critical deployments with improved performance and unparalleled levels of scale in the cloud.HomeCassandra BasicsQuickstartEcosystemDocumentationCommunityCase StudiesResourcesBlogFoundationEventsLicenseThanksSecurityPrivacySponsorshipÂ© 2009-The Apache Software Foundationunder the terms of the Apache License 2.0.  Apache, the Apache feather logo, Apache Cassandra, Cassandra, and the Cassandra logo, are either registered trademarks or trademarks of The Apache Software Foundation.