URL: https://grpc.io/docs/languages/objective-c/basics/

gRPCAboutMeetDocsGuidesShowcaseBlogCommunitygRPConf 2024 is happening NEXT WEEK onAug. 27th!-Register nowand get 25% off with the code GOOGLE25.DocsWhat is gRPC?IntroductionCore conceptsFAQLanguagesC# / .NETAPI (legacy)Daily builds (legacy)C++Quick startBasics tutorialAsync-API tutorialAsynchronous Callback API TutorialBest Practices for gRPC C++ API and FAQALTSAPIDartQuick startBasics tutorialAPIGoQuick startBasics tutorialALTSAPIGenerated codeJavaQuick startBasics tutorialALTSAPIGenerated codeKotlinQuick startBasics tutorialAPINodeQuick startBasics tutorialAPIObjective-CQuick startBasics tutorialOAuth2APIPHPQuick startBasics tutorialAPIDaily buildsPythonQuick startBasics tutorialALTSGenerated codeAPIDaily buildsRubyQuick startBasics tutorialAPIDaily buildsPlatformsAndroidJavaQuick startBasics tutorialAPIKotlinQuick startAPIWebQuick startBasics tutorialGuidesAuthenticationBenchmarkingCancellationCompressionCustom Backend MetricsCustom Load Balancing PoliciesCustom Name ResolutionDeadlinesDebuggingError handlingFlow ControlHealth CheckingInterceptorsKeepaliveMetadataOpenTelemetry MetricsPerformance Best PracticesReflectionRequest HedgingRetryService ConfigStatus CodesWait-for-ReadyView page sourceEdit this pageCreate child pageCreate documentation issueCreate project issueWhy use gRPC?Example code and setupTry it out!Defining the serviceGenerating client codeCreating the client applicationConstructing a service objectCalling service methodsSimple RPCStreaming RPCsDocsLanguagesObjective-CBasics tutorialBasics tutorialA basic tutorial introduction to gRPC in Objective-C.ContentsWhy use gRPC?Example code and setupTry it out!Defining the serviceGenerating client codeCreating the client applicationConstructing a service objectCalling service methodsSimple RPCStreaming RPCsBasics tutorialA basic tutorial introduction to gRPC in Objective-C.This tutorial provides a basic Objective-C programmer’s
introduction to working with gRPC.By walking through this example you’ll learn how to:Define a service in a .proto file.Generate client code using the protocol buffer compiler.Use the Objective-C gRPC API to write a simple client for your service.It assumes a passing familiarity withprotocol
buffers. Note
that the example in this tutorial uses the proto3 version of the protocol
buffers language: you can find out more in
theproto3 language
guideand theObjective-C generated code
guide.Why use gRPC?Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.With gRPC we can define our service once in a.protofile and generate clients
and servers in any of gRPC’s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.Example code and setupThe example code for our tutorial is ingrpc/grpc/examples/objective-c/route_guide.
To download the example, clone thegrpcrepository by running the following
commands:$ git clone -b v1.66.0 --depth1--shallow-submodules https://github.com/grpc/grpc$cdgrpc$ git submodule update --initThen change your current directory toexamples/objective-c/route_guide:$cdexamples/objective-c/route_guideOur example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.You also should haveCocoapodsinstalled, as
well as the relevant tools to generate the client library code (and a server in
another language, for testing). You can obtain the latter by followingthese
setup instructions.Try it out!To try the sample app, we need a gRPC server running locally. Let’s compile and
run, for example, the C++ server in this repository:$pushd../../cpp/route_guide$ make$ ./route_guide_server &$popdNow have Cocoapods generate and install the client library for our .proto files:$ pod install(This might have to compile OpenSSL, which takes around 15 minutes if Cocoapods
doesn’t have it yet on your computer’s cache).Finally, open the XCode workspace created by Cocoapods, and run the app. You can
check the calling code inViewControllers.mand see the results in XCode’s log
console.The next sections guide you step-by-step through how this proto service is
defined, how to generate a client library from it, and how to create an app that
uses that library.Defining the serviceFirst let’s look at how the service we’re using is defined. A gRPCserviceand
its methodrequestandresponsetypes usingprotocol
buffers. You can
see the complete .proto file for our example inexamples/protos/route_guide.proto.To define a service, you specify a namedservicein your .proto file:serviceRouteGuide {...}Then you definerpcmethods inside your service definition, specifying their
request and response types. Protocol buffers let you define four kinds of
service method, all of which are used in theRouteGuideservice:Asimple RPCwhere the client sends a request to the server and receives a
response later, just like a normal remote procedure call.// Obtains the feature at a given position.rpcGetFeature(Point)returns(Feature) {}Aresponse-streaming RPCwhere the client sends a request to the server and
gets back a stream of response messages. You specify a response-streaming
method by placing thestreamkeyword before theresponsetype.// Obtains the Features available within the given Rectangle.  Results are// streamed rather than returned at once (e.g. in a response message with a// repeated field), as the rectangle may cover a large area and contain a// huge number of features.rpcListFeatures(Rectangle)returns(stream Feature) {}Arequest-streaming RPCwhere the client sends a sequence of messages to the
server. Once the client has finished writing the messages, it waits for the
server to read them all and return its response. You specify a
request-streaming method by placing thestreamkeyword before therequesttype.// Accepts a stream of Points on a route being traversed, returning a// RouteSummary when traversal is completed.rpcRecordRoute(stream Point)returns(RouteSummary) {}Abidirectional streaming RPCwhere both sides send a sequence of messages
to the other. The two streams operate independently, so clients and servers
can read and write in whatever order they like: for example, the server could
wait to receive all the client messages before writing its responses, or it
could alternately read a message then write a message, or some other
combination of reads and writes. The order of messages in each stream is
preserved. You specify this type of method by placing thestreamkeyword
before both the request and the response.// Accepts a stream of RouteNotes sent while a route is being traversed,// while receiving other RouteNotes (e.g. from other users).rpcRouteChat(stream RouteNote)returns(stream RouteNote) {}Our.protofile also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here’s
thePointmessage type:// Points are represented as latitude-longitude pairs in the E7 representation// (degrees multiplied by 10**7 and rounded to the nearest integer).// Latitudes should be in the range +/- 90 degrees and longitude should be in// the range +/- 180 degrees (inclusive).messagePoint{int32latitude=1;int32longitude=2;}You can specify a prefix to be used for your generated classes by adding theobjc_class_prefixoption at the top of the file. For example:optionobjc_class_prefix="RTG";Generating client codeNext we need to generate the gRPC client interfaces from our .proto service
definition. We do this using the protocol buffer compiler (protoc) with a
special gRPC Objective-C plugin.For simplicity, we’ve provided aPodspec
filethat runsprotocfor you with the appropriate plugin, input, and output, and
describes how to compile the generated files. You just need to run in this
directory (examples/objective-c/route_guide):$ pod installwhich, before installing the generated library in the XCode project of this sample, runs:$ protoc -I ../../protos --objc_out=Pods/RouteGuide --objcgrpc_out=Pods/RouteGuide ../../protos/route_guide.protoRunning this command generates the following files underPods/RouteGuide/:RouteGuide.pbobjc.h, the header which declares your generated message
classes.RouteGuide.pbobjc.m, which contains the implementation of your message
classes.RouteGuide.pbrpc.h, the header which declares your generated service
classes.RouteGuide.pbrpc.m, which contains the implementation of your service
classes.These contain:All the protocol buffer code to populate, serialize, and retrieve our request
and response message types.A class calledRTGRouteGuidethat lets clients call the methods defined in
theRouteGuideservice.You can also use the provided Podspec file to generate client code from any
other proto service definition; just replace the name (matching the file name),
version, and other metadata.Creating the client applicationIn this section, we’ll look at creating an Objective-C client for ourRouteGuideservice. You can see our complete example client code inexamples/objective-c/route_guide/ViewControllers.m.NoteIn your apps, for maintainability and readability reasons, you shouldn’t
put all of your view controllers in a single file; it’s done here only to
simplify the learning process).Constructing a service objectTo call service methods, we first need to create a service object, an instance
of the generatedRTGRouteGuideclass. The designated initializer of the class
expects aNSString *with the server address and port we want to connect to:#import <GRPCClient/GRPCCall+Tests.h>#import <RouteGuide/RouteGuide.pbrpc.h>#import <GRPCClient/GRPCTransport.h>staticNSString*constkHostAddress=@"localhost:50051";...GRPCMutableCallOptions*options=[[GRPCMutableCallOptions alloc] init];options.transport=GRPCDefaultTransportImplList.core_insecure;RTGRouteGuide*service=[[RTGRouteGuide alloc]initWithHost:kHostAddresscallOptions:options];Notice that we our service is constructed with an insecure transport. This is
because the server we will be using to test our client doesn’t useTLS. This is fine
because it will be running locally on our development machine. The most common
case, though, is connecting with a gRPC server on the internet, running gRPC
over TLS. For that case, the setting the optionoptions.transportisn’t
needed because gRPC will use a secure TLS transport by default.Calling service methodsNow let’s look at how we call our service methods. As you will see, all these
methods are asynchronous, so you can call them from the main thread of your app
without worrying about freezing your UI or the OS killing your app.Simple RPCCalling the simple RPCGetFeatureis as straightforward as calling any other
asynchronous method on Cocoa.RTGPoint*point=[RTGPoint message];point.latitude=40E7;point.longitude=-74E7;GRPCUnaryResponseHandler*handler=[[GRPCUnaryResponseHandler alloc]initWithResponseHandler:^(RTGFeature*response, NSError*error) {if(response) {// Successful response received}else{// RPC error}}responseDispatchQueue:nil];[[servicegetFeatureWithMessage:pointresponseHandler:handlercallOptions:nil] start];As you can see, we create and populate a request protocol buffer object (in our
caseRTGPoint). Then, we call the method on the service object, passing it the
request, and a block to handle the response (or any RPC error). If the RPC
finishes successfully, the handler block is called with anilerror argument,
and we can read the response information from the server from the response
argument. If, instead, some RPC error happens, the handler block is called with
anilresponse argument, and we can read the details of the problem from the
error argument.Streaming RPCsNow let’s look at our streaming methods. Here’s where we call the
response-streaming methodListFeatures, which results in our client app
receiving a stream of geographicalRTGFeatures:- (void)didReceiveProtoMessage(GPBMessage*)message{if(message) {NSLog(@"Found feature at %@ called %@.", response.location, response.name);}}- (void)didCloseWithTrailingMetadata:(NSDictionary*)trailingMetadataerror:(NSError*)error{if(error) {NSLog(@"RPC error: %@", error);}}- (void)execRequest{...[[servicelistFeaturesWithMessage:rectangleresponseHandler:selfcallOptions:nil] start];}Notice that instead of providing a response handler object, the view controller
object itself handles the responses. The methoddidReceiveProtoMessage:is
called when there’s a message received; it can be called any number of times.
The methoddidCloseWithTrailingMetadata:is called when the call is complete
and the gRPC status is received from the server (or when there’s any error
happens during the call).The request-streaming methodRecordRouteexpects a stream ofRTGPoints from
the cient. This stream can be written to the gRPC call object after the call
starts.RTGPoint*point1=[RTGPoint message];point.latitude=40E7;point.longitude=-74E7;RTGPoint*point2=[RTGPoint message];point.latitude=40E7;point.longitude=-74E7;GRPCUnaryResponseHandler*handler=[[GRPCUnaryResponseHandler alloc]initWithResponseHandler:^(RTGRouteSummary*response, NSError*error) {if(response) {NSLog(@"Finished trip with %i points", response.pointCount);NSLog(@"Passed %i features", response.featureCount);NSLog(@"Travelled %i meters", response.distance);NSLog(@"It took %i seconds", response.elapsedTime);}else{NSLog(@"RPC error: %@", error);}}responseDispatchQueue:nil];GRPCStreamingProtoCall*call=[servicerecordRouteWithResponseHandler:handlercallOptions:nil];[call start];[callwriteMessage:point1];[callwriteMessage:point2];[call finish];Note that since the gRPC call object does not know the end of the request
stream, users must invokefinish:method when the request stream is complete.Finally, let’s look at our bidirectional streaming RPCRouteChat(). The way to
call a bidirectional streaming RPC is just a combination of how to call
request-streaming RPCs and response-streaming RPCs.- (void)didReceiveProtoMessage(GPBMessage*)message{RTGRouteNote*note=(RTGRouteNote*)message;if(note) {NSLog(@"Got message %@ at %@", note.message, note.location);}}- (void)didCloseWithTrailingMetadata:(NSDictionary*)trailingMetadataerror:(NSError*)error{if(error) {NSLog(@"RPC error: %@", error);}else{NSLog(@"Chat ended.");}}- (void)execRequest{...GRPCStreamingProtoCall*call=[servicerouteChatWithResponseHandler:selfcallOptions:nil];[call start];[callwriteMessage:note1];...[callwriteMessage:noteN];[call finish];}Last modified February 16, 2023:Update Protocol Buffers documentation URL (#1092) (852a744)View page sourceEdit this pageCreate child pageCreate documentation issueCreate project issue© 2024 gRPC AuthorsTerms|Privacy|Trademarks|License|About