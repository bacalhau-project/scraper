URL: https://nats.io/blog/nats-supported-by-faststream/#code-generator

AboutDownloadDocumentationBlogCommunitySupportPrivacyStreamlining Asynchronous Services with FastStreamTvrtko Sternak— October 23, 2023Back to BlogEver felt lost in the complexity of microservices and message queues? That’s precisely why FastStream was created. Initially, it was our solution to the challenges we faced with messaging queues in our own projects. But as it simplified our lives, we realized it could do the same for others. So, we decided to share it with the world.FastStream is a Python framework for building asynchronous services that interact with event streams like Apache Kafka, RabbitMQ, and NATS. It streamlines the entire process of working with message queues in microservices. Parsing messages, managing networking, and keeping documentation updated—all handled effortlessly.We are happy to announce that FastStream supports NATS by building on top of theofficial nats-io python client!FeaturesDesigned with junior developers in mind,FastStreamsimplifies your work while keeping the door open for more advanced use-cases. Here’s a look at the core features that makeFastStreama go-to framework for modern, data-centric microservices.Multiple Brokers:FastStreamprovides a unified API to work across multiple message brokers (NATS,Kafka,RabbitMQsupport)Pydantic Validation: LeveragePydantic’svalidation capabilities to serialize and validates incoming messagesAutomatic Docs: Stay ahead with automaticAsyncAPIdocumentationIntuitive: Full-typed editor support makes your development experience smooth, catching errors before they reach runtimePowerful Dependency Injection System: Manage your service dependencies efficiently withFastStream’s built-in DI systemTestable: Supports in-memory tests, making your CI/CD pipeline faster and more reliableExtendable: Use extensions for lifespans, custom serialization and middlewaresIntegrations:FastStreamis fully compatible with any HTTP framework you want (FastAPIespecially)Built for Automatic Code Generation:FastStreamis optimized for automatic code generation using advanced models like GPT and LlamaLet’s build something!Let’s get our hands a bit dirty.
We’ll implement an example python app usingFastStreamthat consumes names from “persons” subject and outputs greetings to the “greetings” subject.Cookiecutter projectTo start our project, we will use the prepared cookiecutter FastStream project. To find out more about it, check ourdetailed guide.Install thecookiecutterpackage using the following command:pip install cookiecutterNow, run the provided cookiecutter command and fill out the relevant details to generate a new FastStream project, we will name this project “greetings_app”:cookiecutter https://github.com/airtai/cookiecutter-faststream.gitThe cookiecutter creation process should look like this:You`ve downloaded /Users/tvrtko/.cookiecutters/cookiecutter-faststream before. Is it okay to delete and re-download it?[y/n](y): y[1/4]username(github-username): sternakt[2/4]project_name(My FastStream App): Greetings App[3/4]project_slug(greetings_app): greetings_app[4/4]Select streaming_service1- kafka2- nats3- rabbit
    Choose from[1/2/3](1):2Change the working directory to the newly created directory and install all development requirements using pip:cdgreetings_app
pip install -e".[dev]"Now we are ready to edit our greetings_app/application.py and tests/test_application.py files to implement our application logic.Writing app codeFastStreambrokers provide convenient function decorators@broker.subscriberand@broker.publisherto allow you to delegate the actual process of:consuming and producing data to Event queues, anddecoding and encoding JSON encoded messagesThese decorators make it easy to specify the processing logic for your consumers and producers, allowing you to focus on the core business logic of your application without worrying about the underlying integration.Also,FastStreamusesPydanticto parse input JSON-encoded data into Python objects, making it easy to work with structured data in your applications, so you can serialize your input messages just using type annotations.Here is an example python app we talked about:fromfaststreamimportFastStream,Loggerfromfaststream.natsimportNatsBrokerfrompydanticimportBaseModel,Fieldversion="0.1.0"title="My FastStream service"description="Description of my FastStream service"className(BaseModel):name:str=Field(...,description="Name of the person")classGreeting(BaseModel):greeting:str=Field(...,description="Greeting message")broker=NatsBroker()app=FastStream(broker,title=title,version=version,description=description)to_greetings=broker.publisher("greetings",description="Produces a message on greetings after receiving a meesage on names",)@broker.subscriber("names",description="Consumes messages from names subject and produces messages to greetings subject")asyncdefon_names(msg:Name,logger:Logger)->None:result=f"hello {msg.name}"logger.info(result)greeting=Greeting(greeting=result)awaitto_greetings.publish(greeting)The example application will subscribe topersonsNATS subject and consume Name JSON messages from it. When the application consumes a message it will publish a Greetings JSON messagegreetingssubject.We can save the application into theapplication.pyfile and let’s take a closer look at the code.Creating a brokerTo create an application, first we need to create a broker. This is the main piece of FastStream and takes care of the defining subscribers and producers.version="0.1.0"title="My FastStream service"description="Description of my FastStream service"...broker=NatsBroker()app=FastStream(broker,title=title,version=version,description=description)Defining data structuresNext, we need to define the structure of incoming and outgoing data. FastStream is integrated with Pydantic and offers automatic encoding and decoding of JSON formatted messages into Pydantic classes.className(BaseModel):name:str=Field(...,description="Name of the person")classGreeting(BaseModel):greeting:str=Field(...,description="Greeting message")Defining a publisherNow, we define the publishing logic of our application.to_greetings=broker.publisher("greetings",description="Produces a message on greetings after receiving a message on names",)Defining a subscriberFinally, we can define the subscribing logic of our application. The app will consume data from the “names” subject and use the defined publisher to produce to the “greetings” subject whenever a message is consumed.@broker.subscriber("names",description="Consumes messages from names subject and produces messages to greetings subject")asyncdefon_names(msg:Name,logger:Logger)->None:result=f"hello {msg.name}"logger.info(result)greeting=Greeting(greeting=result)awaitto_greetings.publish(greeting)Testing the serviceThe service can be tested using theTestBrokercontext managers, which, by default, puts the Broker into “testing mode”.The Tester will redirect yoursubscriberandpublisherdecorated functions to the InMemory brokers, allowing you to quickly test your app without the need for a running broker and all its dependencies.Using pytest, the test for our service would look like this:importpytestfromfaststream.natsimportTestNatsBrokerfromgreetings_app.applicationimportGreeting,Name,broker,on_names# Subscribe to the "greetings" subject so we can monitor# messages our application is producing@broker.subscriber("greetings")asyncdefon_greetings(msg:Greeting)->None:pass@pytest.mark.asyncioasyncdeftest_on_names():asyncwithTestNatsBroker(broker):# Send John to "names" subjectawaitbroker.publish(Name(name="John"),"names")# Assert that our application has consumed "John"on_names.mock.assert_called_with(dict(Name(name="John")))# Assert that our application has greeted John in the "greetings" subjecton_greetings.mock.assert_called_with(dict(Greeting(greeting="hello John")))In the test, we send a test User JSON to theinsubject, and then we assert that the broker has responded to theoutsubject with the appropriate message.We can save the test to the test_application.py file and run the test by executing the following command in our application root file.pytestHere is how the tests execution should look like in your terminal:=====================================testsessionstarts=====================================platform darwin -- Python 3.11.5, pytest-7.4.2, pluggy-1.3.0
rootdir: /Users/tvrtko/Documents/Airt Projects/FastStream/faststream-cookiecutter/greetings_app
configfile: pyproject.toml
plugins: asyncio-0.21.1, anyio-3.7.1
asyncio:mode=Mode.STRICT
collected1item                                                                              

tests/test_application.py .[100%]======================================1passed in 0.34s======================================Running the applicationThe application can be started using built-inFastStreamCLI command.To run the service, use theFastStream CLIcommand and pass the module (in this case, the file where the app implementation is located) and the app symbol to the command.faststream run greetings_app.application:appAfter running the command, you should see the following output:2023-10-13 08:36:32,162 INFO     - FastStream app starting...
2023-10-13 08:36:32,170 INFO     - names|-`OnNames`waitingformessages
2023-10-13 08:36:32,177 INFO     - FastStream app started successfully! To exit, press CTRL+CAlso,FastStreamprovides you a great hot reload feature to improve your Development Experiencefaststream run greetings_app.application:app --reloadAnd multiprocessing horizontal scaling feature as well:faststream run greetings_app.application:app --workers3DocumentationFastStream provides a command to serve the AsyncAPI documentation, let’s use it to document our application.
To generate and serve the documentation, run the following command:faststream docs serve greetings_app.application:appNow, you should see the following output:INFO:     Started server process[47151]INFO:     Waitingforapplication startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://localhost:8000(Press CTRL+C to quit)Now open your browser athttp://localhost:8000and enjoy in your automatically generated documentation!Aaaand, that’s it! Feel free to experiment further with your application and checkoutthe documentationfor more complex examples.Support us on GitHub and join our communityHead over to ourGitHub repositoryand show your support by starring it. By doing so, you’ll stay in the loop with the latest developments, updates, and enhancements as we continue to refine and expand FastStream.ConclusionFastStream is your go-to tool for efficient microservices development. It simplifies message queues, and offers Pydantic validation and auto-doc generation.We’re immensely grateful for your interest, and we look forward to your potential contributions. With FastStream in your toolkit, you’re prepared to conquer the challenges of data-centric microservices like never before. Happy coding!About the AuthorTvrtko Sternak is a developer atAIRTand one of the creators ofFastStream.Back to BlogCopyright © NATS Authors 2024NATS is aCloud Native Computing Foundationincubating projectThe Linux Foundation has registered trademarks and uses trademarks.For a list of trademarks of The Linux Foundation, please seeTrademark Usage page.