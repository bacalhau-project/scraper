URL: https://en.wikipedia.org/wiki/Paxos_(computer_science)#Assumptions

Jump to contentMain menuMain menumove to sidebarhideNavigationMain pageContentsCurrent eventsRandom articleAbout WikipediaContact usDonateContributeHelpLearn to editCommunity portalRecent changesUpload fileSearchSearchAppearanceCreate accountLog inPersonal toolsCreate accountLog inPages for logged out editorslearn moreContributionsTalkContentsmove to sidebarhide(Top)1History2AssumptionsToggle Assumptions subsection2.1Processors2.2Network2.3Number of processors3Safety and liveness properties4Typical deployment5Basic PaxosToggle Basic Paxos subsection5.1Phase 15.1.1Phase 1a:Prepare5.1.2Phase 1b:Promise5.2Phase 25.2.1Phase 2a:Accept5.2.2Phase 2b:Accepted5.3When rounds fail5.4Paxos can be used to select a leader5.5Graphic representation of the flow of messages in the basic Paxos5.5.1Basic Paxos without failures5.5.2Error cases in basic Paxos5.5.3Basic Paxos when an Acceptor fails5.5.4Basic Paxos when a redundant learner fails5.5.5Basic Paxos when a Proposer fails5.5.6Basic Paxos when multiple Proposers conflict5.5.7Basic Paxos where an Acceptor accepts Two Different Values5.5.8Basic Paxos where a multi-identifier majority is insufficient5.5.9Basic Paxos where new Proposers cannot change an existing consensus6Multi-PaxosToggle Multi-Paxos subsection6.1Graphic representation of the flow of messages in the Multi-Paxos6.1.1Multi-Paxos without failures6.1.2Multi-Paxos when phase 1 can be skipped6.1.3Multi-Paxos when roles are collapsed6.1.4Multi-Paxos when roles are collapsed and the leader is steady7Optimisations8Cheap PaxosToggle Cheap Paxos subsection8.1Message flow: Cheap Multi-Paxos9Fast PaxosToggle Fast Paxos subsection9.1Message flow: Fast Paxos, non-conflicting9.2Message flow: Fast Paxos, conflicting proposals9.3Message flow: Fast Paxos with uncoordinated recovery, collapsed roles10Generalized PaxosToggle Generalized Paxos subsection10.1Example10.2Message flow: Generalized Paxos (example)10.3Performance11Byzantine PaxosToggle Byzantine Paxos subsection11.1Message flow: Byzantine Multi-Paxos, steady state11.2Message flow: Fast Byzantine Multi-Paxos, steady state11.3Message flow: Fast Byzantine Multi-Paxos, failure12Adapting Paxos for RDMA networks13Production use of Paxos14See also15References16External linksToggle the table of contentsPaxos (computer science)9 languagesDeutschEspañolFrançais한국어日本語РусскийСрпски / srpskiУкраїнська中文Edit linksArticleTalkEnglishReadEditView historyToolsToolsmove to sidebarhideActionsReadEditView historyGeneralWhat links hereRelated changesUpload fileSpecial pagesPermanent linkPage informationCite this pageGet shortened URLDownload QR codeWikidata itemPrint/exportDownload as PDFPrintable versionAppearancemove to sidebarhideFrom Wikipedia, the free encyclopediaFamily of protocols for solving consensusPaxosis a family of protocols for solvingconsensusin a network of unreliable or fallible processors.
Consensus is the process of agreeing on one result among a group of participants.  This problem becomes difficult when the participants or their communications may experience failures.[1]Consensus protocols are the basis for thestate machine replicationapproach todistributed computing, as suggested byLeslie Lamport[2]and surveyed byFred Schneider.[3]State machine replication is a technique for converting an algorithm into a fault-tolerant, distributed implementation.  Ad-hoc techniques may leave important cases of failures unresolved.  The principled approach proposed by Lamport et al. ensures all cases are handled safely.The Paxos protocol was first submitted in 1989 and named after a fictional legislative consensus system used on thePaxosisland in Greece, where Lamport wrote that the parliament had to function "even though legislators continually wandered in and out of the parliamentary Chamber".[4]It was later published as a journal article in 1998.[5]The Paxos family of protocols includes a spectrum of trade-offs between the number of processors, number of message delays before learning the agreed value, the activity level of individual participants, number of messages sent, and types of failures.  Although no deterministic fault-tolerant consensus protocol can guarantee progress in an asynchronous network (aresultproved in a paper byFischer,LynchandPaterson[6]), Paxos guarantees safety (consistency), and the conditions that could prevent it from making progress are difficult to provoke.Paxos is usually used where durability is required (for example, to replicate a file or adatabase), in which the amount of durable state could be large. The protocol attempts to make progress even during periods when some bounded number of replicas are unresponsive. There is also a mechanism to drop a permanently failed replica or to add a new replica.History[edit]The topic predates the protocol. In 1988,Lynch,DworkandStockmeyerhad demonstrated[7]the solvability of consensus in a broad family of "partially synchronous" systems.  Paxos has strong similarities to a protocol used for agreement in "viewstamped replication", first published by Oki andLiskovin 1988, in the context of distributed transactions.[8]Notwithstanding this prior work, Paxos offered a particularly elegant formalism, and included one of the earliest proofs of safety for a fault-tolerant distributed consensus protocol.Reconfigurable state machines have strong ties to prior work on reliable group multicast protocols that support dynamic group membership, for exampleBirman's work in 1985 and 1987 on thevirtually synchronousgbcast[9]protocol. However, gbcast is unusual in supporting durability and addressing partitioning failures.
Most reliable multicast protocols lack these properties, which are required for implementations of the state machine replication model.
This point is elaborated in a paper byLamport,Malkhiand Zhou.[10]Paxos protocols are members of a theoretical class of solutions to a problem formalized as uniform agreement with crash failures.
Lower bounds for this problem have been proved byKeidarand Shraer.[11]Derecho,[12]a C++ software library for cloud-scale state machine replication, offers a Paxos protocol that has been integrated with self-managed virtually synchronous membership.  This protocol matches the Keidar and Shraer optimality bounds, and maps efficiently to modernremote DMA (RDMA)datacenter hardware (but uses TCP if RDMA is not available).Assumptions[edit]In order to simplify the presentation of Paxos, the following assumptions and definitions are made explicit.  Techniques to broaden the applicability are known in the literature, and are not covered in this article.Processors[edit]Processors operate at arbitrary speed.Processors may experience failures.Processors with stable storage may re-join the protocol after failures (following a crash-recovery failure model).Processors do not collude, lie, or otherwise attempt to subvert the protocol. (That is,Byzantine failuresdon't occur. SeeByzantine Paxosfor a solution that tolerates failures that arise from arbitrary/malicious behavior of the processes.)Network[edit]Processors can send messages to any other processor.Messages are sent asynchronously and may take arbitrarily long to deliver.Messages may be lost, reordered, or duplicated.Messages are delivered without corruption. (That is, Byzantine failures don't occur. SeeByzantine Paxosfor a solution which tolerates corrupted messages that arise from arbitrary/malicious behavior of the messaging channels.)Number of processors[edit]In general, a consensus algorithm can make progress usingn=2F+1{\displaystyle n=2F+1}processors, despite the simultaneous failure of anyF{\displaystyle F}processors:[13]in other words, the number of non-faulty processes must be strictly greater than the number of faulty processes. However, using reconfiguration, a protocol may be employed which survives any number of total failures as long as no more than F fail simultaneously. For Paxos protocols, these reconfigurations can be handled as separateconfigurations.[14]Safety and liveness properties[edit]In order to guaranteesafety(also called "consistency"), Paxos defines three properties and ensures the first two are always held, regardless of the pattern of failures:Validity (ornon-triviality)Only proposed values can be chosen and learned.[15]Agreement (orconsistency, orsafety)No two distinct learners can learn different values (or there can't be more than one decided value)[15][16]Termination (or liveness)If value C has been proposed, then eventually learner L will learn some value (if sufficient processors remain non-faulty).[16]Note that Paxos isnotguaranteed to terminate, and thus does not have the liveness property. This is supported by the Fischer Lynch Paterson impossibility result (FLP)[6]which states that a consistency protocol can only have two ofsafety,liveness, andfault tolerance. As Paxos's point is to ensure fault tolerance and it guarantees safety, it cannot also guarantee liveness.Typical deployment[edit]In most deployments of Paxos, each participating process acts in three roles; Proposer, Acceptor and Learner.[17]This reduces the message complexity significantly, without sacrificing correctness:In Paxos, clients send commands to a leader. During normal operation, the leader receives a client's command, assigns it a new command numberi{\displaystyle i}, and then begins thei{\displaystyle i}thinstance of the consensus algorithm by sending messages to a set of acceptor processes.[16]By merging roles, the protocol "collapses" into an efficient client-master-replica style deployment, typical of the database community.[18]The benefit of the Paxos protocols (including implementations with merged roles) is the guarantee of itssafety properties.A typical implementation's message flow is covered in the sectionMulti-Paxos.Basic Paxos[edit]This protocol is the most basic of the Paxos family. Each "instance" (or "execution") of the basic Paxos protocol decides on a single output value. The protocol proceeds over several rounds. A successful round has 2 phases: phase 1 (which is divided into partsaandb) and phase 2 (which is divided into partsaandb). See below the description of the phases. Remember that we assume an asynchronous model, so e.g. a processor may be in one phase while another processor may be in another.Phase 1[edit]Phase 1a:Prepare[edit]AProposercreates a message, which we call aPrepare. The message is identified with unique a number,n, which must be greater than any number previously used in a Prepare message by this Proposer. Note thatnis not the value to be proposed; it is simply a unique identifier of this initial message by the Proposer. In fact, the Prepare message needn't contain the proposed value (often denoted byv).The Proposer chooses at least aQuorumofAcceptors[how?]and sends the Prepare message containingnto them. A Proposer should not initiate Paxos if it cannot communicate with enough Acceptors to constitute a Quorum.Phase 1b:Promise[edit]The Acceptors wait for a Prepare message from any of the Proposers. When an Acceptor receives a Prepare message, the Acceptor must examine the identifier number,n, of that message. There are two cases:Ifnis higher than every previous proposal number received by the Acceptor (from any Proposer), then the Acceptor must return a message (called aPromise) to the Proposer, indicating that the Acceptor will ignore all future proposals numbered less than or equal ton. The Promise must include the highest number among the Proposals that the Acceptor previously accepted, along with the corresponding accepted value.This articleis missing informationabout handling the first Prepare message.Please expand the article to include this information. Further details may exist on thetalk page.(July 2024)Ifnis less than or equal to any previous proposal number received by the Acceptor, the Acceptor needn't respond and can ignore the proposal. However, for the sake of optimization, sending a denial, ornegative acknowledgement(NAK), response would tell the Proposer that it can stop its attempt to create consensus with proposaln.Phase 2[edit]Phase 2a:Accept[edit]If a Proposer receives Promises from a Quorum of Acceptors, it needs to set a valuevto its proposal. If any Acceptors had previously accepted any proposal, then they'll have sent their values to the Proposer, who now must set the value of its proposal,v, to the value associated with the highest proposal number reported by the Acceptors, let's call itz. If none of the Acceptors had accepted a proposal up to this point, then the Proposer may choose the value it originally wanted to propose, sayx.[19]The Proposer sends anAcceptmessage,(n, v), to a Quorum of Acceptors with the chosen value for its proposal, v, and the proposal numbern(which is the same as the number contained in thePreparemessage previously sent to the Acceptors). So, theAcceptmessage is either(n, v=z)or, in case none of the Acceptors previously accepted a value,(n, v=x).ThisAcceptmessage should be interpreted as a "request", as in "Accept this proposal, please!".Phase 2b:Accepted[edit]If an Acceptor receives an Accept message,(n, v), from a Proposer, it must accept itif and only ifit hasnotalready promised (in Phase 1b of the Paxos protocol) to only consider proposals having an identifier greater thann.If the Acceptor has not already promised (in Phase 1b) to only consider proposals having an identifier greater thann, it should register the valuev(of the just receivedAcceptmessage) as the accepted value (of the Protocol), and send anAcceptedmessage to the Proposer and every Learner (which can typically be the Proposers themselves. Learners will learn the decided value ONLY AFTER receiving Accepted messages from a majority of acceptors, which means, NOT after receiving just the FIRST Accept message).Else, it can ignore the Accept message or request.Note that consensus is achieved when a majority of Acceptors accept the sameidentifier number(rather than the samevalue).  Because each identifier is unique to a Proposer and only one value may be proposed per identifier, all Acceptors that accept the same identifier thereby accept the same value.  These facts result in a few counter-intuitive scenarios that do not impact correctness:Acceptors can accept multiple values,a value may achieve a majority across Acceptors (with different identifiers) only to later be changed, andAcceptors may continue to accept proposals after an identifier has achieved a majority.  However, the Paxos protocol guarantees that consensus is permanent and the chosen value is immutable.When rounds fail[edit]Rounds fail when multiple Proposers send conflictingPreparemessages, or when the Proposer does not receive a Quorum of responses (PromiseorAccepted).  In these cases, another round must be started with a higher proposal number.Paxos can be used to select a leader[edit]Notice that a Proposer in Paxos could propose "I am the leader," (or, for example, "Proposer X is the leader").[20]Because of the agreement and validity guarantees of Paxos, if accepted by a Quorum, then the Proposer is now known to be the leader to all other nodes. This satisfies the needs of leader election[21]because there is a single node believing it is the leader and a single node known to be the leader at all times.Graphic representation of the flow of messages in the basic Paxos[edit]The following diagrams represent several cases/situations of the application of the Basic Paxos protocol. Some cases show how the Basic Paxos protocol copes with the failure of certain (redundant) components of the distributed system.Note that the values returned in thePromisemessage are "null" the first time a proposal is made (since no Acceptor has accepted a value before in this round).Basic Paxos without failures[edit]In the diagram below, there is 1 Client, 1 Proposer, 3 Acceptors (i.e. the Quorum size is 3) and 2 Learners (represented by the 2 vertical lines). This diagram represents the case of a first round, which is successful (i.e. no process in the network fails).Here, V is the last of (Va, Vb, Vc).Error cases in basic Paxos[edit]The simplest error cases are the failure of an Acceptor (when a Quorum of Acceptors remains alive) and failure of a redundant Learner. In these cases, the protocol requires no "recovery" (i.e. it still succeeds): no additional rounds or messages are required, as shown below (in the next two diagrams/cases).Basic Paxos when an Acceptor fails[edit]In the following diagram, one of the Acceptors in the Quorum fails, so the Quorum size becomes 2. In this case, the Basic Paxos protocol still succeeds.Client   Proposer      Acceptor     Learner
   |         |          |  |  |       |  |
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Prepare(1)
   |         |          |  |  !       |  |  !! FAIL !!
   |         |<---------X--X          |  |  Promise(1,{Va, Vb, null})
   |         X--------->|->|          |  |  Accept!(1,V)
   |         |<---------X--X--------->|->|  Accepted(1,V)
   |<---------------------------------X--X  Response
   |         |          |  |          |  |Basic Paxos when a redundant learner fails[edit]In the following case, one of the (redundant) Learners fails, but the Basic Paxos protocol still succeeds.Client Proposer         Acceptor     Learner
   |         |          |  |  |       |  |
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Prepare(1)
   |         |<---------X--X--X       |  |  Promise(1,{Va,Vb,Vc})
   |         X--------->|->|->|       |  |  Accept!(1,V)
   |         |<---------X--X--X------>|->|  Accepted(1,V)
   |         |          |  |  |       |  !  !! FAIL !!
   |<---------------------------------X     Response
   |         |          |  |  |       |Basic Paxos when a Proposer fails[edit]In this case, a Proposer fails after proposing a value, but before the agreement is reached. Specifically, it fails in the middle of the Accept message, so only one Acceptor of the Quorum receives the value. Meanwhile, a new Leader (a Proposer) is elected (but this is not shown in detail). Note that there are 2 rounds in this case (rounds proceed vertically, from the top to the bottom).Client  Proposer        Acceptor     Learner
   |      |             |  |  |       |  |
   X----->|             |  |  |       |  |  Request
   |      X------------>|->|->|       |  |  Prepare(1)
   |      |<------------X--X--X       |  |  Promise(1,{Va, Vb, Vc})
   |      |             |  |  |       |  |
   |      |             |  |  |       |  |  !! Leader fails during broadcast !!
   |      X------------>|  |  |       |  |  Accept!(1,V)
   |      !             |  |  |       |  |
   |         |          |  |  |       |  |  !! NEW LEADER !!
   |         X--------->|->|->|       |  |  Prepare(2)
   |         |<---------X--X--X       |  |  Promise(2,{V, null, null})
   |         X--------->|->|->|       |  |  Accept!(2,V)
   |         |<---------X--X--X------>|->|  Accepted(2,V)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |Basic Paxos when multiple Proposers conflict[edit]The most complex case is when multiple Proposers believe themselves to be Leaders.  For instance, the current leader may fail and later recover, but the other Proposers have already re-selected a new leader.  The recovered leader has not learned this yet and attempts to begin one round in conflict with the current leader. In the diagram below, 4 unsuccessful rounds are shown, but there could be more (as suggested at the bottom of the diagram).Client   Proposer       Acceptor     Learner
   |      |             |  |  |       |  |
   X----->|             |  |  |       |  |  Request
   |      X------------>|->|->|       |  |  Prepare(1)
   |      |<------------X--X--X       |  |  Promise(1,{null,null,null})
   |      !             |  |  |       |  |  !! LEADER FAILS
   |         |          |  |  |       |  |  !! NEW LEADER (knows last number was 1)
   |         X--------->|->|->|       |  |  Prepare(2)
   |         |<---------X--X--X       |  |  Promise(2,{null,null,null})
   |      |  |          |  |  |       |  |  !! OLD LEADER recovers
   |      |  |          |  |  |       |  |  !! OLD LEADER tries 2, denied
   |      X------------>|->|->|       |  |  Prepare(2)
   |      |<------------X--X--X       |  |  Nack(2)
   |      |  |          |  |  |       |  |  !! OLD LEADER tries 3
   |      X------------>|->|->|       |  |  Prepare(3)
   |      |<------------X--X--X       |  |  Promise(3,{null,null,null})
   |      |  |          |  |  |       |  |  !! NEW LEADER proposes, denied
   |      |  X--------->|->|->|       |  |  Accept!(2,Va)
   |      |  |<---------X--X--X       |  |  Nack(3)
   |      |  |          |  |  |       |  |  !! NEW LEADER tries 4
   |      |  X--------->|->|->|       |  |  Prepare(4)
   |      |  |<---------X--X--X       |  |  Promise(4,{null,null,null})
   |      |  |          |  |  |       |  |  !! OLD LEADER proposes, denied
   |      X------------>|->|->|       |  |  Accept!(3,Vb)
   |      |<------------X--X--X       |  |  Nack(4)
   |      |  |          |  |  |       |  |  ... and so on ...Basic Paxos where an Acceptor accepts Two Different Values[edit]In the following case, one Proposer achieves acceptance of value V1 by one Acceptor before failing.  A new Proposer prepares the Acceptors that never accepted V1, allowing it to propose V2. Then V2 is accepted by all Acceptors, including the one that initially accepted V1.Proposer    Acceptor     Learner
 |  |       |  |  |       |  |
 X--------->|->|->|       |  |  Prepare(1)
 |<---------X--X--X       |  |  Promise(1,{null,null,null})
 x--------->|  |  |       |  |  Accept!(1,V1)
 |  |       X------------>|->|  Accepted(1,V1)
 !  |       |  |  |       |  |  !! FAIL !!
    |       |  |  |       |  |
    X--------->|->|       |  |  Prepare(2)
    |<---------X--X       |  |  Promise(2,{null,null})
    X------>|->|->|       |  |  Accept!(2,V2)
    |<------X--X--X------>|->|  Accepted(2,V2)
    |       |  |  |       |  |Basic Paxos where a multi-identifier majority is insufficient[edit]In the following case, one Proposer achieves acceptance of value V1 of one Acceptor before failing.  A new Proposer prepares the Acceptors that never accepted V1, allowing it to propose V2. This Proposer is able to get one Acceptor to accept V2 before failing.  A new Proposer finds a majority that includes the Acceptor that has accepted V1, and must propose it. The Proposer manages to get two Acceptors to accept it before failing.  At this point, three Acceptors have accepted V1, but not for the same identifier.  Finally, a new Proposer prepares the majority that has not seen the largest accepted identifier.  The value associated with the largest identifier in that majority is V2, so it must propose it.  This Proposer then gets all Acceptors to accept V2, achieving consensus.Proposer           Acceptor        Learner
 |  |  |  |       |  |  |  |  |       |  |
 X--------------->|->|->|->|->|       |  |  Prepare(1)
 |<---------------X--X--X--X--X       |  |  Promise(1,{null,null,null,null,null})
 x--------------->|  |  |  |  |       |  |  Accept!(1,V1)
 |  |  |  |       X------------------>|->|  Accepted(1,V1)
 !  |  |  |       |  |  |  |  |       |  |  !! FAIL !!
    |  |  |       |  |  |  |  |       |  |
    X--------------->|->|->|->|       |  |  Prepare(2)
    |<---------------X--X--X--X       |  |  Promise(2,{null,null,null,null})
    X--------------->|  |  |  |       |  |  Accept!(2,V2)
    |  |  |       |  X--------------->|->|  Accepted(2,V2)
    !  |  |       |  |  |  |  |       |  |  !! FAIL !!
       |  |       |  |  |  |  |       |  | 
       X--------->|---->|->|->|       |  |  Prepare(3)
       |<---------X-----X--X--X       |  |  Promise(3,{V1,null,null,null})
       X--------------->|->|  |       |  |  Accept!(3,V1)
       |  |       |  |  X--X--------->|->|  Accepted(3,V1)
       !  |       |  |  |  |  |       |  |  !! FAIL !!
          |       |  |  |  |  |       |  |
          X------>|->|------->|       |  |  Prepare(4)
          |<------X--X--|--|--X       |  |  Promise(4,{V1(1),V2(2),null})
          X------>|->|->|->|->|       |  |  Accept!(4,V2)
          |       X--X--X--X--X------>|->|  Accepted(4,V2)Basic Paxos where new Proposers cannot change an existing consensus[edit]In the following case, one Proposer achieves acceptance of value V1 of two Acceptors before failing.  A new Proposer may start another round, but it is now impossible for that proposer to prepare a majority that doesn't include at least one Acceptor that has accepted V1.  As such, even though the Proposer doesn't see the existing consensus, the Proposer's only option is to propose the value already agreed upon.  New Proposers can continually increase the identifier to restart the process, but the consensus can never be changed.Proposer    Acceptor     Learner
 |  |       |  |  |       |  |
 X--------->|->|->|       |  |  Prepare(1)
 |<---------X--X--X       |  |  Promise(1,{null,null,null})
 x--------->|->|  |       |  |  Accept!(1,V1)
 |  |       X--X--------->|->|  Accepted(1,V1)
 !  |       |  |  |       |  |  !! FAIL !!
    |       |  |  |       |  |
    X--------->|->|       |  |  Prepare(2)
    |<---------X--X       |  |  Promise(2,{V1,null})
    X------>|->|->|       |  |  Accept!(2,V1)
    |<------X--X--X------>|->|  Accepted(2,V1)
    |       |  |  |       |  |Multi-Paxos[edit]A typical deployment of Paxos requires a continuous stream of agreed values acting as commands to a distributed state machine.  If each command is the result of a single instance of theBasic Paxosprotocol, a significant amount of overhead would result.If the leader is relatively stable, phase 1 becomes unnecessary. Thus, it is possible to skip phase 1 for future instances of the protocol with the same leader.To achieve this, the round numberIis included along with each value which is incremented in each round by the same Leader.  Multi-Paxos reduces the failure-free message delay (proposal to learning) from 4 delays to 2 delays.Graphic representation of the flow of messages in the Multi-Paxos[edit]Multi-Paxos without failures[edit]In the following diagram, only one instance (or "execution") of the basic Paxos protocol, with an initial Leader (a Proposer), is shown. Note that a Multi-Paxos consists of several instances of the basic Paxos protocol.Client   Proposer      Acceptor     Learner
   |         |          |  |  |       |  | --- First Request ---
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Prepare(N)
   |         |<---------X--X--X       |  |  Promise(N,I,{Va,Vb,Vc})
   |         X--------->|->|->|       |  |  Accept!(N,I,V)
   |         |<---------X--X--X------>|->|  Accepted(N,I,V)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |where V = last of (Va, Vb, Vc).Multi-Paxos when phase 1 can be skipped[edit]In this case, subsequent instances of the basic Paxos protocol (represented byI+1) use the same leader, so the phase 1 (of these subsequent instances of the basic Paxos protocol), which consist of the Prepare and Promise sub-phases, is skipped. Note that the Leader should be stable, i.e. it should not crash or change.Client   Proposer       Acceptor     Learner
   |         |          |  |  |       |  |  --- Following Requests ---
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Accept!(N,I+1,W)
   |         |<---------X--X--X------>|->|  Accepted(N,I+1,W)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |Multi-Paxos when roles are collapsed[edit]A common deployment of the Multi-Paxos consists in collapsing the role of the Proposers, Acceptors and Learners to "Servers". So, in the end, there are only "Clients" and "Servers".The following diagram represents the first "instance" of a basic Paxos protocol, when the roles of the Proposer, Acceptor and Learner are collapsed to a single role, called the "Server".Client      Servers
   |         |  |  | --- First Request ---
   X-------->|  |  |  Request
   |         X->|->|  Prepare(N)
   |         |<-X--X  Promise(N, I, {Va, Vb})
   |         X->|->|  Accept!(N, I, Vn)
   |         X<>X<>X  Accepted(N, I)
   |<--------X  |  |  Response
   |         |  |  |Multi-Paxos when roles are collapsed and the leader is steady[edit]In the subsequent instances of the basic Paxos protocol, with the same leader as in the previous instances of the basic Paxos protocol, the phase 1 can be skipped.Client      Servers
   X-------->|  |  |  Request
   |         X->|->|  Accept!(N,I+1,W)
   |         X<>X<>X  Accepted(N,I+1)
   |<--------X  |  |  Response
   |         |  |  |Optimisations[edit]A number of optimisations can be performed to reduce the number of exchanged messages, to improve the performance of the protocol, etc. A few of these optimisations are reported below."We can save messages at the cost of an extra message delay by having a single distinguished learner that informs the other learners when it finds out that a value has been chosen. Acceptors then sendAcceptedmessages only to the distinguished learner.  In most applications, the roles of leader and distinguished learner are performed by the same processor.[22]"A leader can send itsPrepareandAccept!messages just to a quorum of acceptors. As long as all acceptors in that quorum are working and can communicate with the leader and the learners, there is no need for acceptors not in the quorum to do anything.[22]"Acceptors do not care what value is chosen. They simply respond toPrepareandAccept!messages to ensure that, despite failures, only a single value can be chosen. However, if an acceptor does learn what value has been chosen, it can store the value in stable storage and erase any other information it has saved there. If the acceptor later receives aPrepareorAccept!message, instead of performing its Phase1b or Phase2b action, it can simply inform the leader of the chosen value.[22]"Instead of sending the value v, the leader can send a hash of v to some acceptors in itsAccept!messages. A learner will learn that v is chosen if it receivesAcceptedmessages for either v or its hash from a quorum of acceptors, and at least one of those messages contains v rather than its hash. However, a leader could receivePromisemessages that tell it the hash of a value v that it must use in its Phase2a action without telling it the actual value of v. If that happens, the leader cannot execute its Phase2a action until it communicates with some process that knows v."[22]"A proposer can send its proposal only to the leader rather than to all coordinators. However, this requires that the result of the leader-selection algorithm be broadcast to the proposers, which might be expensive. So, it might be better to let the proposer send its proposal to all coordinators. (In that case, only the coordinators themselves need to know who the leader is.)[15]"Instead of each acceptor sendingAcceptedmessages to each learner, acceptors can send theirAcceptedmessages to the leader and the leader can inform the learners when a value has been chosen. However, this adds an extra message delay.[15]"Finally, observe that phase 1 is unnecessary for round 1 .. The leader of round 1 can begin the round by sending anAccept!message with any proposed value."[15]Cheap Paxos[edit]Cheap Paxos extendsBasic Paxosto tolerate F failures with F+1 main processors and F auxiliary processors by dynamically reconfiguring after each failure.This reduction in processor requirements comes at the expense of liveness; if too many main processors fail in a short time, the system must halt until the auxiliary processors can reconfigure the system.  During stable periods, the auxiliary processors take no part in the protocol."With only two processors p and q, one processor cannot distinguish failure of the other processor from failure of the communication medium. A third processor is needed. However, that third processor does not have to participate in choosing the sequence of commands. It must take action only in case p or q fails, after which it does nothing while either p or q continues to operate the system by itself. The third processor can therefore be a small/slow/cheap one, or a processor primarily devoted to other tasks."[22]Message flow: Cheap Multi-Paxos[edit]An example involving three main acceptors, one auxiliary acceptor and quorum size of three, showing failure of one main processor and subsequent reconfiguration:{  Acceptors  }
Proposer     Main       Aux    Learner
|            |  |  |     |       |  -- Phase 2 --
X----------->|->|->|     |       |  Accept!(N,I,V)
|            |  |  !     |       |  --- FAIL! ---
|<-----------X--X--------------->|  Accepted(N,I,V)
|            |  |        |       |  -- Failure detected (only 2 accepted) --
X----------->|->|------->|       |  Accept!(N,I,V)  (re-transmit, include Aux)
|<-----------X--X--------X------>|  Accepted(N,I,V)
|            |  |        |       |  -- Reconfigure : Quorum = 2 --
X----------->|->|        |       |  Accept!(N,I+1,W) (Aux not participating)
|<-----------X--X--------------->|  Accepted(N,I+1,W)
|            |  |        |       |Fast Paxos[edit]Fast Paxos generalizesBasic Paxosto reduce end-to-end message delays.  In Basic Paxos, the message delay from client request to learning is 3 message delays.  Fast Paxos allows 2 message delays, but requires that (1) the system be composed of3f+ 1acceptors to tolerate up toffaults (instead of the classic 2f+1), and (2) the Client to send its request to multiple destinations.Intuitively, if the leader has no value to propose, then a client could send anAccept!message to the Acceptors directly.  The Acceptors would respond as in Basic Paxos, sendingAcceptedmessages to the leader and every Learner achieving two message delays from Client to Learner.If the leader detects a collision, it resolves the collision by sendingAccept!messages for a new round which areAcceptedas usual.  This coordinated recovery technique requires four message delays from Client to Learner.The final optimization occurs when the leader specifies a recovery technique in advance, allowing the Acceptors to perform the collision recovery themselves.  Thus, uncoordinated collision recovery can occur in three message delays (and only two message delays if all Learners are also Acceptors).Message flow: Fast Paxos, non-conflicting[edit]Client    Leader         Acceptor      Learner
   |         |          |  |  |  |       |  |
   |         X--------->|->|->|->|       |  |  Any(N,I,Recovery)
   |         |          |  |  |  |       |  |
   X------------------->|->|->|->|       |  |  Accept!(N,I,W)
   |         |<---------X--X--X--X------>|->|  Accepted(N,I,W)
   |<------------------------------------X--X  Response(W)
   |         |          |  |  |  |       |  |Message flow: Fast Paxos, conflicting proposals[edit]Conflicting proposals with coordinated recovery.  Note: the protocol does not specify how to handle the dropped client request.Client   Leader      Acceptor     Learner
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |  !! Concurrent conflicting proposals
 |  |      |        |  |  |  |      |  |  !!   received in different order
 |  |      |        |  |  |  |      |  |  !!   by the Acceptors
 |  X--------------?|-?|-?|-?|      |  |  Accept!(N,I,V)
 X-----------------?|-?|-?|-?|      |  |  Accept!(N,I,W)
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |  !! Acceptors disagree on value
 |  |      |<-------X--X->|->|----->|->|  Accepted(N,I,V)
 |  |      |<-------|<-|<-X--X----->|->|  Accepted(N,I,W)
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |  !! Detect collision & recover
 |  |      X------->|->|->|->|      |  |  Accept!(N+1,I,W)
 |  |      |<-------X--X--X--X----->|->|  Accepted(N+1,I,W)
 |<---------------------------------X--X  Response(W)
 |  |      |        |  |  |  |      |  |Conflicting proposals with uncoordinated recovery.Client   Leader      Acceptor     Learner
 |  |      |        |  |  |  |      |  |
 |  |      X------->|->|->|->|      |  |  Any(N,I,Recovery)
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |  !! Concurrent conflicting proposals
 |  |      |        |  |  |  |      |  |  !!   received in different order
 |  |      |        |  |  |  |      |  |  !!   by the Acceptors
 |  X--------------?|-?|-?|-?|      |  |  Accept!(N,I,V)
 X-----------------?|-?|-?|-?|      |  |  Accept!(N,I,W)
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |  !! Acceptors disagree on value
 |  |      |<-------X--X->|->|----->|->|  Accepted(N,I,V)
 |  |      |<-------|<-|<-X--X----->|->|  Accepted(N,I,W)
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |  !! Detect collision & recover
 |  |      |<-------X--X--X--X----->|->|  Accepted(N+1,I,W)
 |<---------------------------------X--X  Response(W)
 |  |      |        |  |  |  |      |  |Message flow: Fast Paxos with uncoordinated recovery, collapsed roles[edit](merged Acceptor/Learner roles)Client         Servers
 |  |         |  |  |  |
 |  |         X->|->|->|  Any(N,I,Recovery)
 |  |         |  |  |  |
 |  |         |  |  |  |  !! Concurrent conflicting proposals
 |  |         |  |  |  |  !!   received in different order
 |  |         |  |  |  |  !!   by the Servers
 |  X--------?|-?|-?|-?|  Accept!(N,I,V)
 X-----------?|-?|-?|-?|  Accept!(N,I,W)
 |  |         |  |  |  |
 |  |         |  |  |  |  !! Servers disagree on value
 |  |         X<>X->|->|  Accepted(N,I,V)
 |  |         |<-|<-X<>X  Accepted(N,I,W)
 |  |         |  |  |  |
 |  |         |  |  |  |  !! Detect collision & recover
 |  |         X<>X<>X<>X  Accepted(N+1,I,W)
 |<-----------X--X--X--X  Response(W)
 |  |         |  |  |  |Generalized Paxos[edit]Generalized consensus explores the relationship between the operations of the replicated state machine and the consensus protocol that implements it.[16]The main discovery involves optimizations of Paxos when conflicting proposals could be applied in any order.  i.e., when the proposed operations arecommutative operationsfor the state machine. In such cases, the conflicting operations can both be accepted, avoiding the delays required for resolving conflicts and re-proposing the rejected operations.This concept is further generalized into ever-growing sequences of commutative operations, some of which are known to be stable (and thus may be executed).  The protocol tracks these sequences ensuring that all proposed operations of one sequence are stabilized before allowing any operation non-commuting with them to become stable.Example[edit]In order to illustrate Generalized Paxos, the example below shows a message flow between two concurrently executing clients and a replicated state machine implementing read/write operations over two distinct registers A and B.Commutativity TableRead(A)Write(A)Read(B)Write(B)Read(A)Write(A)Read(B)Write(B)Note thatin this table indicates operations which are non-commutative.A possible sequence of operations :<1:Read(A), 2:Read(B), 3:Write(B), 4:Read(B), 5:Read(A), 6:Write(A)>Since5:Read(A)commutes with both3:Write(B)and4:Read(B), one possible permutation equivalent to the previous order is the following:<1:Read(A), 2:Read(B), 5:Read(A), 3:Write(B), 4:Read(B), 6:Write(A)>In practice, a commute occurs only when operations are proposed concurrently.Message flow: Generalized Paxos (example)[edit]Responses not shown. Note: message abbreviations differ from previous message flows due to specifics of the protocol, see[23]for a full discussion.Client      Leader  Acceptor       Learner
 |  |         |      |  |  |         |  |  !! New Leader Begins Round
 |  |         X----->|->|->|         |  |  Prepare(N)
 |  |         |<-----X- X- X         |  |  Promise(N,null)
 |  |         X----->|->|->|         |  |  Phase2Start(N,null)
 |  |         |      |  |  |         |  | 
 |  |         |      |  |  |         |  |  !! Concurrent commuting proposals
 |  X------- ?|-----?|-?|-?|         |  |  Propose(ReadA)
 X-----------?|-----?|-?|-?|         |  |  Propose(ReadB)
 |  |         X------X-------------->|->|  Accepted(N,<ReadA,ReadB>)
 |  |         |<--------X--X-------->|->|  Accepted(N,<ReadB,ReadA>)
 |  |         |      |  |  |         |  |
 |  |         |      |  |  |         |  |  !! No Conflict, both accepted
 |  |         |      |  |  |         |  |  Stable = <ReadA, ReadB>
 |  |         |      |  |  |         |  |
 |  |         |      |  |  |         |  |  !! Concurrent conflicting proposals
 X-----------?|-----?|-?|-?|         |  |  Propose(<WriteB,ReadA>)
 |  X--------?|-----?|-?|-?|         |  |  Propose(ReadB)
 |  |         |      |  |  |         |  |
 |  |         X------X-------------->|->|  Accepted(N,<WriteB,ReadA> . <ReadB>)
 |  |         |<--------X--X-------->|->|  Accepted(N,<ReadB> . <WriteB,ReadA>)
 |  |         |      |  |  |         |  |
 |  |         |      |  |  |         |  |  !! Conflict detected, leader chooses
 |  |         |      |  |  |         |  |  commutative order:
 |  |         |      |  |  |         |  |  V = <ReadA, WriteB, ReadB>
 |  |         |      |  |  |         |  |
 |  |         X----->|->|->|         |  |  Phase2Start(N+1,V)
 |  |         |<-----X- X- X-------->|->|  Accepted(N+1,V)
 |  |         |      |  |  |         |  |  Stable = <ReadA, ReadB> .
 |  |         |      |  |  |         |  |           <ReadA, WriteB, ReadB>
 |  |         |      |  |  |         |  |
 |  |         |      |  |  |         |  | !! More conflicting proposals
 X-----------?|-----?|-?|-?|         |  |  Propose(WriteA)
 |  X--------?|-----?|-?|-?|         |  |  Propose(ReadA)
 |  |         |      |  |  |         |  |
 |  |         X------X-------------->|->|  Accepted(N+1,<WriteA> . <ReadA>)
 |  |         |<--------X- X-------->|->|  Accepted(N+1,<ReadA> . <WriteA>)
 |  |         |      |  |  |         |  |
 |  |         |      |  |  |         |  |  !! Leader chooses order:
 |  |         |      |  |  |         |  |  W = <WriteA, ReadA>
 |  |         |      |  |  |         |  |
 |  |         X----->|->|->|         |  |  Phase2Start(N+2,W)
 |  |         |<-----X- X- X-------->|->|  Accepted(N+2,W)
 |  |         |      |  |  |         |  |  Stable = <ReadA, ReadB> .
 |  |         |      |  |  |         |  |           <ReadA, WriteB, ReadB> .
 |  |         |      |  |  |         |  |           <WriteA, ReadA>
 |  |         |      |  |  |         |  |Performance[edit]The above message flow shows us that Generalized Paxos can leverage operation semantics to avoid collisions when the spontaneous ordering of the network fails. This allows the protocol to be in practice quicker than Fast Paxos. However, when a collision occurs, Generalized Paxos needs two additional round trips to recover. This situation is illustrated with operations WriteB and ReadB in the above schema.In the general case, such round trips are unavoidable and come from the fact that multiple commands can be accepted during a round. This makes the protocol more expensive than Paxos when conflicts are frequent. Hopefully two possible refinements of Generalized Paxos are possible to improve recovery time.[24]First, if the coordinator is part of every quorum of acceptors (round N is saidcentered), then to recover at round N+1 from a collision at round N, the coordinator skips phase 1 and proposes at phase 2 the sequence it accepted last during round N. This reduces the cost of recovery to a single round trip.Second, if both rounds N and N+1 use a unique and identical centered quorum, when an acceptor detects a collision at round N, it spontaneously proposes at round N+1 a sequence suffixing both (i) the sequence accepted at round N by the coordinator and (ii) the greatest non-conflicting prefix it accepted at round N. For instance, if the coordinator and the acceptor accepted respectively at round N <WriteB, ReadB>  and <ReadB, ReadA> , the acceptor will spontaneously accept <WriteB, ReadB, ReadA> at round N+1. With this variation, the cost of recovery is a single message delay which is obviously optimal. Notice here that the use of a unique quorum at a round does not harm liveness. This comes from the fact that any process in this quorum is a read quorum for the prepare phase of the next rounds.[25]Byzantine Paxos[edit]Paxos may also be extended to support arbitrary failures of the participants, including lying, fabrication of messages, collusion with other participants, selective non-participation, etc.  These types of failures are calledByzantine failures, after the solution popularized by Lamport.[26]Byzantine Paxos[27]introduced by Castro andLiskovadds an extra message (Verify) which acts to distribute knowledge and verify the actions of the other processors:Message flow: Byzantine Multi-Paxos, steady state[edit]Client   Proposer      Acceptor     Learner
   |         |          |  |  |       |  |
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Accept!(N,I,V)
   |         |          X<>X<>X       |  |  Verify(N,I,V) - BROADCAST
   |         |<---------X--X--X------>|->|  Accepted(N,V)
   |<---------------------------------X--X  Response(V)
   |         |          |  |  |       |  |Fast Byzantine Paxos[28]introduced by Martin andAlvisiremoves this extra delay, since the client sends commands directly to the Acceptors.Note theAcceptedmessage in Fast Byzantine Paxos is sent to all Acceptors and all Learners, while Fast Paxos sendsAcceptedmessages only to Learners):Message flow: Fast Byzantine Multi-Paxos, steady state[edit]Client    Acceptor     Learner
   |      |  |  |       |  |
   X----->|->|->|       |  |  Accept!(N,I,V)
   |      X<>X<>X------>|->|  Accepted(N,I,V) - BROADCAST
   |<-------------------X--X  Response(V)
   |      |  |  |       |  |The failure scenario is the same for both protocols;  Each Learner waits to receive F+1 identical messages from different Acceptors.  If this does not occur, the Acceptors themselves will also be aware of it (since they exchanged each other's messages in the broadcast round), and correct Acceptors will re-broadcast the agreed value:Message flow: Fast Byzantine Multi-Paxos, failure[edit]Client    Acceptor     Learner
   |      |  |  !       |  |  !! One Acceptor is faulty
   X----->|->|->!       |  |  Accept!(N,I,V)
   |      X<>X<>X------>|->|  Accepted(N,I,{V,W}) - BROADCAST
   |      |  |  !       |  |  !! Learners receive 2 different commands
   |      |  |  !       |  |  !! Correct Acceptors notice error and choose
   |      X<>X<>X------>|->|  Accepted(N,I,V) - BROADCAST
   |<-------------------X--X  Response(V)
   |      |  |  !       |  |Adapting Paxos for RDMA networks[edit]With the emergence of very high speed reliable datacenter networks that support remote DMA (RDMA), there has been substantial interest in optimizing Paxos to leverage hardware offloading, in which the network interface card and network routers provide reliability and network-layer congestion control, freeing the host CPU for other tasks.  TheDerecho C++ Paxos libraryis an open-source Paxos implementation that explores this option.[12]Derecho offers both a classic Paxos, with data durability across full shutdown/restart sequences, and vertical Paxos (atomic multicast), for in-memory replication and state-machine synchronization.  The Paxos protocols employed by Derecho needed to be adapted to maximize asynchronous data streaming and remove other sources of delay on the leader's critical path.  So doing enables Derecho to sustain the full bidirectional RDMA data rate.  In contrast, although traditional Paxos protocols can be migrated to an RDMA network by simply mapping the message send operations to native RDMA operations, doing so leaves round-trip delays on the critical path.  In high-speed RDMA networks, even small delays can be large enough to prevent utilization of the full potential bandwidth.Production use of Paxos[edit]This sectionneeds additional citations forverification.Please helpimprove this articlebyadding citations to reliable sourcesin this section. Unsourced material may be challenged and removed.Find sources:"Paxos" computer science–news·newspapers·books·scholar·JSTOR(October 2018)(Learn how and when to remove this message)Google uses the Paxos algorithm in their Chubbydistributed lock servicein order to keep replicas consistent in case of failure.[29]Chubby is used byBigtablewhich is now in production in Google Analytics and other products.Google Spannerand Megastore use the Paxos algorithm internally.TheOpenReplica replication serviceuses Paxos to maintain replicas for an open access system that enables users to create fault-tolerant objects. It provides high performance through concurrent rounds and flexibility through dynamic membership changes.IBM supposedly uses the Paxos algorithm in theirIBM SAN Volume Controllerproduct to implement a general purpose fault-tolerant virtual machine used to run the configuration and control components of thestorage virtualizationservices offered by the cluster. (Original MIT & IBM research paper)Microsoft uses Paxos in theAutopilot cluster management servicefrom Bing, and in Windows Server Failover Clustering.WANdiscohave implemented Paxos within their DConE active-active replication technology.[30]XtreemFSuses a Paxos-basedleasenegotiation algorithm for fault-tolerant and consistent replication of file data and metadata.[31]Heroku usesDoozerdwhich implements Paxos for its consistent distributed data store.Cephuses Paxos as part of the monitor processes to agree which OSDs are up and in the cluster.TheMariaDB Xpanddistributed SQL database uses Paxos fordistributed transaction resolution.Neo4jHA graph database implements Paxos, replacingApache ZooKeeperfrom v1.9Apache CassandraNoSQL database uses Paxos forLight Weight Transaction feature onlyScyllaDBNoSQL database uses Paxos forLight Weight TransactionsAmazon Elastic Container Services uses Paxos to maintaina consistent view of cluster stateAmazon DynamoDB uses the Paxos algorithm forleader election and consensus.See also[edit]Two generals problemChandra–Toueg consensus algorithmState machineRaftReferences[edit]^Pease, Marshall; Shostak, Robert; Lamport, Leslie (April 1980)."Reaching Agreement in the Presence of Faults".Journal of the Association for Computing Machinery.27(2): 228–234.doi:10.1145/322186.322188.S2CID6429068. Retrieved2007-02-02.^Lamport, Leslie (July 1978)."Time, Clocks and the Ordering of Events in a Distributed System".Communications of the ACM.21(7): 558–565.doi:10.1145/359545.359563.S2CID215822405. Retrieved2007-02-02.^Schneider, Fred (1990)."Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial"(PDF).ACM Computing Surveys.22(4): 299–319.CiteSeerX10.1.1.69.1536.doi:10.1145/98163.98167.S2CID678818.^Leslie Lamport's history of the paper^Lamport, Leslie (May 1998)."The Part-Time Parliament".ACM Transactions on Computer Systems.16(2): 133–169.doi:10.1145/279227.279229.S2CID421028. Retrieved2007-02-02.^abFischer, M. (April 1985)."Impossibility of distributed consensus with one faulty process".Journal of the ACM.32(2): 374–382.doi:10.1145/3149.214121.S2CID207660233.^Dwork, Cynthia; Lynch, Nancy; Stockmeyer, Larry (April 1988)."Consensus in the Presence of Partial Synchrony"(PDF).Journal of the ACM.35(2): 288–323.CiteSeerX10.1.1.13.3423.doi:10.1145/42282.42283.S2CID17007235.^Oki, Brian; Liskov, Barbara (1988)."Viewstamped Replication: A New Primary Copy Method to Support Highly-Available Distributed Systems".PODC '88: Proceedings of the seventh annualACM Symposium on Principles of Distributed Computing. pp. 8–17.doi:10.1145/62546.62549.^Birman, Kenneth; Joseph, Thomas (February 1987). "Reliable Communication in the Presence of Failures".ACM Transactions on Computer Systems.5: 47–76.doi:10.1145/7351.7478.hdl:1813/6534.S2CID11224827.^Lamport, Leslie; Malkhi, Dahlia; Zhou, Lidong (March 2010). "Reconfiguring a State Machine".SIGACT News.41(1): 63–73.CiteSeerX10.1.1.212.2168.doi:10.1145/1753171.1753191.S2CID15189602.^Keidar, Idit; Shraer, Alexander (2006). "Timeliness, failure-detectors, and consensus performance.".PODC '06: Proceedings of the 25th Annual ACM Symposium on Principles of Distributed Computing.doi:10.1145/1146381.1146408.^abJha, Sagar; Behrens, Jonathan; Gkountouvas, Theo; Milano, Matthew; Song, Weijia; Tremel, Edward; van Renesse, Robbert; Zink, Sydney; Birman, Ken (April 2019). "Derecho: Fast State Machine Replication for Cloud Services".ACM Transactions on Computer Systems.36(2).doi:10.1145/3302258.S2CID218482757.^Lamport, Leslie (2004)."Lower Bounds for Asynchronous Consensus".^Van Renesse, Robbert; Altinbuken, Deniz (2015-02-17)."Paxos Made Moderately Complex".ACM Computing Surveys.47(3): 42:1–42:36.doi:10.1145/2673577.ISSN0360-0300.^abcdeLamport, Leslie (2005)."Fast Paxos".^abcdLamport, Leslie (2005)."Generalized Consensus and Paxos".{{cite journal}}:Cite journal requires|journal=(help)^Chandra, Tushar; Griesemer, Robert; Redstone, Joshua (2007). "Paxos made live".Proceedings of the twenty-sixth annual ACM symposium on Principles of distributed computing. pp. 398–407.doi:10.1145/1281100.1281103.ISBN9781595936165.S2CID207164635.^Quesada Torres, Luis (2018).The Paxos Algorithm. Google TechTalks.^Lamport, Leslie (2001).Paxos Made SimpleACM SIGACT News (Distributed Computing Column) 32, 4 (Whole Number 121, December 2001) 51-58.^"Leader Election, Why Should I Care?".Elastic Blog. 13 September 2013. Retrieved27 February2021.^I. Gupta, R. van Renesse, and K. P. Birman, 2000, A Probabilistically Correct Leader Election Protocol for Large Groups,Technical Report, Cornell University^abcdeLamport, Leslie; Massa, Mike (2004)."Cheap Paxos".Proceedings of theInternational Conference on Dependable Systems and Networks(DSN 2004).^Turner, Bryan (2007)."The Paxos Family of Consensus Protocols".^Pierre, Sutra; Marc, Shapiro (2011)."Fast Genuine Generalized Consensus"(PDF).SRDS'11: 30th IEEE Symposium on Reliable Distributed Systems.^Lamport, Leslie; Malkhi, Dahlia; Zhou, Lidong (2009). "Vertical paxos and primary-backup replication".Proceedings of the 28th ACM symposium on Principles of distributed computing. PODC '09. New York, NY, USA: ACM. pp. 312–313.CiteSeerX10.1.1.150.1791.doi:10.1145/1582716.1582783.ISBN9781605583969.S2CID2763624.^Lamport, Leslie; Shostak, Robert; Pease, Marshall (July 1982)."The Byzantine Generals Problem".ACM Transactions on Programming Languages and Systems.4(3): 382–401.CiteSeerX10.1.1.64.2312.doi:10.1145/357172.357176.S2CID55899582. Retrieved2007-02-02.^Castro, Miguel; Liskov, Barbara (February 1999)."Practical Byzantine Fault Tolerance"(PDF).Proceedings of the Third Symposium on Operating Systems Design and Implementation: 173–186. Retrieved5 March2018.^Martin, Jean-Philippe; Alvisi, Lorenzo (July 2006)."Fast Byzantine Consensus"(PDF).IEEE Transactions on Dependable and Secure Computing.3(3): 202–215.doi:10.1109/TDSC.2006.35. Retrieved5 March2018.^Burrows, Mike."The Chubby lock service for loosely-coupled distributed systems"(PDF). OSDI.^Aahlad et al.(2011).“The Distributed Coordination Engine (DConE)”Archived2016-04-15 at theWayback Machine. WANdisco white paper.^Kolbeck, Björn; Högqvist, Mikael; Stender, Jan; Hupfeld, Felix (2011).“Flease - Lease Coordination without a Lock Server”. 25th IEEE International Parallel & Distributed Processing Symposium (IPDPS 2011).External links[edit]Leslie Lamport's home pagePaxos Made SimplePaxos Made Moderately ComplexRevisiting the Paxos AlgorithmPaxos CommitGoogle Whitepaper: Chubby Distributed Lock ServiceGoogle Whitepaper: Bigtable A Distributed Storage System for Structured DataSurvey of Paxos Algorithms (2007)OpenReplica Open Replication ServiceFTFile: Fault Tolerant File libraryIsis2 library (the SafeSend primitive is a free, open source implementation of Paxos)Mencius - Circular rotating Paxos for geo-distributed systemsWANdisco - Active-Active Replication solutions for Hadoop, Subversion & GITlibpaxos, a collection of open source implementations of the Paxos algorithmlibpaxos-cpp, a C++ implementation of the paxos distributed consensus algorithmJBP - Java Byzantine Paxoserlpaxos, Paxos by Erlangpaxos - Straight-forward paxos implementation in Python & JavaManhattan Paxos (mpaxos), Paxos in C, supporting multiple paxos groups and efficient transactions across them.Clustering with Neo4jHT-PaxosPaxosStore, paxos implementation in WeChatLWT in CassandraGoogle TechTalks: The Paxos AlgorithmRetrieved from "https://en.wikipedia.org/w/index.php?title=Paxos_(computer_science)&oldid=1238153610"Categories:Distributed algorithmsFault-tolerant computer systemsHidden categories:CS1 errors: missing periodicalWebarchive template wayback linksArticles with short descriptionShort description is different from WikidataWikipedia articles needing clarification from October 2018Articles to be expanded from July 2024Articles needing additional references from October 2018All articles needing additional referencesThis page was last edited on 2 August 2024, at 11:30(UTC).Text is available under theCreative Commons Attribution-ShareAlike License 4.0;
additional terms may apply. By using this site, you agree to theTerms of UseandPrivacy Policy. Wikipedia® is a registered trademark of theWikimedia Foundation, Inc., a non-profit organization.Privacy policyAbout WikipediaDisclaimersContact WikipediaCode of ConductDevelopersStatisticsCookie statementMobile view