URL: https://etcd.io/docs/v3.6/op-guide/kubernetes/

etcdDocsBlogCommunityInstallPlayVersionsv3.6v3.5v3.4v3.3v3.2v3.1v2.3Versionsv3.6-DRAFTQuickstartDemoTutorialsHow to Set Up a Demo etcd ClusterReading from etcdWriting to etcdHow to get keys by prefixHow to delete keysHow to make multiple writes in a transactionHow to watch keysHow to create leaseHow to create locksHow to conduct leader election in etcd clusterHow to check Cluster statusHow to save the databaseHow to migrate etcd from v2 to v3How to Add and Remove MembersInstallFAQLibraries and toolsMetricsReporting bugsTuningDiscovery service protocolLogging conventionsGolang modulesLearningData modeletcd client designetcd learner designetcd v3 authentication designetcd APIetcd persistent storage filesetcd API guaranteesetcd versus other key-value storesGlossaryDeveloper guideDiscovery service protocolSet up a local clusterInteracting with etcdWhy gRPC gatewaygRPC naming and discoverySystem limitsetcd featuresAPI referenceAPI reference: concurrencyOperations guideAuthentication GuidesRole-based access controlAuthenticationConfiguration optionsTransport security modelClustering GuideRun etcd clusters as a Kubernetes StatefulSetRun etcd clusters inside containersFailure modesDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMonitoring etcdPerformanceDesign of runtime reconfigurationRuntime reconfigurationSupported platformsVersioningData CorruptionBenchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkBenchmarking etcd v3Benchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0Benchmarking etcd v2.1.0UpgradingUpgrading etcd clusters and applicationsUpgrade etcd from 3.4 to 3.5Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.0 to 3.1Upgrade etcd from 2.3 to 3.0TriageIssue triage guidelinesPR managementv3.5QuickstartDemoTutorialsHow to Set Up a Demo etcd ClusterReading from etcdWriting to etcdHow to get keys by prefixHow to delete keysHow to make multiple writes in a transactionHow to watch keysHow to create leaseHow to create locksHow to conduct leader election in etcd clusterHow to check Cluster statusHow to save the databaseHow to migrate etcd from v2 to v3How to Add and Remove MembersInstallFAQLibraries and toolsMetricsReporting bugsTuningDiscovery service protocolLogging conventionsGolang modulesLearningData modeletcd client designetcd learner designetcd v3 authentication designetcd APIetcd persistent storage filesetcd API guaranteesetcd versus other key-value storesGlossaryDeveloper guideDiscovery service protocolSet up a local clusterInteracting with etcdWhy gRPC gatewaygRPC naming and discoverySystem limitsetcd featuresAPI referenceAPI reference: concurrencyOperations guideAuthentication GuidesRole-based access controlAuthenticationConfiguration optionsTransport security modelClustering GuideRun etcd clusters as a Kubernetes StatefulSetRun etcd clusters inside containersFailure modesDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMonitoring etcdPerformanceDesign of runtime reconfigurationRuntime reconfigurationSupported platformsVersioningData CorruptionBenchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkBenchmarking etcd v3Benchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0Benchmarking etcd v2.1.0DowngradingDowngrading etcd clusters and applicationsDowngrade etcd from 3.5 to 3.4UpgradingUpgrading etcd clusters and applicationsUpgrade etcd from 3.4 to 3.5Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.0 to 3.1Upgrade etcd from 2.3 to 3.0TriageIssue triage guidelinesPR managementv3.4QuickstartOverviewDemoInstallFAQLibraries and toolsMetricsReporting bugsTuningDiscovery service protocolLogging conventionsLearningData modeletcd client designetcd learner designetcd v3 authentication designetcd3 APIetcd API guaranteesetcd versus other key-value storesGlossaryDeveloper guideDiscovery service protocolSet up a local clusterInteracting with etcdWhy gRPC gatewaygRPC naming and discoverySystem limitsetcd featuresAPI referenceAPI reference: concurrencyOperations guideConfiguration optionsRole-based access controlTransport security modelClustering GuideRun etcd clusters inside containersFailure modesDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenancePerformanceDesign of runtime reconfigurationRuntime reconfigurationSupported platformsMigrate applications from using API v2 to API v3VersioningData CorruptionMonitoring etcdBenchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkBenchmarking etcd v3Benchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0Benchmarking etcd v2.1.0UpgradingUpgrading etcd clusters and applicationsUpgrade etcd from 3.4 to 3.5Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.0 to 3.1Upgrade etcd from 2.3 to 3.0PlatformsAmazon Web ServicesContainer Linux with systemdFreeBSDTriageIssue Triage Guidelinesv3.3InstallLibraries and toolsMetricsBenchmarksBenchmarking etcd v2.1.0Benchmarking etcd v2.2.0Benchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v3Storage Memory Usage BenchmarkWatch Memory Usage BenchmarkDemoDeveloper guideDiscovery service protocoletcd API Referenceetcd concurrency API ReferenceExperimental APIs and featuresgRPC naming and discoveryInteracting with etcdSet up a local clusterSystem limitsWhy gRPC gatewayDiscovery service protocoletcd v3 APIFrequently Asked Questions (FAQ)Learningetcd client architectureClient feature matrixData modeletcd v3 authentication designetcd versus other key-value storesetcd3 APIGlossaryKV API guaranteesLearnerLogging conventionsOperations guideMonitoring etcdVersioningClustering GuideConfiguration flagsDesign of runtime reconfigurationDisaster recoveryetcd gatewayFailure modesgRPC proxyHardware recommendationsMaintenanceMigrate applications from using API v2 to API v3PerformanceRole-based access controlRun etcd clusters inside containersRuntime reconfigurationSupported systemsTransport security modelPlatformsAmazon Web ServicesContainer Linux with systemdFreeBSDProduction usersReporting bugsTuningUpgradingUpgrade etcd from 2.3 to 3.0Upgrade etcd from 3.0 to 3.1Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.3 to 3.4Upgrade etcd from 3.4 to 3.5Upgrading etcd clusters and applicationsv3.2BenchmarksBenchmarking etcd v2.1.0Benchmarking etcd v2.2.0Benchmarking etcd v2.2.0-rcBenchmarking etcd v2.2.0-rc-memoryBenchmarking etcd v3-demoStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkData modelDemoDeveloper guideDiscovery service protocoletcd API referenceetcd concurrency API ReferenceExperimental APIs and featuresgRPC gatewaygRPC naming and discoveryInteracting with etcdSet up a local clusterSystem limitsetcd dev internalDiscovery service protocolLogging conventionsetcd operations guideAuthentication GuideClustering GuideConfiguration flagsDesign of runtime reconfigurationDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMigrate applications from using API v2 to API v3Monitoring etcdPerformanceRun etcd clusters inside containersRuntime reconfigurationSecurity modelSupported platformsUnderstand failuresVersioningetcd upgradesUpgrade etcd from 2.3 to 3.0Upgrade etcd from 3.0 to 3.1Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.3 to 3.4Upgrading etcd clusters and applicationsetcd v3 authentication designetcd versus other key-value storesetcd3 APIFrequently Asked Questions (FAQ)GlossaryInstallKV API guaranteesLibraries and toolsMetricsPlatformsAmazon Web ServicesFreeBSDRun etcd on Container Linux with systemdProduction usersReporting bugsRFCetcd v3 APITuningv3.1Data modelDemoetcd benchmarksetcd v2.1.0-alpha benchmarksetcd v2.2.0 benchmarksetcd v2.2.0-rc benchmarksetcd v2.2.0-rc-memory benchmarksetcd v3-demo benchmarksStorage Memory Usage BenchmarkWatch Memory Usage Benchmarketcd developer guideDiscovery service protocoletcd API ReferenceExperimental APIs and featuresgRPC GatewaygRPC naming and discoveryInteracting with etcdSetup a local clusterSystem limitsetcd internal devDiscovery service protocolLogging conventionsetcd operations guideClustering GuideConfiguration flagsDesign of runtime reconfigurationDisaster recoveryetcd gatewaygRPC proxyHardware recommendationsMaintenanceMigrate applications from using API v2 to API v3Monitoring etcdPerformanceRun etcd clusters inside containersRuntime reconfigurationSecurity modelSupported platformsUnderstand failuresVersioningetcd3 APIFrequently Asked Questions (FAQ)GlossaryInstallKV API guaranteesLibraries and toolsMetricsPlatformsFreeBSDProduction usersReporting bugsRFCetcd v3 APITuningUpgrading etcd clusters and applicationsUpgrade etcd from 2.3 to 3.0Upgrade etcd from 3.0 to 3.1Upgrade etcd from 3.1 to 3.2Upgrade etcd from 3.2 to 3.3Upgrade etcd from 3.3 to 3.4Why etcdv2.3AdministrationAuthentication GuideBackward CompatibilityBenchmarksBenchmarking etcd v2.2.0etcd 2.1.0-alpha benchmarksetcd 2.2.0-rc benchmarksetcd 2.2.0-rc memory benchmarksetcd 3 demo benchmarksStorage Memory Usage BenchmarkWatch Memory Usage BenchmarkClustering GuideConfiguration FlagsDesign of Runtime ReconfigurationDevelopmentDiscovery Service ProtocolError Codeetcd APIetcd v3 APIFAQGlossaryLibraries and ToolsMembers APIMetricsMiscellaneous APIsPlatformsFreeBSProduction UsersProxyReporting BugsRunning etcd under DockerRuntime ReconfigurationSecurity ModelSnapshot MigrationTuningUpgrade etcd from 2.1 to 2.2Upgrade etcd from 2.1 to 2.2Upgrade etcd from 2.2 to 2.3v2 Auth and SecurityVersioningView page sourceEdit this pageCreate child pageCreate documentation issueCreate project issueExample ManifestGenerating CertificatesVersionsv3.6-DRAFTOperations guideRun etcd clusters as a Kubernetes StatefulSetRun etcd clusters as a Kubernetes StatefulSetRunning etcd as a Kubernetes StatefulSetBelow demonstrates how to perform thestatic bootstrap processas a Kubernetes StatefulSet.Example ManifestThis manifest contains a service and statefulset for deploying a static etcd cluster in kubernetes.If you copy the contents of the manifest into a file namedetcd.yaml, it can be applied to a cluster with this command.$ kubectl apply --filename etcd.yamlUpon being applied, wait for the pods to become ready.$ kubectl get podsNAME     READY   STATUS    RESTARTS   AGEetcd-0   1/1     Running024metcd-1   1/1     Running024metcd-2   1/1     Running024mThe container used in the example includes etcdctl and can be called directly inside the pods.$ kubectlexec-it etcd-0 -- etcdctl member list -wtable+------------------+---------+--------+-------------------------+-------------------------+------------+|ID|STATUS|NAME|PEER ADDRS|CLIENT ADDRS|IS LEARNER|+------------------+---------+--------+-------------------------+-------------------------+------------+|4f98c3545405a0b0|started|etcd-2|http://etcd-2.etcd:2380|http://etcd-2.etcd:2379|false||a394e0ee91773643|started|etcd-0|http://etcd-0.etcd:2380|http://etcd-0.etcd:2379|false||d10297b8d2f01265|started|etcd-1|http://etcd-1.etcd:2380|http://etcd-1.etcd:2379|false|+------------------+---------+--------+-------------------------+-------------------------+------------+To deploy with a self-signed certificate, refer to the commented configuration headings starting with## TLSto find values that you can uncomment. Additional instructions for generating a cert with cert-manager is included in a section below.# file: etcd.yaml---apiVersion:v1kind:Servicemetadata:name:etcdnamespace:defaultspec:type:ClusterIPclusterIP:Noneselector:app:etcd#### Ideally we would use SRV records to do peer discovery for initialization.## Unfortunately discovery will not work without logic to wait for these to## populate in the container. This problem is relatively easy to overcome by## making changes to prevent the etcd process from starting until the records## have populated. The documentation on statefulsets briefly talk about it.##   https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-idpublishNotReadyAddresses:true#### The naming scheme of the client and server ports match the scheme that etcd## uses when doing discovery with SRV records.ports:-name:etcd-clientport:2379-name:etcd-serverport:2380-name:etcd-metricsport:8080---apiVersion:apps/v1kind:StatefulSetmetadata:namespace:defaultname:etcdspec:#### The service name is being set to leverage the service headlessly.## https://kubernetes.io/docs/concepts/services-networking/service/#headless-servicesserviceName:etcd#### If you are increasing the replica count of an existing cluster, you should## also update the --initial-cluster-state flag as noted further down in the## container configuration.replicas:3#### For initialization, the etcd pods must be available to eachother before## they are "ready" for traffic. The "Parallel" policy makes this possible.podManagementPolicy:Parallel#### To ensure availability of the etcd cluster, the rolling update strategy## is used. For availability, there must be at least 51% of the etcd nodes## online at any given time.updateStrategy:type:RollingUpdate#### This is label query over pods that should match the replica count.## It must match the pod template's labels. For more information, see the## following documentation:##   https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectorsselector:matchLabels:app:etcd#### Pod configuration template.template:metadata:#### The labeling here is tied to the "matchLabels" of this StatefulSet and## "affinity" configuration of the pod that will be created.#### This example's labeling scheme is fine for one etcd cluster per## namespace, but should you desire multiple clusters per namespace, you## will need to update the labeling schema to be unique per etcd cluster.labels:app:etcdannotations:#### This gets referenced in the etcd container's configuration as part of## the DNS name. It must match the service name created for the etcd## cluster. The choice to place it in an annotation instead of the env## settings is because there should only be 1 service per etcd cluster.serviceName:etcdspec:#### Configuring the node affinity is necessary to prevent etcd servers from## ending up on the same hardware together.#### See the scheduling documentation for more information about this:##   https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinityaffinity:## The podAntiAffinity is a set of rules for scheduling that describe## when NOT to place a pod from this StatefulSet on a node.podAntiAffinity:#### When preparing to place the pod on a node, the scheduler will check## for other pods matching the rules described by the labelSelector## separated by the chosen topology key.requiredDuringSchedulingIgnoredDuringExecution:## This label selector is looking for app=etcd-labelSelector:matchExpressions:-key:appoperator:Invalues:-etcd## This topology key denotes a common label used on nodes in the## cluster. The podAntiAffinity configuration essentially states## that if another pod has a label of app=etcd on the node, the## scheduler should not place another pod on the node.##   https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetesiohostnametopologyKey:"kubernetes.io/hostname"#### Containers in the podcontainers:## This example only has this etcd container.-name:etcdimage:quay.io/coreos/etcd:v3.5.15imagePullPolicy:IfNotPresentports:-name:etcd-clientcontainerPort:2379-name:etcd-servercontainerPort:2380-name:etcd-metricscontainerPort:8080#### These probes will fail over TLS for self-signed certificates, so etcd## is configured to deliver metrics over port 8080 further down.#### As mentioned in the "Monitoring etcd" page, /readyz and /livez were## added in v3.5.12. Prior to this, monitoring required extra tooling## inside the container to make these probes work.#### The values in this readiness probe should be further validated, it## is only an example configuration.readinessProbe:httpGet:path:/readyzport:8080initialDelaySeconds:10periodSeconds:5timeoutSeconds:5successThreshold:1failureThreshold:30## The values in this liveness probe should be further validated, it## is only an example configuration.livenessProbe:httpGet:path:/livezport:8080initialDelaySeconds:15periodSeconds:10timeoutSeconds:5failureThreshold:3env:#### Environment variables defined here can be used by other parts of the## container configuration. They are interpreted by Kubernetes, instead## of in the container environment.#### These env vars pass along information about the pod.-name:K8S_NAMESPACEvalueFrom:fieldRef:fieldPath:metadata.namespace-name:HOSTNAMEvalueFrom:fieldRef:fieldPath:metadata.name-name:SERVICE_NAMEvalueFrom:fieldRef:fieldPath:metadata.annotations['serviceName']#### Configuring etcdctl inside the container to connect to the etcd node## in the container reduces confusion when debugging.-name:ETCDCTL_ENDPOINTSvalue:$(HOSTNAME).$(SERVICE_NAME):2379#### TLS client configuration for etcdctl in the container.## These files paths are part of the "etcd-client-certs" volume mount.# - name: ETCDCTL_KEY#   value: /etc/etcd/certs/client/tls.key# - name: ETCDCTL_CERT#   value: /etc/etcd/certs/client/tls.crt# - name: ETCDCTL_CACERT#   value: /etc/etcd/certs/client/ca.crt#### Use this URI_SCHEME value for non-TLS clusters.-name:URI_SCHEMEvalue:"http"## TLS: Use this URI_SCHEME for TLS clusters.# - name: URI_SCHEME# value: "https"#### If you're using a different container, the executable may be in a## different location. This example uses the full path to help remove## ambiguity to you, the reader.## Often you can just use "etcd" instead of "/usr/local/bin/etcd" and it## will work because the $PATH includes a directory containing "etcd".command:-/usr/local/bin/etcd#### Arguments used with the etcd command inside the container.args:#### Configure the name of the etcd server.- --name=$(HOSTNAME)#### Configure etcd to use the persistent storage configured below.- --data-dir=/data#### In this example we're consolidating the WAL into sharing space with## the data directory. This is not ideal in production environments and## should be placed in it's own volume.- --wal-dir=/data/wal#### URL configurations are parameterized here and you shouldn't need to## do anything with these.- --listen-peer-urls=$(URI_SCHEME)://0.0.0.0:2380- --listen-client-urls=$(URI_SCHEME)://0.0.0.0:2379- --advertise-client-urls=$(URI_SCHEME)://$(HOSTNAME).$(SERVICE_NAME):2379#### This must be set to "new" for initial cluster bootstrapping. To scale## the cluster up, this should be changed to "existing" when the replica## count is increased. If set incorrectly, etcd makes an attempt to## start but fail safely.- --initial-cluster-state=new#### Token used for cluster initialization. The recommendation for this is## to use a unique token for every cluster. This example parameterized## to be unique to the namespace, but if you are deploying multiple etcd## clusters in the same namespace, you should do something extra to## ensure uniqueness amongst clusters.- --initial-cluster-token=etcd-$(K8S_NAMESPACE)#### The initial cluster flag needs to be updated to match the number of## replicas configured. When combined, these are a little hard to read.## Here is what a single parameterized peer looks like:##   etcd-0=$(URI_SCHEME)://etcd-0.$(SERVICE_NAME):2380- --initial-cluster=etcd-0=$(URI_SCHEME)://etcd-0.$(SERVICE_NAME):2380,etcd-1=$(URI_SCHEME)://etcd-1.$(SERVICE_NAME):2380,etcd-2=$(URI_SCHEME)://etcd-2.$(SERVICE_NAME):2380#### The peer urls flag should be fine as-is.- --initial-advertise-peer-urls=$(URI_SCHEME)://$(HOSTNAME).$(SERVICE_NAME):2380#### This avoids probe failure if you opt to configure TLS.- --listen-metrics-urls=http://0.0.0.0:8080#### These are some configurations you may want to consider enabling, but## should look into further to identify what settings are best for you.# - --auto-compaction-mode=periodic# - --auto-compaction-retention=10m#### TLS client configuration for etcd, reusing the etcdctl env vars.# - --client-cert-auth# - --trusted-ca-file=$(ETCDCTL_CACERT)# - --cert-file=$(ETCDCTL_CERT)# - --key-file=$(ETCDCTL_KEY)#### TLS server configuration for etcdctl in the container.## These files paths are part of the "etcd-server-certs" volume mount.# - --peer-client-cert-auth# - --peer-trusted-ca-file=/etc/etcd/certs/server/ca.crt# - --peer-cert-file=/etc/etcd/certs/server/tls.crt# - --peer-key-file=/etc/etcd/certs/server/tls.key#### This is the mount configuration.volumeMounts:-name:etcd-datamountPath:/data#### TLS client configuration for etcdctl# - name: etcd-client-tls#   mountPath: "/etc/etcd/certs/client"#   readOnly: true#### TLS server configuration# - name: etcd-server-tls#   mountPath: "/etc/etcd/certs/server"#   readOnly: truevolumes:#### TLS client configuration# - name: etcd-client-tls#   secret:#     secretName: etcd-client-tls#     optional: false#### TLS server configuration# - name: etcd-server-tls#   secret:#     secretName: etcd-server-tls#     optional: false#### This StatefulSet will uses the volumeClaimTemplate field to create a PVC in## the cluster for each replica. These PVCs can not be easily resized later.volumeClaimTemplates:-metadata:name:etcd-dataspec:accessModes:["ReadWriteOnce"]#### In some clusters, it is necessary to explicitly set the storage class.## This example will end up using the default storage class.# storageClassName: ""resources:requests:storage:1GiGenerating CertificatesIn this section, we useHelmto install an operator calledcert-manager.With cert-manager installed in the cluster, self-signed certificates can be generated in the cluster. These generated certificates get placed inside a secret object that can be attached as files in containers.This is the helm command to install cert-manager.$ helm upgrade --install --create-namespace --namespace cert-manager cert-manager cert-manager --repo https://charts.jetstack.io --set crds.enabled=trueThis is an example ClusterIssuer configuration for generating self-signed certificates.# file: issuer.yamlapiVersion:cert-manager.io/v1kind:ClusterIssuermetadata:name:selfsignedspec:selfSigned:{}This manifest creates Certificate objects for the client and server certs, referencing the ClusterIssuer “selfsigned”. The dnsNames should be an exhaustive list of valid hostnames for the certificates that cert-manager creates.# file: certificates.yaml---apiVersion:cert-manager.io/v1kind:Certificatemetadata:name:etcd-servernamespace:defaultspec:secretName:etcd-server-tlsissuerRef:name:selfsignedkind:ClusterIssuercommonName:etcddnsNames:-etcd-etcd.default-etcd.default.svc.cluster.local-etcd-0-etcd-0.etcd-etcd-0.etcd.default-etcd-0.etcd.default.svc-etcd-0.etcd.default.svc.cluster.local-etcd-1-etcd-1.etcd-etcd-1.etcd.default-etcd-1.etcd.default.svc-etcd-1.etcd.default.svc.cluster.local-etcd-2-etcd-2.etcd-etcd-2.etcd.default-etcd-2.etcd.default.svc-etcd-2.etcd.default.svc.cluster.local---apiVersion:cert-manager.io/v1kind:Certificatemetadata:name:etcd-clientnamespace:defaultspec:secretName:etcd-client-tlsissuerRef:name:selfsignedkind:ClusterIssuercommonName:etcddnsNames:-etcd-etcd.default-etcd.default.svc.cluster.local-etcd-0-etcd-0.etcd-etcd-0.etcd.default-etcd-0.etcd.default.svc-etcd-0.etcd.default.svc.cluster.local-etcd-1-etcd-1.etcd-etcd-1.etcd.default-etcd-1.etcd.default.svc-etcd-1.etcd.default.svc.cluster.local-etcd-2-etcd-2.etcd-etcd-2.etcd.default-etcd-2.etcd.default.svc-etcd-2.etcd.default.svc.cluster.localFeedbackWas this page helpful?YesNoGlad to hear it! Pleasetell us how we can improve.Sorry to hear that. Pleasetell us how we can improve.Last modified August 5, 2024:formatting - it really doesnt matter (10d90f3)©
2013–2024etcd AuthorsTerms|Privacy|Trademarks|LicenseAll Rights Reserved