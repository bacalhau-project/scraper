URL: https://kubernetes.io/docs/concepts/configuration/secret/

DocumentationKubernetes BlogTrainingPartnersCommunityCase StudiesVersionsRelease Informationv1.31v1.30v1.29v1.28v1.27English中文 (Chinese)Français (French)Deutsch (German)Bahasa Indonesia (Indonesian)日本語 (Japanese)한국어 (Korean)Português (Portuguese)Español (Spanish)DocumentationAvailable Documentation VersionsGetting startedLearning environmentProduction environmentContainer RuntimesInstalling Kubernetes with deployment toolsBootstrapping clusters with kubeadmInstalling kubeadmTroubleshooting kubeadmCreating a cluster with kubeadmCustomizing components with the kubeadm APIOptions for Highly Available TopologyCreating Highly Available Clusters with kubeadmSet up a High Availability etcd Cluster with kubeadmConfiguring each kubelet in your cluster using kubeadmDual-stack support with kubeadmTurnkey Cloud SolutionsBest practicesConsiderations for large clustersRunning in multiple zonesValidate node setupEnforcing Pod Security StandardsPKI certificates and requirementsConceptsOverviewKubernetes ComponentsObjects In KubernetesKubernetes Object ManagementObject Names and IDsLabels and SelectorsNamespacesAnnotationsField SelectorsFinalizersOwners and DependentsRecommended LabelsThe Kubernetes APICluster ArchitectureNodesCommunication between Nodes and the Control PlaneControllersLeasesCloud Controller ManagerAbout cgroup v2Container Runtime Interface (CRI)Garbage CollectionMixed Version ProxyContainersImagesContainer EnvironmentRuntime ClassContainer Lifecycle HooksWorkloadsPodsPod LifecycleInit ContainersSidecar ContainersEphemeral ContainersDisruptionsPod Quality of Service ClassesUser NamespacesDownward APIWorkload ManagementDeploymentsReplicaSetStatefulSetsDaemonSetJobsAutomatic Cleanup for Finished JobsCronJobReplicationControllerAutoscaling WorkloadsManaging WorkloadsServices, Load Balancing, and NetworkingServiceIngressIngress ControllersGateway APIEndpointSlicesNetwork PoliciesDNS for Services and PodsIPv4/IPv6 dual-stackTopology Aware RoutingNetworking on WindowsService ClusterIP allocationService Internal Traffic PolicyStorageVolumesPersistent VolumesProjected VolumesEphemeral VolumesStorage ClassesVolume Attributes ClassesDynamic Volume ProvisioningVolume SnapshotsVolume Snapshot ClassesCSI Volume CloningStorage CapacityNode-specific Volume LimitsVolume Health MonitoringWindows StorageConfigurationConfiguration Best PracticesConfigMapsSecretsLiveness, Readiness, and Startup ProbesResource Management for Pods and ContainersOrganizing Cluster Access Using kubeconfig FilesResource Management for Windows nodesSecurityCloud Native SecurityPod Security StandardsPod Security AdmissionService AccountsPod Security PoliciesSecurity For Windows NodesControlling Access to the Kubernetes APIRole Based Access Control Good PracticesGood practices for Kubernetes SecretsMulti-tenancyHardening Guide - Authentication MechanismsKubernetes API Server Bypass RisksLinux kernel security constraints for Pods and containersSecurity ChecklistPoliciesLimit RangesResource QuotasProcess ID Limits And ReservationsNode Resource ManagersScheduling, Preemption and EvictionKubernetes SchedulerAssigning Pods to NodesPod OverheadPod Scheduling ReadinessPod Topology Spread ConstraintsTaints and TolerationsScheduling FrameworkDynamic Resource AllocationScheduler Performance TuningResource Bin PackingPod Priority and PreemptionNode-pressure EvictionAPI-initiated EvictionCluster AdministrationNode ShutdownsCertificatesCluster NetworkingLogging ArchitectureMetrics For Kubernetes System ComponentsMetrics for Kubernetes Object StatesSystem LogsTraces For Kubernetes System ComponentsProxies in KubernetesAPI Priority and FairnessCluster AutoscalingInstalling AddonsCoordinated Leader ElectionWindows in KubernetesWindows containers in KubernetesGuide for Running Windows Containers in KubernetesExtending KubernetesCompute, Storage, and Networking ExtensionsNetwork PluginsDevice PluginsExtending the Kubernetes APICustom ResourcesKubernetes API Aggregation LayerOperator patternTasksInstall ToolsInstall and Set Up kubectl on LinuxInstall and Set Up kubectl on macOSInstall and Set Up kubectl on WindowsAdminister a ClusterAdministration with kubeadmCertificate Management with kubeadmConfiguring a cgroup driverReconfiguring a kubeadm clusterUpgrading kubeadm clustersUpgrading Linux nodesUpgrading Windows nodesChanging The Kubernetes Package RepositoryMigrating from dockershimChanging the Container Runtime on a Node from Docker Engine to containerdMigrate Docker Engine nodes from dockershim to cri-dockerdFind Out What Container Runtime is Used on a NodeTroubleshooting CNI plugin-related errorsCheck whether dockershim removal affects youMigrating telemetry and security agents from dockershimGenerate Certificates ManuallyManage Memory, CPU, and API ResourcesConfigure Default Memory Requests and Limits for a NamespaceConfigure Default CPU Requests and Limits for a NamespaceConfigure Minimum and Maximum Memory Constraints for a NamespaceConfigure Minimum and Maximum CPU Constraints for a NamespaceConfigure Memory and CPU Quotas for a NamespaceConfigure a Pod Quota for a NamespaceInstall a Network Policy ProviderUse Antrea for NetworkPolicyUse Calico for NetworkPolicyUse Cilium for NetworkPolicyUse Kube-router for NetworkPolicyRomana for NetworkPolicyWeave Net for NetworkPolicyAccess Clusters Using the Kubernetes APIAdvertise Extended Resources for a NodeAutoscale the DNS Service in a ClusterChange the Access Mode of a PersistentVolume to ReadWriteOncePodChange the default StorageClassSwitching from Polling to CRI Event-based Updates to Container StatusChange the Reclaim Policy of a PersistentVolumeCloud Controller Manager AdministrationConfigure a kubelet image credential providerConfigure Quotas for API ObjectsControl CPU Management Policies on the NodeControl Topology Management Policies on a nodeCustomizing DNS ServiceDebugging DNS ResolutionDeclare Network PolicyDeveloping Cloud Controller ManagerEnable Or Disable A Kubernetes APIEncrypting Confidential Data at RestDecrypt Confidential Data that is Already Encrypted at RestGuaranteed Scheduling For Critical Add-On PodsIP Masquerade Agent User GuideLimit Storage ConsumptionMigrate Replicated Control Plane To Use Cloud Controller ManagerNamespaces WalkthroughOperating etcd clusters for KubernetesReserve Compute Resources for System DaemonsRunning Kubernetes Node Components as a Non-root UserSafely Drain a NodeSecuring a ClusterSet Kubelet Parameters Via A Configuration FileShare a Cluster with NamespacesUpgrade A ClusterUse Cascading Deletion in a ClusterUsing a KMS provider for data encryptionUsing CoreDNS for Service DiscoveryUsing NodeLocal DNSCache in Kubernetes ClustersUsing sysctls in a Kubernetes ClusterUtilizing the NUMA-aware Memory ManagerVerify Signed Kubernetes ArtifactsConfigure Pods and ContainersAssign Memory Resources to Containers and PodsAssign CPU Resources to Containers and PodsConfigure GMSA for Windows Pods and containersResize CPU and Memory Resources assigned to ContainersConfigure RunAsUserName for Windows pods and containersCreate a Windows HostProcess PodConfigure Quality of Service for PodsAssign Extended Resources to a ContainerConfigure a Pod to Use a Volume for StorageConfigure a Pod to Use a PersistentVolume for StorageConfigure a Pod to Use a Projected Volume for StorageConfigure a Security Context for a Pod or ContainerConfigure Service Accounts for PodsPull an Image from a Private RegistryConfigure Liveness, Readiness and Startup ProbesAssign Pods to NodesAssign Pods to Nodes using Node AffinityConfigure Pod InitializationAttach Handlers to Container Lifecycle EventsConfigure a Pod to Use a ConfigMapShare Process Namespace between Containers in a PodUse a User Namespace With a PodUse an Image Volume With a PodCreate static PodsTranslate a Docker Compose File to Kubernetes ResourcesEnforce Pod Security Standards by Configuring the Built-in Admission ControllerEnforce Pod Security Standards with Namespace LabelsMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission ControllerMonitoring, Logging, and DebuggingTroubleshooting ApplicationsDebug PodsDebug ServicesDebug a StatefulSetDetermine the Reason for Pod FailureDebug Init ContainersDebug Running PodsGet a Shell to a Running ContainerTroubleshooting ClustersTroubleshooting kubectlResource metrics pipelineTools for Monitoring ResourcesMonitor Node HealthDebugging Kubernetes nodes with crictlAuditingDebugging Kubernetes Nodes With KubectlDeveloping and debugging services locally using telepresenceWindows debugging tipsManage Kubernetes ObjectsDeclarative Management of Kubernetes Objects Using Configuration FilesDeclarative Management of Kubernetes Objects Using KustomizeManaging Kubernetes Objects Using Imperative CommandsImperative Management of Kubernetes Objects Using Configuration FilesUpdate API Objects in Place Using kubectl patchMigrate Kubernetes Objects Using Storage Version MigrationManaging SecretsManaging Secrets using kubectlManaging Secrets using Configuration FileManaging Secrets using KustomizeInject Data Into ApplicationsDefine a Command and Arguments for a ContainerDefine Dependent Environment VariablesDefine Environment Variables for a ContainerExpose Pod Information to Containers Through Environment VariablesExpose Pod Information to Containers Through FilesDistribute Credentials Securely Using SecretsRun ApplicationsRun a Stateless Application Using a DeploymentRun a Single-Instance Stateful ApplicationRun a Replicated Stateful ApplicationScale a StatefulSetDelete a StatefulSetForce Delete StatefulSet PodsHorizontal Pod AutoscalingHorizontalPodAutoscaler WalkthroughSpecifying a Disruption Budget for your ApplicationAccessing the Kubernetes API from a PodRun JobsRunning Automated Tasks with a CronJobCoarse Parallel Processing Using a Work QueueFine Parallel Processing Using a Work QueueIndexed Job for Parallel Processing with Static Work AssignmentJob with Pod-to-Pod CommunicationParallel Processing using ExpansionsHandling retriable and non-retriable pod failures with Pod failure policyAccess Applications in a ClusterDeploy and Access the Kubernetes DashboardAccessing ClustersConfigure Access to Multiple ClustersUse Port Forwarding to Access Applications in a ClusterUse a Service to Access an Application in a ClusterConnect a Frontend to a Backend Using ServicesCreate an External Load BalancerList All Container Images Running in a ClusterSet up Ingress on Minikube with the NGINX Ingress ControllerCommunicate Between Containers in the Same Pod Using a Shared VolumeConfigure DNS for a ClusterAccess Services Running on ClustersExtend KubernetesConfigure the Aggregation LayerUse Custom ResourcesExtend the Kubernetes API with CustomResourceDefinitionsVersions in CustomResourceDefinitionsSet up an Extension API ServerConfigure Multiple SchedulersUse an HTTP Proxy to Access the Kubernetes APIUse a SOCKS5 Proxy to Access the Kubernetes APISet up Konnectivity serviceTLSConfigure Certificate Rotation for the KubeletManage TLS Certificates in a ClusterManual Rotation of CA CertificatesManage Cluster DaemonsPerform a Rolling Update on a DaemonSetPerform a Rollback on a DaemonSetRunning Pods on Only Some NodesNetworkingAdding entries to Pod /etc/hosts with HostAliasesExtend Service IP RangesValidate IPv4/IPv6 dual-stackExtend kubectl with pluginsManage HugePagesSchedule GPUsTutorialsHello MinikubeLearn Kubernetes BasicsCreate a ClusterUsing Minikube to Create a ClusterDeploy an AppUsing kubectl to Create a DeploymentExplore Your AppViewing Pods and NodesExpose Your App PubliclyUsing a Service to Expose Your AppScale Your AppRunning Multiple Instances of Your AppUpdate Your AppPerforming a Rolling UpdateConfigurationExample: Configuring a Java MicroserviceExternalizing config using MicroProfile, ConfigMaps and SecretsUpdating Configuration via a ConfigMapConfiguring Redis using a ConfigMapAdopting Sidecar ContainersSecurityApply Pod Security Standards at the Cluster LevelApply Pod Security Standards at the Namespace LevelRestrict a Container's Access to Resources with AppArmorRestrict a Container's Syscalls with seccompStateless ApplicationsExposing an External IP Address to Access an Application in a ClusterExample: Deploying PHP Guestbook application with RedisStateful ApplicationsStatefulSet BasicsExample: Deploying WordPress and MySQL with Persistent VolumesExample: Deploying Cassandra with a StatefulSetRunning ZooKeeper, A Distributed System CoordinatorServicesConnecting Applications with ServicesUsing Source IPExplore Termination Behavior for Pods And Their EndpointsReferenceGlossaryAPI OverviewKubernetes API ConceptsServer-Side ApplyClient LibrariesCommon Expression Language in KubernetesKubernetes Deprecation PolicyDeprecated API Migration GuideKubernetes API health endpointsAPI Access ControlAuthenticatingAuthenticating with Bootstrap TokensAuthorizationUsing RBAC AuthorizationUsing Node AuthorizationWebhook ModeUsing ABAC AuthorizationAdmission ControllersDynamic Admission ControlManaging Service AccountsCertificates and Certificate Signing RequestsMapping PodSecurityPolicies to Pod Security StandardsKubelet authentication/authorizationTLS bootstrappingValidating Admission PolicyWell-Known Labels, Annotations and TaintsAudit AnnotationsKubernetes APIWorkload ResourcesPodBindingPodTemplateReplicationControllerReplicaSetDeploymentStatefulSetControllerRevisionDaemonSetJobCronJobHorizontalPodAutoscalerHorizontalPodAutoscalerPriorityClassPodSchedulingContext v1alpha3ResourceClaim v1alpha3ResourceClaimTemplate v1alpha3ResourceSlice v1alpha3Service ResourcesServiceEndpointsEndpointSliceIngressIngressClassConfig and Storage ResourcesConfigMapSecretCSIDriverCSINodeCSIStorageCapacityPersistentVolumeClaimPersistentVolumeStorageClassStorageVersionMigration v1alpha1VolumeVolumeAttachmentVolumeAttributesClass v1beta1Authentication ResourcesServiceAccountTokenRequestTokenReviewCertificateSigningRequestClusterTrustBundle v1alpha1SelfSubjectReviewAuthorization ResourcesLocalSubjectAccessReviewSelfSubjectAccessReviewSelfSubjectRulesReviewSubjectAccessReviewClusterRoleClusterRoleBindingRoleRoleBindingPolicy ResourcesFlowSchemaLimitRangeResourceQuotaNetworkPolicyPodDisruptionBudgetPriorityLevelConfigurationValidatingAdmissionPolicyValidatingAdmissionPolicyBindingExtend ResourcesCustomResourceDefinitionDeviceClass v1alpha3MutatingWebhookConfigurationValidatingWebhookConfigurationCluster ResourcesAPIServiceComponentStatusEventIPAddress v1beta1LeaseLeaseCandidate v1alpha1NamespaceNodeRuntimeClassServiceCIDR v1beta1Common DefinitionsDeleteOptionsLabelSelectorListMetaLocalObjectReferenceNodeSelectorRequirementObjectFieldSelectorObjectMetaObjectReferencePatchQuantityResourceFieldSelectorStatusTypedLocalObjectReferenceCommon ParametersInstrumentationService Level Indicator MetricsCRI Pod & Container MetricsNode metrics dataKubernetes Metrics ReferenceKubernetes Issues and SecurityKubernetes Issue TrackerKubernetes Security and Disclosure InformationCVE feedNode Reference InformationKubelet Checkpoint APILinux Kernel Version RequirementsArticles on dockershim Removal and on Using CRI-compatible RuntimesNode Labels Populated By The KubeletKubelet Configuration Directory MergingKubelet Device Manager API VersionsNode StatusNetworking ReferenceProtocols for ServicesPorts and ProtocolsVirtual IPs and Service ProxiesSetup toolsKubeadmkubeadm initkubeadm joinkubeadm upgradekubeadm configkubeadm resetkubeadm tokenkubeadm versionkubeadm alphakubeadm certskubeadm init phasekubeadm join phasekubeadm kubeconfigkubeadm reset phasekubeadm upgrade phaseImplementation detailsCommand line tool (kubectl)Introduction to kubectlkubectl Quick Referencekubectl referencekubectlkubectl annotatekubectl api-resourceskubectl api-versionskubectl applykubectl apply edit-last-appliedkubectl apply set-last-appliedkubectl apply view-last-appliedkubectl attachkubectl authkubectl auth can-ikubectl auth reconcilekubectl auth whoamikubectl autoscalekubectl certificatekubectl certificate approvekubectl certificate denykubectl cluster-infokubectl cluster-info dumpkubectl completionkubectl configkubectl config current-contextkubectl config delete-clusterkubectl config delete-contextkubectl config delete-userkubectl config get-clusterskubectl config get-contextskubectl config get-userskubectl config rename-contextkubectl config setkubectl config set-clusterkubectl config set-contextkubectl config set-credentialskubectl config unsetkubectl config use-contextkubectl config viewkubectl cordonkubectl cpkubectl createkubectl create clusterrolekubectl create clusterrolebindingkubectl create configmapkubectl create cronjobkubectl create deploymentkubectl create ingresskubectl create jobkubectl create namespacekubectl create poddisruptionbudgetkubectl create priorityclasskubectl create quotakubectl create rolekubectl create rolebindingkubectl create secretkubectl create secret docker-registrykubectl create secret generickubectl create secret tlskubectl create servicekubectl create service clusteripkubectl create service externalnamekubectl create service loadbalancerkubectl create service nodeportkubectl create serviceaccountkubectl create tokenkubectl debugkubectl deletekubectl describekubectl diffkubectl drainkubectl editkubectl eventskubectl execkubectl explainkubectl exposekubectl getkubectl kustomizekubectl labelkubectl logskubectl optionskubectl patchkubectl pluginkubectl plugin listkubectl port-forwardkubectl proxykubectl replacekubectl rolloutkubectl rollout historykubectl rollout pausekubectl rollout restartkubectl rollout resumekubectl rollout statuskubectl rollout undokubectl runkubectl scalekubectl setkubectl set envkubectl set imagekubectl set resourceskubectl set selectorkubectl set serviceaccountkubectl set subjectkubectl taintkubectl topkubectl top nodekubectl top podkubectl uncordonkubectl versionkubectl waitkubectl CommandskubectlJSONPath Supportkubectl for Docker Userskubectl Usage ConventionsComponent toolsFeature GatesFeature Gates (removed)kubeletkube-apiserverkube-controller-managerkube-proxykube-schedulerDebug clusterFlow controlConfiguration APIsClient Authentication (v1)Client Authentication (v1beta1)Event Rate Limit Configuration (v1alpha1)Image Policy API (v1alpha1)kube-apiserver Admission (v1)kube-apiserver Audit Configuration (v1)kube-apiserver Configuration (v1)kube-apiserver Configuration (v1alpha1)kube-apiserver Configuration (v1beta1)kube-controller-manager Configuration (v1alpha1)kube-proxy Configuration (v1alpha1)kube-scheduler Configuration (v1)kubeadm Configuration (v1beta3)kubeadm Configuration (v1beta4)kubeconfig (v1)Kubelet Configuration (v1)Kubelet Configuration (v1alpha1)Kubelet Configuration (v1beta1)Kubelet CredentialProvider (v1)WebhookAdmission Configuration (v1)External APIsKubernetes Custom Metrics (v1beta2)Kubernetes External Metrics (v1beta1)Kubernetes Metrics (v1beta1)SchedulingScheduler ConfigurationScheduling PoliciesOther ToolsMapping from dockercli to crictlContributeContribute to Kubernetes DocumentationSuggesting content improvementsContributing new contentOpening a pull requestDocumenting for a releaseBlogs and case studiesReviewing changesReviewing pull requestsFor approvers and reviewersLocalizing Kubernetes documentationParticipating in SIG DocsRoles and responsibilitiesIssue WranglersPR wranglersDocumentation style overviewContent guideStyle guideDiagram guideWriting a new topicPage content typesContent organizationCustom Hugo ShortcodesUpdating Reference DocumentationQuickstartContributing to the Upstream Kubernetes CodeGenerating Reference Documentation for the Kubernetes APIGenerating Reference Documentation for kubectl CommandsGenerating Reference Documentation for MetricsGenerating Reference Pages for Kubernetes Components and ToolsAdvanced contributingViewing Site AnalyticsDocs smoke test pageKubernetes DocumentationConceptsConfigurationSecretsSecretsA Secret is an object that contains a small amount of sensitive data such as
a password, a token, or a key. Such information might otherwise be put in aPodspecification or in acontainer image. Using a
Secret means that you don't need to include confidential data in your
application code.Because Secrets can be created independently of the Pods that use them, there
is less risk of the Secret (and its data) being exposed during the workflow of
creating, viewing, and editing Pods. Kubernetes, and applications that run in
your cluster, can also take additional precautions with Secrets, such as avoiding
writing sensitive data to nonvolatile storage.Secrets are similar toConfigMapsbut are specifically intended to hold confidential data.Caution:Kubernetes Secrets are, by default, stored unencrypted in the API server's underlying data store
(etcd). Anyone with API access can retrieve or modify a Secret, and so can anyone with access to etcd.
Additionally, anyone who is authorized to create a Pod in a namespace can use that access to read
any Secret in that namespace; this includes indirect access such as the ability to create a
Deployment.In order to safely use Secrets, take at least the following steps:Enable Encryption at Restfor Secrets.Enable or configure RBAC ruleswith
least-privilege access to Secrets.Restrict Secret access to specific containers.Consider using external Secret store providers.For more guidelines to manage and improve the security of your Secrets, refer toGood practices for Kubernetes Secrets.SeeInformation security for Secretsfor more details.Uses for SecretsYou can use Secrets for purposes such as the following:Set environment variables for a container.Provide credentials such as SSH keys or passwords to Pods.Allow the kubelet to pull container images from private registries.The Kubernetes control plane also uses Secrets; for example,bootstrap token Secretsare a mechanism to
help automate node registration.Use case: dotfiles in a secret volumeYou can make your data "hidden" by defining a key that begins with a dot.
This key represents a dotfile or "hidden" file. For example, when the following Secret
is mounted into a volume,secret-volume, the volume will contain a single file,
called.secret-file, and thedotfile-test-containerwill have this file
present at the path/etc/secret-volume/.secret-file.Note:Files beginning with dot characters are hidden from the output ofls -l;
you must usels -lato see them when listing directory contents.secret/dotfile-secret.yamlapiVersion:v1kind:Secretmetadata:name:dotfile-secretdata:.secret-file:dmFsdWUtMg0KDQo=---apiVersion:v1kind:Podmetadata:name:secret-dotfiles-podspec:volumes:-name:secret-volumesecret:secretName:dotfile-secretcontainers:-name:dotfile-test-containerimage:registry.k8s.io/busyboxcommand:- ls-"-l"-"/etc/secret-volume"volumeMounts:-name:secret-volumereadOnly:truemountPath:"/etc/secret-volume"Use case: Secret visible to one container in a PodConsider a program that needs to handle HTTP requests, do some complex business
logic, and then sign some messages with an HMAC. Because it has complex
application logic, there might be an unnoticed remote file reading exploit in
the server, which could expose the private key to an attacker.This could be divided into two processes in two containers: a frontend container
which handles user interaction and business logic, but which cannot see the
private key; and a signer container that can see the private key, and responds
to simple signing requests from the frontend (for example, over localhost networking).With this partitioned approach, an attacker now has to trick the application
server into doing something rather arbitrary, which may be harder than getting
it to read a file.Alternatives to SecretsRather than using a Secret to protect confidential data, you can pick from alternatives.Here are some of your options:If your cloud-native component needs to authenticate to another application that you
know is running within the same Kubernetes cluster, you can use aServiceAccountand its tokens to identify your client.There are third-party tools that you can run, either within or outside your cluster,
that manage sensitive data. For example, a service that Pods access over HTTPS,
that reveals a Secret if the client correctly authenticates (for example, with a ServiceAccount
token).For authentication, you can implement a custom signer for X.509 certificates, and useCertificateSigningRequeststo let that custom signer issue certificates to Pods that need them.You can use adevice pluginto expose node-local encryption hardware to a specific Pod. For example, you can schedule
trusted Pods onto nodes that provide a Trusted Platform Module, configured out-of-band.You can also combine two or more of those options, including the option to use Secret objects themselves.For example: implement (or deploy) anoperatorthat fetches short-lived session tokens from an external service, and then creates Secrets based
on those short-lived session tokens. Pods running in your cluster can make use of the session tokens,
and operator ensures they are valid. This separation means that you can run Pods that are unaware of
the exact mechanisms for issuing and refreshing those session tokens.Types of SecretWhen creating a Secret, you can specify its type using thetypefield of
theSecretresource, or certain equivalentkubectlcommand line flags (if available).
The Secret type is used to facilitate programmatic handling of the Secret data.Kubernetes provides several built-in types for some common usage scenarios.
These types vary in terms of the validations performed and the constraints
Kubernetes imposes on them.Built-in TypeUsageOpaquearbitrary user-defined datakubernetes.io/service-account-tokenServiceAccount tokenkubernetes.io/dockercfgserialized~/.dockercfgfilekubernetes.io/dockerconfigjsonserialized~/.docker/config.jsonfilekubernetes.io/basic-authcredentials for basic authenticationkubernetes.io/ssh-authcredentials for SSH authenticationkubernetes.io/tlsdata for a TLS client or serverbootstrap.kubernetes.io/tokenbootstrap token dataYou can define and use your own Secret type by assigning a non-empty string as thetypevalue for a Secret object (an empty string is treated as anOpaquetype).Kubernetes doesn't impose any constraints on the type name. However, if you
are using one of the built-in types, you must meet all the requirements defined
for that type.If you are defining a type of Secret that's for public use, follow the convention
and structure the Secret type to have your domain name before the name, separated
by a/. For example:cloud-hosting.example.net/cloud-api-credentials.Opaque SecretsOpaqueis the default Secret type if you don't explicitly specify a type in
a Secret manifest. When you create a Secret usingkubectl, you must use thegenericsubcommand to indicate anOpaqueSecret type. For example, the
following command creates an empty Secret of typeOpaque:kubectl create secret generic empty-secretkubectl get secret empty-secretThe output looks like:NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6sTheDATAcolumn shows the number of data items stored in the Secret.
In this case,0means you have created an empty Secret.ServiceAccount token SecretsAkubernetes.io/service-account-tokentype of Secret is used to store a
token credential that identifies aServiceAccount. This
is a legacy mechanism that provides long-lived ServiceAccount credentials to
Pods.In Kubernetes v1.22 and later, the recommended approach is to obtain a
short-lived, automatically rotating ServiceAccount token by using theTokenRequestAPI instead. You can get these short-lived tokens using the following methods:Call theTokenRequestAPI either directly or by using an API client likekubectl. For example, you can use thekubectl create tokencommand.Request a mounted token in aprojected volumein your Pod manifest. Kubernetes creates the token and mounts it in the Pod.
The token is automatically invalidated when the Pod that it's mounted in is
deleted. For details, seeLaunch a Pod using service account token projection.Note:You should only create a ServiceAccount token Secret
if you can't use theTokenRequestAPI to obtain a token,
and the security exposure of persisting a non-expiring token credential
in a readable API object is acceptable to you. For instructions, seeManually create a long-lived API token for a ServiceAccount.When using this Secret type, you need to ensure that thekubernetes.io/service-account.nameannotation is set to an existing
ServiceAccount name. If you are creating both the ServiceAccount and
the Secret objects, you should create the ServiceAccount object first.After the Secret is created, a Kubernetescontrollerfills in some other fields such as thekubernetes.io/service-account.uidannotation, and thetokenkey in thedatafield, which is populated with an authentication token.The following example configuration declares a ServiceAccount token Secret:secret/serviceaccount-token-secret.yamlapiVersion:v1kind:Secretmetadata:name:secret-sa-sampleannotations:kubernetes.io/service-account.name:"sa-name"type:kubernetes.io/service-account-tokendata:extra:YmFyCg==After creating the Secret, wait for Kubernetes to populate thetokenkey in thedatafield.See theServiceAccountdocumentation for more information on how ServiceAccounts work.
You can also check theautomountServiceAccountTokenfield and theserviceAccountNamefield of thePodfor information on referencing ServiceAccount credentials from within Pods.Docker config SecretsIf you are creating a Secret to store credentials for accessing a container image registry,
you must use one of the followingtypevalues for that Secret:kubernetes.io/dockercfg: store a serialized~/.dockercfgwhich is the
legacy format for configuring Docker command line. The Secretdatafield contains a.dockercfgkey whose value is the content of a
base64 encoded~/.dockercfgfile.kubernetes.io/dockerconfigjson: store a serialized JSON that follows the
same format rules as the~/.docker/config.jsonfile, which is a new format
for~/.dockercfg. The Secretdatafield must contain a.dockerconfigjsonkey for which the value is the content of a base64
encoded~/.docker/config.jsonfile.Below is an example for akubernetes.io/dockercfgtype of Secret:secret/dockercfg-secret.yamlapiVersion:v1kind:Secretmetadata:name:secret-dockercfgtype:kubernetes.io/dockercfgdata:.dockercfg:|eyJhdXRocyI6eyJodHRwczovL2V4YW1wbGUvdjEvIjp7ImF1dGgiOiJvcGVuc2VzYW1lIn19fQo=Note:If you do not want to perform the base64 encoding, you can choose to use thestringDatafield instead.When you create Docker config Secrets using a manifest, the API
server checks whether the expected key exists in thedatafield, and
it verifies if the value provided can be parsed as a valid JSON. The API
server doesn't validate if the JSON actually is a Docker config file.You can also usekubectlto create a Secret for accessing a container
registry, such as when you don't have a Docker configuration file:kubectl create secret docker-registry secret-tiger-docker\--docker-email=tiger@acme.example\--docker-username=tiger\--docker-password=pass1234\--docker-server=my-registry.example:5000This command creates a Secret of typekubernetes.io/dockerconfigjson.Retrieve the.data.dockerconfigjsonfield from that new Secret and decode the
data:kubectl get secret secret-tiger-docker -ojsonpath='{.data.*}'| base64 -dThe output is equivalent to the following JSON document (which is also a valid
Docker configuration file):{"auths": {"my-registry.example:5000": {"username":"tiger","password":"pass1234","email":"tiger@acme.example","auth":"dGlnZXI6cGFzczEyMzQ="}}}Caution:Theauthvalue there is base64 encoded; it is obscured but not secret.
Anyone who can read that Secret can learn the registry access bearer token.It is suggested to usecredential providersto dynamically and securely provide pull secrets on-demand.Basic authentication SecretThekubernetes.io/basic-authtype is provided for storing credentials needed
for basic authentication. When using this Secret type, thedatafield of the
Secret must contain one of the following two keys:username: the user name for authenticationpassword: the password or token for authenticationBoth values for the above two keys are base64 encoded strings. You can
alternatively provide the clear text content using thestringDatafield in the
Secret manifest.The following manifest is an example of a basic authentication Secret:secret/basicauth-secret.yamlapiVersion:v1kind:Secretmetadata:name:secret-basic-authtype:kubernetes.io/basic-authstringData:username:admin# required field for kubernetes.io/basic-authpassword:t0p-Secret# required field for kubernetes.io/basic-authNote:ThestringDatafield for a Secret does not work well with server-side apply.The basic authentication Secret type is provided only for convenience.
You can create anOpaquetype for credentials used for basic authentication.
However, using the defined and public Secret type (kubernetes.io/basic-auth) helps other
people to understand the purpose of your Secret, and sets a convention for what key names
to expect.SSH authentication SecretsThe builtin typekubernetes.io/ssh-authis provided for storing data used in
SSH authentication. When using this Secret type, you will have to specify assh-privatekeykey-value pair in thedata(orstringData) field
as the SSH credential to use.The following manifest is an example of a Secret used for SSH public/private
key authentication:secret/ssh-auth-secret.yamlapiVersion:v1kind:Secretmetadata:name:secret-ssh-authtype:kubernetes.io/ssh-authdata:# the data is abbreviated in this examplessh-privatekey:|UG91cmluZzYlRW1vdGljb24lU2N1YmE=The SSH authentication Secret type is provided only for convenience.
You can create anOpaquetype for credentials used for SSH authentication.
However, using the defined and public Secret type (kubernetes.io/ssh-auth) helps other
people to understand the purpose of your Secret, and sets a convention for what key names
to expect.
The Kubernetes API verifies that the required keys are set for a Secret of this type.Caution:SSH private keys do not establish trusted communication between an SSH client and
host server on their own. A secondary means of establishing trust is needed to
mitigate "man in the middle" attacks, such as aknown_hostsfile added to a ConfigMap.TLS SecretsThekubernetes.io/tlsSecret type is for storing
a certificate and its associated key that are typically used for TLS.One common use for TLS Secrets is to configure encryption in transit for
anIngress, but you can also use it
with other resources or directly in your workload.
When using this type of Secret, thetls.keyand thetls.crtkey must be provided
in thedata(orstringData) field of the Secret configuration, although the API
server doesn't actually validate the values for each key.As an alternative to usingstringData, you can use thedatafield to provide
the base64 encoded certificate and private key. For details, seeConstraints on Secret names and data.The following YAML contains an example config for a TLS Secret:secret/tls-auth-secret.yamlapiVersion:v1kind:Secretmetadata:name:secret-tlstype:kubernetes.io/tlsdata:# values are base64 encoded, which obscures them but does NOT provide# any useful level of confidentialitytls.crt:|LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNVakNDQWJzQ0FnMytNQTBHQ1NxR1NJYjNEUUVCQlFVQU1JR2JNUXN3Q1FZRFZRUUdFd0pLVURFT01Bd0cKQTFVRUNCTUZWRzlyZVc4eEVEQU9CZ05WQkFjVEIwTm9kVzh0YTNVeEVUQVBCZ05WQkFvVENFWnlZVzVyTkVSRQpNUmd3RmdZRFZRUUxFdzlYWldKRFpYSjBJRk4xY0hCdmNuUXhHREFXQmdOVkJBTVREMFp5WVc1ck5FUkVJRmRsCllpQkRRVEVqTUNFR0NTcUdTSWIzRFFFSkFSWVVjM1Z3Y0c5eWRFQm1jbUZ1YXpSa1pDNWpiMjB3SGhjTk1UTXcKTVRFeE1EUTFNVE01V2hjTk1UZ3dNVEV3TURRMU1UTTVXakJMTVFzd0NRWURWUVFHREFKS1VERVBNQTBHQTFVRQpDQXdHWEZSdmEzbHZNUkV3RHdZRFZRUUtEQWhHY21GdWF6UkVSREVZTUJZR0ExVUVBd3dQZDNkM0xtVjRZVzF3CmJHVXVZMjl0TUlHYU1BMEdDU3FHU0liM0RRRUJBUVVBQTRHSUFEQ0JoQUo5WThFaUhmeHhNL25PbjJTbkkxWHgKRHdPdEJEVDFKRjBReTliMVlKanV2YjdjaTEwZjVNVm1UQllqMUZTVWZNOU1vejJDVVFZdW4yRFljV29IcFA4ZQpqSG1BUFVrNVd5cDJRN1ArMjh1bklIQkphVGZlQ09PekZSUFY2MEdTWWUzNmFScG04L3dVVm16eGFLOGtCOWVaCmhPN3F1TjdtSWQxL2pWcTNKODhDQXdFQUFUQU5CZ2txaGtpRzl3MEJBUVVGQUFPQmdRQU1meTQzeE15OHh3QTUKVjF2T2NSOEtyNWNaSXdtbFhCUU8xeFEzazlxSGtyNFlUY1JxTVQ5WjVKTm1rWHYxK2VSaGcwTi9WMW5NUTRZRgpnWXcxbnlESnBnOTduZUV4VzQyeXVlMFlHSDYyV1hYUUhyOVNVREgrRlowVnQvRGZsdklVTWRjUUFEZjM4aU9zCjlQbG1kb3YrcE0vNCs5a1h5aDhSUEkzZXZ6OS9NQT09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K# In this example, the key data is not a real PEM-encoded private keytls.key:|RXhhbXBsZSBkYXRhIGZvciB0aGUgVExTIGNydCBmaWVsZA==The TLS Secret type is provided only for convenience.
You can create anOpaquetype for credentials used for TLS authentication.
However, using the defined and public Secret type (kubernetes.io/tls)
helps ensure the consistency of Secret format in your project. The API server
verifies if the required keys are set for a Secret of this type.To create a TLS Secret usingkubectl, use thetlssubcommand:kubectl create secret tls my-tls-secret\--cert=path/to/cert/file\--key=path/to/key/fileThe public/private key pair must exist before hand. The public key certificate for--certmust be .PEM encoded
and must match the given private key for--key.Bootstrap token SecretsThebootstrap.kubernetes.io/tokenSecret type is for
tokens used during the node bootstrap process. It stores tokens used to sign
well-known ConfigMaps.A bootstrap token Secret is usually created in thekube-systemnamespace and
named in the formbootstrap-token-<token-id>where<token-id>is a 6 character
string of the token ID.As a Kubernetes manifest, a bootstrap token Secret might look like the
following:secret/bootstrap-token-secret-base64.yamlapiVersion:v1kind:Secretmetadata:name:bootstrap-token-5emitjnamespace:kube-systemtype:bootstrap.kubernetes.io/tokendata:auth-extra-groups:c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=expiration:MjAyMC0wOS0xM1QwNDozOToxMFo=token-id:NWVtaXRqtoken-secret:a3E0Z2lodnN6emduMXAwcg==usage-bootstrap-authentication:dHJ1ZQ==usage-bootstrap-signing:dHJ1ZQ==A bootstrap token Secret has the following keys specified underdata:token-id: A random 6 character string as the token identifier. Required.token-secret: A random 16 character string as the actual token Secret. Required.description: A human-readable string that describes what the token is
used for. Optional.expiration: An absolute UTC time usingRFC3339specifying when the token
should be expired. Optional.usage-bootstrap-<usage>: A boolean flag indicating additional usage for
the bootstrap token.auth-extra-groups: A comma-separated list of group names that will be
authenticated as in addition to thesystem:bootstrappersgroup.You can alternatively provide the values in thestringDatafield of the Secret
without base64 encoding them:secret/bootstrap-token-secret-literal.yamlapiVersion:v1kind:Secretmetadata:# Note how the Secret is namedname:bootstrap-token-5emitj# A bootstrap token Secret usually resides in the kube-system namespacenamespace:kube-systemtype:bootstrap.kubernetes.io/tokenstringData:auth-extra-groups:"system:bootstrappers:kubeadm:default-node-token"expiration:"2020-09-13T04:39:10Z"# This token ID is used in the nametoken-id:"5emitj"token-secret:"kq4gihvszzgn1p0r"# This token can be used for authenticationusage-bootstrap-authentication:"true"# and it can be used for signingusage-bootstrap-signing:"true"Note:ThestringDatafield for a Secret does not work well with server-side apply.Working with SecretsCreating a SecretThere are several options to create a Secret:UsekubectlUse a configuration fileUse the Kustomize toolConstraints on Secret names and dataThe name of a Secret object must be a validDNS subdomain name.You can specify thedataand/or thestringDatafield when creating a
configuration file for a Secret. Thedataand thestringDatafields are optional.
The values for all keys in thedatafield have to be base64-encoded strings.
If the conversion to base64 string is not desirable, you can choose to specify
thestringDatafield instead, which accepts arbitrary strings as values.The keys ofdataandstringDatamust consist of alphanumeric characters,-,_or.. All key-value pairs in thestringDatafield are internally
merged into thedatafield. If a key appears in both thedataand thestringDatafield, the value specified in thestringDatafield takes
precedence.Size limitIndividual Secrets are limited to 1MiB in size. This is to discourage creation
of very large Secrets that could exhaust the API server and kubelet memory.
However, creation of many smaller Secrets could also exhaust memory. You can
use aresource quotato limit the
number of Secrets (or other resources) in a namespace.Editing a SecretYou can edit an existing Secret unless it isimmutable. To
edit a Secret, use one of the following methods:UsekubectlUse a configuration fileYou can also edit the data in a Secret using theKustomize tool. However, this
method creates a newSecretobject with the edited data.Depending on how you created the Secret, as well as how the Secret is used in
your Pods, updates to existingSecretobjects are propagated automatically to
Pods that use the data. For more information, refer toUsing Secrets as files from a Podsection.Using a SecretSecrets can be mounted as data volumes or exposed asenvironment variablesto be used by a container in a Pod. Secrets can also be used by other parts of the
system, without being directly exposed to the Pod. For example, Secrets can hold
credentials that other parts of the system should use to interact with external
systems on your behalf.Secret volume sources are validated to ensure that the specified object
reference actually points to an object of type Secret. Therefore, a Secret
needs to be created before any Pods that depend on it.If the Secret cannot be fetched (perhaps because it does not exist, or
due to a temporary lack of connection to the API server) the kubelet
periodically retries running that Pod. The kubelet also reports an Event
for that Pod, including details of the problem fetching the Secret.Optional SecretsWhen you reference a Secret in a Pod, you can mark the Secret asoptional,
such as in the following example. If an optional Secret doesn't exist,
Kubernetes ignores it.secret/optional-secret.yamlapiVersion:v1kind:Podmetadata:name:mypodspec:containers:-name:mypodimage:redisvolumeMounts:-name:foomountPath:"/etc/foo"readOnly:truevolumes:-name:foosecret:secretName:mysecretoptional:trueBy default, Secrets are required. None of a Pod's containers will start until
all non-optional Secrets are available.If a Pod references a specific key in a non-optional Secret and that Secret
does exist, but is missing the named key, the Pod fails during startup.Using Secrets as files from a PodIf you want to access data from a Secret in a Pod, one way to do that is to
have Kubernetes make the value of that Secret be available as a file inside
the filesystem of one or more of the Pod's containers.For instructions, refer toCreate a Pod that has access to the secret data through a Volume.When a volume contains data from a Secret, and that Secret is updated, Kubernetes tracks
this and updates the data in the volume, using an eventually-consistent approach.Note:A container using a Secret as asubPathvolume mount does not receive
automated Secret updates.The kubelet keeps a cache of the current keys and values for the Secrets that are used in
volumes for pods on that node.
You can configure the way that the kubelet detects changes from the cached values. TheconfigMapAndSecretChangeDetectionStrategyfield in thekubelet configurationcontrols
which strategy the kubelet uses. The default strategy isWatch.Updates to Secrets can be either propagated by an API watch mechanism (the default), based on
a cache with a defined time-to-live, or polled from the cluster API server on each kubelet
synchronisation loop.As a result, the total delay from the moment when the Secret is updated to the moment
when new keys are projected to the Pod can be as long as the kubelet sync period + cache
propagation delay, where the cache propagation delay depends on the chosen cache type
(following the same order listed in the previous paragraph, these are:
watch propagation delay, the configured cache TTL, or zero for direct polling).Using Secrets as environment variablesTo use a Secret in anenvironment variablein a Pod:For each container in your Pod specification, add an environment variable
for each Secret key that you want to use to theenv[].valueFrom.secretKeyReffield.Modify your image and/or command line so that the program looks for values
in the specified environment variables.For instructions, refer toDefine container environment variables using Secret data.It's important to note that the range of characters allowed for environment variable
names in pods isrestricted.
If any keys do not meet the rules, those keys are not made available to your container, though
the Pod is allowed to start.Container image pull SecretsIf you want to fetch container images from a private repository, you need a way for
the kubelet on each node to authenticate to that repository. You can configureimage pull Secretsto make this possible. These Secrets are configured at the Pod
level.Using imagePullSecretsTheimagePullSecretsfield is a list of references to Secrets in the same namespace.
You can use animagePullSecretsto pass a Secret that contains a Docker (or other) image registry
password to the kubelet. The kubelet uses this information to pull a private image on behalf of your Pod.
See thePodSpec APIfor more information about theimagePullSecretsfield.Manually specifying an imagePullSecretYou can learn how to specifyimagePullSecretsfrom thecontainer imagesdocumentation.Arranging for imagePullSecrets to be automatically attachedYou can manually createimagePullSecrets, and reference these from a ServiceAccount. Any Pods
created with that ServiceAccount or created with that ServiceAccount by default, will get theirimagePullSecretsfield set to that of the service account.
SeeAdd ImagePullSecrets to a service accountfor a detailed explanation of that process.Using Secrets with static PodsYou cannot use ConfigMaps or Secrets withstatic Pods.Immutable SecretsFEATURE STATE:Kubernetes v1.21 [stable]Kubernetes lets you mark specific Secrets (and ConfigMaps) asimmutable.
Preventing changes to the data of an existing Secret has the following benefits:protects you from accidental (or unwanted) updates that could cause applications outages(for clusters that extensively use Secrets - at least tens of thousands of unique Secret
to Pod mounts), switching to immutable Secrets improves the performance of your cluster
by significantly reducing load on kube-apiserver. The kubelet does not need to maintain
a [watch] on any Secrets that are marked as immutable.Marking a Secret as immutableYou can create an immutable Secret by setting theimmutablefield totrue. For example,apiVersion:v1kind:Secretmetadata:...data:...immutable:trueYou can also update any existing mutable Secret to make it immutable.Note:Once a Secret or ConfigMap is marked as immutable, it isnotpossible to revert this change
nor to mutate the contents of thedatafield. You can only delete and recreate the Secret.
Existing Pods maintain a mount point to the deleted Secret - it is recommended to recreate
these pods.Information security for SecretsAlthough ConfigMap and Secret work similarly, Kubernetes applies some additional
protection for Secret objects.Secrets often hold values that span a spectrum of importance, many of which can
cause escalations within Kubernetes (e.g. service account tokens) and to
external systems. Even if an individual app can reason about the power of the
Secrets it expects to interact with, other apps within the same namespace can
render those assumptions invalid.A Secret is only sent to a node if a Pod on that node requires it.
For mounting Secrets into Pods, the kubelet stores a copy of the data into atmpfsso that the confidential data is not written to durable storage.
Once the Pod that depends on the Secret is deleted, the kubelet deletes its local copy
of the confidential data from the Secret.There may be several containers in a Pod. By default, containers you define
only have access to the default ServiceAccount and its related Secret.
You must explicitly define environment variables or map a volume into a
container in order to provide access to any other Secret.There may be Secrets for several Pods on the same node. However, only the
Secrets that a Pod requests are potentially visible within its containers.
Therefore, one Pod does not have access to the Secrets of another Pod.Configure least-privilege access to SecretsTo enhance the security measures around Secrets, Kubernetes provides a mechanism: you can
annotate a ServiceAccount askubernetes.io/enforce-mountable-secrets: "true".For more information, you can refer to thedocumentation about this annotation.Warning:Any containers that run withprivileged: trueon a node can access all
Secrets used on that node.What's nextFor guidelines to manage and improve the security of your Secrets, refer toGood practices for Kubernetes Secrets.Learn how tomanage Secrets usingkubectlLearn how tomanage Secrets using config fileLearn how tomanage Secrets using kustomizeRead theAPI referenceforSecretFeedbackWas this page helpful?YesNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it onStack Overflow.
Open an issue in theGitHub Repositoryif you want toreport a problemorsuggest an improvement.Last modified July 24, 2024 at 5:00 PM PST:Fix a link text in secret.md (61b67bc9d1)Secret API referenceEdit this pageCreate child pageCreate documentation issuePrint entire sectionUses for SecretsUse case: dotfiles in a secret volumeUse case: Secret visible to one container in a PodAlternatives to SecretsTypes of SecretOpaque SecretsServiceAccount token SecretsDocker config SecretsBasic authentication SecretSSH authentication SecretsTLS SecretsBootstrap token SecretsWorking with SecretsCreating a SecretEditing a SecretUsing a SecretUsing Secrets as files from a PodUsing Secrets as environment variablesContainer image pull SecretsUsing Secrets with static PodsImmutable SecretsMarking a Secret as immutableInformation security for SecretsConfigure least-privilege access to SecretsWhat's nextDocumentationBlogTrainingPartnersCommunityCase Studies© 2024 The Kubernetes Authors | Documentation Distributed underCC BY 4.0Copyright © 2024 The Linux Foundation ®. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see ourTrademark Usage pageICP license: 京ICP备17074266号-3